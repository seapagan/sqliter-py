{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLiter","text":"<p>SQLiter is a lightweight Object-Relational Mapping (ORM) library for SQLite databases in Python. It provides a simplified interface for interacting with SQLite databases using Pydantic models. The only external run-time dependency is Pydantic itself.</p> <p>It does not aim to be a full-fledged ORM like SQLAlchemy, but rather a simple and easy-to-use library for basic database operations, especially for small projects. It is NOT asynchronous (at this time, though that is planned).</p> <p>The ideal use case is more for Python CLI tools that need to store data in a database-like format without needing to learn SQL or use a full ORM.</p> <p>Caution</p> <p>This project is still in development and is lacking some planned functionality. Please use with caution - Classes and methods may change until a stable release is made. I'll try to keep this to an absolute minimum and the releases and documentation will be very clear about any breaking changes.</p> <p>See the TODO for planned features and improvements.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Table creation based on Pydantic models</li> <li>Supports <code>date</code> and <code>datetime</code> fields.</li> <li>Support for complex data types (<code>list</code>, <code>dict</code>, <code>set</code>, <code>tuple</code>) stored as   BLOBs</li> <li>Foreign key relationships with referential integrity and CASCADE actions</li> <li>Automatic primary key generation</li> <li>User defined indexes on any field</li> <li>Set any field as UNIQUE</li> <li>CRUD operations (Create, Read, Update, Delete)</li> <li>Chained Query building with filtering, ordering, and pagination</li> <li>Transaction support</li> <li>Optional query result caching with LRU eviction, TTL, and memory limits</li> <li>Custom exceptions for better error handling</li> <li>Full type hinting and type checking</li> <li>Detailed documentation and examples</li> <li>Interactive TUI demo for exploring features</li> <li>No external dependencies other than Pydantic</li> <li>Full test coverage</li> <li>Can optionally output the raw SQL queries being executed for debugging   purposes.</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>For detailed documentation of every class, method, property, and constant, see the API Reference.</p>"},{"location":"#interactive-demo","title":"Interactive Demo","text":"<p>SQLiter includes an interactive terminal-based demo (TUI) that lets you explore all features hands-on without writing any code. Run the demo to see live code examples and their output:</p> <pre><code># Install with the demo extra\nuv add sqliter-py[demo]\n# or\npip install sqliter-py[demo]\n\n# Run the interactive demo\npython -m sqliter.tui\n</code></pre> <p>The demo includes:</p> <ul> <li>14 demo categories covering all SQLiter features</li> <li>Live code display with syntax highlighting</li> <li>One-click execution to see results in real-time</li> <li>Organized tutorials from basic to advanced topics</li> </ul> <p>For more information, see the Interactive Demo documentation.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install SQLiter using whichever method you prefer or is compatible with your project setup.</p> <p>With <code>uv</code> which is rapidly becoming my favorite tool for managing projects and virtual environments (<code>uv</code> is used for developing this project and in the CI):</p> <pre><code>uv add sqliter-py\n</code></pre> <p>With <code>Poetry</code>:</p> <pre><code>poetry add sqliter-py\n</code></pre> <p>Or with <code>pip</code>:</p> <pre><code>pip install sqliter-py\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Currently by default, the only external dependency is Pydantic. However, there are some optional dependencies that can be installed to enable additional features:</p>"},{"location":"installation/#demo","title":"Demo","text":"<p>The <code>demo</code> extra installs the Textual TUI framework, which is used for the interactive demo application:</p> <pre><code>uv add sqliter-py[demo]\n</code></pre> <p>This enables the <code>sqliter-demo</code> command and the <code>python -m sqliter.tui</code> interface for exploring SQLiter features interactively. See the Interactive Demo documentation for more details.</p>"},{"location":"installation/#extras","title":"Extras","text":"<p>The <code>extras</code> extra installs Inflect, which is used for grammatically correct pluralization:</p> <ol> <li>Table names: When auto-generating table names from model classes    (e.g., <code>Person</code> \u2192 <code>people</code> instead of <code>persons</code>)</li> <li>Reverse relationships: When auto-generating <code>related_name</code> for ORM    foreign keys (e.g., <code>Category</code> \u2192 <code>categories</code> instead of <code>categorys</code>)</li> </ol> <p>Without <code>inflect</code>, a simple \"s\" suffix is added (unless the name already ends in \"s\"). In most cases, the default works fine, but <code>inflect</code> handles irregular plurals correctly.</p> <p>Install with:</p> <pre><code>uv add 'sqliter-py[extras]'\n</code></pre>"},{"location":"installation/#full","title":"Full","text":"<p>The <code>full</code> extra installs all optional dependencies (both Textual and Inflect):</p> <pre><code>uv add sqliter-py[full]\n</code></pre> <p>This is recommended if you want access to all SQLiter features, including the interactive demo and proper pluralization.</p>"},{"location":"installation/#installation-summary","title":"Installation Summary","text":"Extra Includes Purpose (none) Pydantic only Basic ORM functionality <code>demo</code> + Textual Interactive TUI demo <code>extras</code> + Inflect Better pluralization <code>full</code> + Textual + Inflect All features"},{"location":"license/","title":"License","text":"<p>This project is licensed under the terms of the MIT license below:</p> <pre><code>The MIT License (MIT)\nCopyright (c) 2024-2026 Grant Ramsay\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Here's a quick example of how to use SQLiter:</p> <pre><code>from typing import Optional\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\n# Define your model\nclass User(BaseDBModel):\n    name: str\n    age: int\n    admin: Optional[bool] = False\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n\n# Create the table\ndb.create_table(User)\n\n# Insert a record\nuser = User(name=\"John Doe\", age=30)\nnew_user = db.insert(user)\n\n# Query records\nresults = db.select(User).filter(name=\"John Doe\").fetch_all()\nfor user in results:\n    print(f\"User: {user.name}, Age: {user.age}, Admin: {user.admin}\")\n\n# Update a record\nnew_user.age = 31\ndb.update(new_user)\n\nresults = db.select(User).filter(name=\"John Doe\").fetch_one()\n\nprint(\"Updated age:\", results.age)\n\n# Delete a record by primary key\ndb.delete(User, new_user.pk)\n\n# Delete all records returned from a query:\ndelete_count = db.select(User).filter(age__gt=30).delete()\n</code></pre> <p>See the Guide for more detailed information on how to use <code>SQLiter</code>.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section provides detailed documentation for every public class, method, property, function, and constant in the SQLiter library. Each entry includes the full signature, parameter descriptions, return types, and usage examples.</p> <p>Tip</p> <p>If you are new to SQLiter, start with the Guide for a tutorial-style introduction. This API Reference is intended as a comprehensive lookup resource.</p>"},{"location":"api-reference/#module-overview","title":"Module Overview","text":"Module Import Description <code>sqliter</code> <code>from sqliter import SqliterDB</code> Main database class <code>sqliter.model</code> <code>from sqliter.model import BaseDBModel</code> Base model (legacy mode) <code>sqliter.model</code> <code>from sqliter.model import unique</code> Unique constraint helper <code>sqliter.model</code> <code>from sqliter.model import ForeignKey</code> Foreign key factory (legacy mode) <code>sqliter.orm</code> <code>from sqliter.orm import BaseDBModel</code> Base model (ORM mode) <code>sqliter.orm</code> <code>from sqliter.orm import ForeignKey</code> Foreign key descriptor (ORM mode) <code>sqliter.orm</code> <code>from sqliter.orm import ManyToMany</code> Many-to-many descriptor (ORM mode) <code>sqliter.orm</code> <code>from sqliter.orm import ModelRegistry</code> Model registry <code>sqliter.query</code> (internal) QueryBuilder (returned by <code>db.select()</code>) <code>sqliter.exceptions</code> <code>from sqliter.exceptions import ...</code> Exception hierarchy <code>sqliter.helpers</code> (internal) Utility functions <code>sqliter.constants</code> (internal) Constant mappings <p>Note</p> <p>The ORM module (<code>sqliter.orm</code>) is an alternative import mode that extends the legacy <code>sqliter.model</code> with lazy loading and reverse relationships. See ORM Mode for details.</p>"},{"location":"api-reference/#pages","title":"Pages","text":"<ul> <li>SqliterDB -- Main entry point for all database   operations: connections, tables, CRUD, caching, and transactions.</li> </ul> <ul> <li>BaseDBModel -- Pydantic-based base class for   defining database models, plus the <code>unique()</code> constraint helper.</li> </ul> <ul> <li>QueryBuilder -- Fluent API for filtering,   ordering, paginating, and executing queries.</li> </ul> <ul> <li>Foreign Keys -- <code>ForeignKey()</code> factory   function, <code>ForeignKeyInfo</code> dataclass, and <code>FKAction</code> type alias   (legacy mode).</li> </ul> <ul> <li>ORM Mode -- Extended <code>BaseDBModel</code> with lazy loading,   <code>ForeignKey</code> descriptor, <code>LazyLoader</code>, <code>ModelRegistry</code>,   <code>ReverseQuery</code>, and <code>ReverseRelationship</code>.</li> </ul> <ul> <li>Many-to-Many -- <code>ManyToMany</code> descriptor,   <code>ManyToManyManager</code> API, reverse accessors, and junction tables.</li> </ul> <ul> <li>Exceptions -- Full hierarchy of 17 exception   classes with message templates and usage context.</li> </ul> <ul> <li>Helpers &amp; Constants -- Internal utility functions   and constant mappings used by the library.</li> </ul>"},{"location":"api-reference/base-model/","title":"BaseDBModel","text":"<p>The base class for all SQLiter database models. Extends Pydantic's <code>BaseModel</code> with database-specific functionality including automatic primary keys, timestamps, table name inference, and field serialization.</p> <pre><code>from sqliter.model import BaseDBModel\n</code></pre> <p>Source: <code>sqliter/model/model.py</code>, <code>sqliter/model/unique.py</code></p> <p>See also: Guide -- Models, Guide -- Fields</p> <p>Note</p> <p>This page documents the legacy mode <code>BaseDBModel</code> from <code>sqliter.model</code>. For the ORM-mode version with lazy loading and reverse relationships, see ORM Mode.</p>"},{"location":"api-reference/base-model/#built-in-fields","title":"Built-in Fields","text":"<p>Every model automatically includes these fields:</p> Field Type Default Description <code>pk</code> <code>int</code> <code>0</code> Auto-incrementing primary key (set on insert) <code>created_at</code> <code>int</code> <code>0</code> Unix timestamp when the record was created <code>updated_at</code> <code>int</code> <code>0</code> Unix timestamp when the record was last updated <p><code>pk</code> is managed by SQLite's <code>AUTOINCREMENT</code>. The <code>created_at</code> and <code>updated_at</code> timestamps are set automatically by <code>SqliterDB.insert()</code> and <code>SqliterDB.update()</code>.</p>"},{"location":"api-reference/base-model/#model-configuration","title":"Model Configuration","text":"<p><code>BaseDBModel</code> uses the following Pydantic <code>ConfigDict</code>:</p> <pre><code>model_config = ConfigDict(\n    extra=\"ignore\",\n    populate_by_name=True,\n    validate_assignment=True,\n    from_attributes=True,\n)\n</code></pre> Option Value Effect <code>extra</code> <code>\"ignore\"</code> Extra fields in input data are silently ignored <code>populate_by_name</code> <code>True</code> Fields can be populated by name or alias <code>validate_assignment</code> <code>True</code> Field values are validated on assignment <code>from_attributes</code> <code>True</code> Models can be created from objects with attributes"},{"location":"api-reference/base-model/#inner-class-meta","title":"Inner Class <code>Meta</code>","text":"<p>Configure database-specific attributes via the <code>Meta</code> inner class.</p> <pre><code>class MyModel(BaseDBModel):\n    name: str\n\n    class Meta:\n        table_name = \"custom_table\"\n        indexes = [\"name\"]\n        unique_indexes = [(\"name\", \"email\")]\n</code></pre> <p>Attributes:</p> Attribute Type Default Description <code>table_name</code> <code>str</code> | <code>None</code> <code>None</code> Custom table name; auto-generated from class name if not set <code>indexes</code> <code>list[str]</code> | <code>list[tuple[str, ...]]</code> <code>[]</code> Fields for regular indexes; use tuples for composite indexes <code>unique_indexes</code> <code>list[str]</code> | <code>list[tuple[str, ...]]</code> <code>[]</code> Fields for unique indexes; use tuples for composite indexes"},{"location":"api-reference/base-model/#class-methods","title":"Class Methods","text":""},{"location":"api-reference/base-model/#get_table_name","title":"<code>get_table_name()</code>","text":"<p>Get the database table name for the model.</p> <pre><code>@classmethod\ndef get_table_name(cls) -&gt; str:\n</code></pre> <p>Returns:</p> <p><code>str</code> -- The table name. If <code>Meta.table_name</code> is set, returns that value. Otherwise, the class name is converted to <code>snake_case</code>, the suffix <code>Model</code> is removed (if present), and the result is pluralized.</p> <p>If the <code>inflect</code> library is installed, grammatically correct pluralization is used (e.g., <code>\"person\"</code> becomes <code>\"people\"</code>). Otherwise, a simple <code>\"s\"</code> suffix is added.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> -- If the table name contains invalid characters.</li> </ul> <p>Example:</p> <pre><code>class UserProfile(BaseDBModel):\n    name: str\n\nUserProfile.get_table_name()  # \"user_profiles\"\n</code></pre>"},{"location":"api-reference/base-model/#get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>Returns the name of the primary key field (always <code>\"pk\"</code>).</p> <pre><code>@classmethod\ndef get_primary_key(cls) -&gt; str:\n</code></pre> <p>Returns:</p> <p><code>str</code> -- Always <code>\"pk\"</code>.</p>"},{"location":"api-reference/base-model/#should_create_pk","title":"<code>should_create_pk()</code>","text":"<p>Returns whether the primary key should be created (always <code>True</code>).</p> <pre><code>@classmethod\ndef should_create_pk(cls) -&gt; bool:\n</code></pre> <p>Returns:</p> <p><code>bool</code> -- Always <code>True</code>.</p>"},{"location":"api-reference/base-model/#serialize_field","title":"<code>serialize_field()</code>","text":"<p>Serialize a field value for SQLite storage.</p> <pre><code>@classmethod\ndef serialize_field(\n    cls,\n    value: SerializableField,\n) -&gt; SerializableField:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>value</code> <code>SerializableField</code> required The field value to serialize <p>Returns:</p> <p><code>SerializableField</code> -- The serialized value:</p> <ul> <li><code>datetime</code> / <code>date</code> objects are converted to Unix timestamps (via   <code>to_unix_timestamp()</code>).</li> <li><code>list</code>, <code>dict</code>, <code>set</code>, <code>tuple</code> values are serialized with <code>pickle</code>.</li> <li>All other values are returned as-is.</li> </ul>"},{"location":"api-reference/base-model/#deserialize_field","title":"<code>deserialize_field()</code>","text":"<p>Deserialize a field value from SQLite storage back to a Python object.</p> <pre><code>@classmethod\ndef deserialize_field(\n    cls,\n    field_name: str,\n    value: SerializableField,\n    *,\n    return_local_time: bool,\n) -&gt; object:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>field_name</code> <code>str</code> required Name of the field being deserialized <code>value</code> <code>SerializableField</code> required The value from the database <code>return_local_time</code> <code>bool</code> required Whether to localize datetime values <p>Returns:</p> <p><code>object</code> -- The deserialized value:</p> <ul> <li>Integer values in <code>datetime</code>/<code>date</code> fields are converted back using   <code>from_unix_timestamp()</code>.</li> <li><code>bytes</code> values in <code>list</code>/<code>dict</code>/<code>set</code>/<code>tuple</code> fields are   deserialized with <code>pickle</code>.</li> <li><code>None</code> values return <code>None</code>.</li> <li>All other values are returned as-is.</li> </ul>"},{"location":"api-reference/base-model/#model_validate_partial","title":"<code>model_validate_partial()</code>","text":"<p>Create a model instance from partial data (not all fields required). Used internally when fetching partial field selections.</p> <pre><code>@classmethod\ndef model_validate_partial(\n    cls,\n    obj: dict[str, Any],\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>obj</code> <code>dict[str, Any]</code> required Dictionary of field names and values <p>Returns:</p> <p><code>Self</code> -- A model instance constructed with the provided data.</p>"},{"location":"api-reference/base-model/#protocol","title":"Protocol","text":""},{"location":"api-reference/base-model/#serializablefield","title":"<code>SerializableField</code>","text":"<p>Protocol for fields that can be serialized or deserialized. Used as a type hint for <code>serialize_field()</code> and <code>deserialize_field()</code>.</p> <pre><code>class SerializableField(Protocol):\n    \"\"\"Protocol for fields that can be serialized or deserialized.\"\"\"\n</code></pre>"},{"location":"api-reference/base-model/#unique","title":"<code>unique()</code>","text":"<p>Create a Pydantic <code>Field</code> with a unique constraint marker in <code>json_schema_extra</code>.</p> <pre><code>from sqliter.model import unique\n</code></pre> <pre><code>def unique(\n    default: Any = ...,\n    **kwargs: Any,\n) -&gt; Any:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>default</code> <code>Any</code> <code>...</code> Default value for the field <code>**kwargs</code> <code>Any</code> Additional arguments passed to Pydantic <code>Field</code> <p>Returns:</p> <p>A Pydantic <code>Field</code> with <code>json_schema_extra={\"unique\": True}</code>.</p> <p>Example:</p> <pre><code>from typing import Annotated\n\nfrom sqliter.model import BaseDBModel, unique\n\n\nclass User(BaseDBModel):\n    email: Annotated[str, unique()]\n    username: Annotated[str, unique(default=\"anonymous\")]\n</code></pre> <p>Tip</p> <p>Using <code>Annotated</code> is optional but recommended. Without it, type checkers like MyPy will report an incompatible assignment because <code>unique()</code> returns a Pydantic <code>Field</code>, not a <code>str</code>. The plain syntax <code>email: str = unique()</code> still works at runtime.</p>"},{"location":"api-reference/base-model/#unique-deprecated","title":"<code>Unique()</code> (Deprecated)","text":"<p>Caution</p> <p><code>Unique()</code> is deprecated and will be removed in a future version. Use <code>unique()</code> instead.</p> <pre><code>from sqliter.model import Unique  # Deprecated\n</code></pre> <p>Wrapper around <code>unique()</code> that emits a <code>DeprecationWarning</code>.</p>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":"<p>All exceptions in SQLiter inherit from <code>SqliterError</code>. Import them from <code>sqliter.exceptions</code>:</p> <pre><code>from sqliter.exceptions import (\n    SqliterError,\n    DatabaseConnectionError,\n    RecordInsertionError,\n    # ...\n)\n</code></pre> <p>Source: <code>sqliter/exceptions.py</code></p> <p>See also: Guide -- Exceptions</p>"},{"location":"api-reference/exceptions/#hierarchy","title":"Hierarchy","text":"<pre><code>Exception\n\u2514\u2500\u2500 SqliterError\n    \u251c\u2500\u2500 DatabaseConnectionError\n    \u251c\u2500\u2500 TableCreationError\n    \u251c\u2500\u2500 TableDeletionError\n    \u251c\u2500\u2500 RecordInsertionError\n    \u251c\u2500\u2500 RecordUpdateError\n    \u251c\u2500\u2500 RecordNotFoundError\n    \u251c\u2500\u2500 RecordFetchError\n    \u251c\u2500\u2500 RecordDeletionError\n    \u251c\u2500\u2500 InvalidFilterError\n    \u251c\u2500\u2500 InvalidOffsetError\n    \u251c\u2500\u2500 InvalidOrderError\n    \u251c\u2500\u2500 InvalidRelationshipError\n    \u251c\u2500\u2500 InvalidPrefetchError\n    \u251c\u2500\u2500 InvalidIndexError\n    \u251c\u2500\u2500 ForeignKeyError\n    \u2502   \u251c\u2500\u2500 ForeignKeyConstraintError\n    \u2502   \u2514\u2500\u2500 InvalidForeignKeyError\n    \u2514\u2500\u2500 SqlExecutionError\n</code></pre>"},{"location":"api-reference/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"api-reference/exceptions/#sqlitererror","title":"<code>SqliterError</code>","text":"<p>Base exception class for all SQLiter-specific errors.</p> <pre><code>class SqliterError(Exception):\n    message_template: str = \"An error occurred in the SQLiter package.\"\n</code></pre> <p>Attributes:</p> Attribute Type Description <code>message_template</code> <code>str</code> Template string formatted with <code>*args</code> <code>original_exception</code> <code>Exception</code> The caught exception that triggered this error (if any) <p>Behavior:</p> <ul> <li>Formats <code>message_template</code> with positional <code>*args</code>.</li> <li>Captures the active exception via <code>sys.exc_info()</code> and appends its   type, location, and message.</li> <li>Chains the original exception using <code>__cause__</code>.</li> </ul>"},{"location":"api-reference/exceptions/#connection-exceptions","title":"Connection Exceptions","text":""},{"location":"api-reference/exceptions/#databaseconnectionerror","title":"<code>DatabaseConnectionError</code>","text":"<p>Raised when a database connection cannot be established.</p> <pre><code>message_template = \"Failed to connect to the database: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.connect()</code></li> </ul>"},{"location":"api-reference/exceptions/#table-exceptions","title":"Table Exceptions","text":""},{"location":"api-reference/exceptions/#tablecreationerror","title":"<code>TableCreationError</code>","text":"<p>Raised when a table cannot be created in the database.</p> <pre><code>message_template = \"Failed to create the table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.create_table()</code></li> </ul>"},{"location":"api-reference/exceptions/#tabledeletionerror","title":"<code>TableDeletionError</code>","text":"<p>Raised when a table cannot be deleted from the database.</p> <pre><code>message_template = \"Failed to delete the table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.drop_table()</code></li> </ul>"},{"location":"api-reference/exceptions/#record-exceptions","title":"Record Exceptions","text":""},{"location":"api-reference/exceptions/#recordinsertionerror","title":"<code>RecordInsertionError</code>","text":"<p>Raised when a record cannot be inserted into the database.</p> <pre><code>message_template = \"Failed to insert record into table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.insert()</code></li> </ul>"},{"location":"api-reference/exceptions/#recordupdateerror","title":"<code>RecordUpdateError</code>","text":"<p>Raised when a record cannot be updated in the database.</p> <pre><code>message_template = \"Failed to update record in table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.update()</code></li> </ul>"},{"location":"api-reference/exceptions/#recordnotfounderror","title":"<code>RecordNotFoundError</code>","text":"<p>Raised when a requested record is not found in the database.</p> <pre><code>message_template = \"Failed to find that record in the table (key '{}') \"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.update()</code> (when no rows match)</li> <li><code>SqliterDB.delete()</code> (when no rows match)</li> </ul>"},{"location":"api-reference/exceptions/#recordfetcherror","title":"<code>RecordFetchError</code>","text":"<p>Raised on an error fetching records from the database.</p> <pre><code>message_template = \"Failed to fetch record from table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.get()</code></li> <li><code>QueryBuilder._execute_query()</code> (internal)</li> </ul>"},{"location":"api-reference/exceptions/#recorddeletionerror","title":"<code>RecordDeletionError</code>","text":"<p>Raised when a record cannot be deleted from the database.</p> <pre><code>message_template = \"Failed to delete record from table: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.delete()</code></li> <li><code>QueryBuilder.delete()</code></li> </ul>"},{"location":"api-reference/exceptions/#query-exceptions","title":"Query Exceptions","text":""},{"location":"api-reference/exceptions/#invalidfiltererror","title":"<code>InvalidFilterError</code>","text":"<p>Raised when an invalid filter is applied to a query.</p> <pre><code>message_template = \"Failed to apply filter: invalid field '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>QueryBuilder.filter()</code></li> </ul>"},{"location":"api-reference/exceptions/#invalidoffseterror","title":"<code>InvalidOffsetError</code>","text":"<p>Raised when an invalid offset value is provided.</p> <pre><code>message_template = (\n    \"Invalid offset value: '{}'. Offset must be a positive integer.\"\n)\n</code></pre> <p>Raised by:</p> <ul> <li><code>QueryBuilder.offset()</code></li> </ul>"},{"location":"api-reference/exceptions/#invalidordererror","title":"<code>InvalidOrderError</code>","text":"<p>Raised when an invalid order specification is provided.</p> <pre><code>message_template = \"Invalid order value - {}\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>QueryBuilder.order()</code></li> </ul>"},{"location":"api-reference/exceptions/#invalidrelationshiperror","title":"<code>InvalidRelationshipError</code>","text":"<p>Raised when an invalid relationship path is specified in <code>select_related()</code> or relationship filter traversal.</p> <pre><code>message_template = (\n    \"Invalid relationship path '{}': field '{}' is not a valid \"\n    \"foreign key relationship on model {}\"\n)\n</code></pre> <p>Raised by:</p> <ul> <li><code>QueryBuilder.select_related()</code></li> <li><code>QueryBuilder.filter()</code> (relationship   traversal)</li> </ul>"},{"location":"api-reference/exceptions/#invalidprefetcherror","title":"<code>InvalidPrefetchError</code>","text":"<p>Raised when an invalid relationship path is specified in <code>prefetch_related()</code>. This includes paths that don't exist, forward FK paths (which should use <code>select_related()</code>), and any attribute that is not a reverse FK or M2M relationship.</p> <pre><code>message_template = (\n    \"Invalid prefetch path '{}': '{}' is not a reverse \"\n    \"foreign key or many-to-many relationship on model {}\"\n)\n</code></pre> <p>Raised by:</p> <ul> <li><code>QueryBuilder.prefetch_related()</code></li> </ul>"},{"location":"api-reference/exceptions/#index-exceptions","title":"Index Exceptions","text":""},{"location":"api-reference/exceptions/#invalidindexerror","title":"<code>InvalidIndexError</code>","text":"<p>Raised when one or more fields specified for an index do not exist in the model's fields. Has a custom <code>__init__</code> that accepts structured arguments.</p> <pre><code>class InvalidIndexError(SqliterError):\n    message_template = \"Invalid fields for indexing in model '{}': {}\"\n\n    def __init__(\n        self,\n        invalid_fields: list[str],\n        model_class: str,\n    ) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>invalid_fields</code> <code>list[str]</code> Fields that do not exist in the model <code>model_class</code> <code>str</code> Name of the model class <p>Attributes:</p> Attribute Type Description <code>invalid_fields</code> <code>list[str]</code> The invalid field names (from <code>__init__</code> parameter) <code>model_class</code> <code>str</code> The model class name (from <code>__init__</code> parameter) <p>Raised by:</p> <ul> <li><code>SqliterDB.create_table()</code> (during   index creation)</li> </ul>"},{"location":"api-reference/exceptions/#foreign-key-exceptions","title":"Foreign Key Exceptions","text":""},{"location":"api-reference/exceptions/#foreignkeyerror","title":"<code>ForeignKeyError</code>","text":"<p>Base exception for foreign key related errors.</p> <pre><code>message_template = \"Foreign key error: {}\"\n</code></pre>"},{"location":"api-reference/exceptions/#foreignkeyconstrainterror","title":"<code>ForeignKeyConstraintError</code>","text":"<p>Raised when a foreign key constraint is violated (e.g., inserting a record with a FK value that does not exist in the referenced table, or deleting a record that is still referenced).</p> <pre><code>message_template = (\n    \"Foreign key constraint violation: Cannot {} record - \"\n    \"referenced record {}\"\n)\n</code></pre> <p>Raised by:</p> <ul> <li><code>SqliterDB.insert()</code> (FK value not in   referenced table)</li> <li><code>SqliterDB.delete()</code> (record still referenced   with RESTRICT)</li> </ul>"},{"location":"api-reference/exceptions/#invalidforeignkeyerror","title":"<code>InvalidForeignKeyError</code>","text":"<p>Raised when an invalid foreign key configuration is detected (e.g., using <code>SET NULL</code> without <code>null=True</code>).</p> <pre><code>message_template = \"Invalid foreign key configuration: {}\"\n</code></pre> <p>Raised by:</p> <ul> <li><code>ForeignKey()</code> factory function</li> </ul>"},{"location":"api-reference/exceptions/#sql-exceptions","title":"SQL Exceptions","text":""},{"location":"api-reference/exceptions/#sqlexecutionerror","title":"<code>SqlExecutionError</code>","text":"<p>Raised when a raw SQL execution fails.</p> <pre><code>message_template = \"Failed to execute SQL: '{}'\"\n</code></pre> <p>Raised by:</p> <ul> <li>Internal <code>SqliterDB._execute_sql()</code> method (used by   <code>create_table()</code>, <code>drop_table()</code>, and index creation)</li> </ul>"},{"location":"api-reference/foreign-keys/","title":"Foreign Keys (Legacy Mode)","text":"<p>This page documents the legacy-mode foreign key support. For the ORM-mode <code>ForeignKey</code> descriptor with lazy loading, see ORM Mode.</p> <p>Source: <code>sqliter/model/foreign_key.py</code></p> <p>See also: Guide -- Foreign Keys, Explicit Foreign Keys</p>"},{"location":"api-reference/foreign-keys/#fkaction","title":"<code>FKAction</code>","text":"<p>Type alias for the allowed foreign key actions.</p> <pre><code>FKAction = Literal[\"CASCADE\", \"SET NULL\", \"RESTRICT\", \"NO ACTION\"]\n</code></pre> Value Description <code>\"CASCADE\"</code> Propagate the operation to referencing records (delete or update them) <code>\"SET NULL\"</code> Set the foreign key field to <code>NULL</code> (requires <code>null=True</code>) <code>\"RESTRICT\"</code> Prevent the operation if references exist (default) <code>\"NO ACTION\"</code> Similar to <code>RESTRICT</code> in SQLite"},{"location":"api-reference/foreign-keys/#foreignkey","title":"<code>ForeignKey()</code>","text":"<p>Factory function that creates a Pydantic <code>Field</code> with foreign key metadata stored in <code>json_schema_extra</code>.</p> <pre><code>def ForeignKey(\n    to: type[BaseDBModel],\n    *,\n    on_delete: FKAction = \"RESTRICT\",\n    on_update: FKAction = \"RESTRICT\",\n    null: bool = False,\n    unique: bool = False,\n    related_name: str | None = None,\n    db_column: str | None = None,\n    default: Any = ...,\n    **kwargs: Any,\n) -&gt; Any:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>to</code> <code>type[BaseDBModel]</code> required Target model class referenced by this FK <code>on_delete</code> <code>FKAction</code> <code>\"RESTRICT\"</code> Action when referenced record is deleted <code>on_update</code> <code>FKAction</code> <code>\"RESTRICT\"</code> Action when referenced record's PK is updated <code>null</code> <code>bool</code> <code>False</code> Whether the FK field can be <code>NULL</code> <code>unique</code> <code>bool</code> <code>False</code> Whether the FK must be unique (one-to-one) <code>related_name</code> <code>str</code> | <code>None</code> <code>None</code> Name for reverse relationship (reserved) <code>db_column</code> <code>str</code> | <code>None</code> <code>None</code> Custom column name; defaults to <code>{field_name}_id</code> <code>default</code> <code>Any</code> <code>...</code> Default value; auto-set to <code>None</code> if <code>null=True</code> <code>**kwargs</code> <code>Any</code> Additional arguments passed to Pydantic <code>Field</code> <p>Returns:</p> <p>A Pydantic <code>Field</code> with foreign key metadata.</p> <p>Raises:</p> <ul> <li><code>InvalidForeignKeyError</code> --   If <code>on_delete=\"SET NULL\"</code> or <code>on_update=\"SET NULL\"</code> is used without   <code>null=True</code>.</li> </ul> <p>Example:</p> <pre><code>from sqliter.model import BaseDBModel, ForeignKey\n\n\nclass Author(BaseDBModel):\n    name: str\n\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"CASCADE\")\n</code></pre>"},{"location":"api-reference/foreign-keys/#foreignkeyinfo","title":"<code>ForeignKeyInfo</code>","text":"<p>Dataclass holding metadata about a foreign key relationship. Created internally by <code>ForeignKey()</code> and stored in the field's <code>json_schema_extra[\"foreign_key\"]</code>.</p> <pre><code>@dataclass\nclass ForeignKeyInfo:\n    to_model: type[BaseDBModel]\n    on_delete: FKAction\n    on_update: FKAction\n    null: bool\n    unique: bool\n    related_name: str | None\n    db_column: str | None\n</code></pre> <p>Fields:</p> Field Type Description <code>to_model</code> <code>type[BaseDBModel]</code> Target model class <code>on_delete</code> <code>FKAction</code> Delete action <code>on_update</code> <code>FKAction</code> Update action <code>null</code> <code>bool</code> Whether the FK is nullable <code>unique</code> <code>bool</code> Whether the FK must be unique <code>related_name</code> <code>str</code> | <code>None</code> Reverse relationship name <code>db_column</code> <code>str</code> | <code>None</code> Custom column name"},{"location":"api-reference/foreign-keys/#get_foreign_key_info","title":"<code>get_foreign_key_info()</code>","text":"<p>Extract <code>ForeignKeyInfo</code> from a Pydantic <code>FieldInfo</code> object, if the field is a foreign key.</p> <pre><code>def get_foreign_key_info(\n    field_info: FieldInfo,\n) -&gt; ForeignKeyInfo | None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>field_info</code> <code>FieldInfo</code> required The Pydantic field info to examine <p>Returns:</p> <p><code>ForeignKeyInfo | None</code> -- The FK metadata if the field is a foreign key, <code>None</code> otherwise.</p> <p>Example:</p> <pre><code>from sqliter.model.foreign_key import get_foreign_key_info\n\nfield_info = Book.model_fields[\"author_id\"]\nfk_info = get_foreign_key_info(field_info)\nif fk_info:\n    print(fk_info.to_model)   # &lt;class 'Author'&gt;\n    print(fk_info.on_delete)  # \"CASCADE\"\n</code></pre>"},{"location":"api-reference/helpers/","title":"Helpers &amp; Constants","text":"<p>Internal utility functions and constant mappings used by the SQLiter library. These are not part of the public API but are documented here for completeness.</p> <p>Sources: <code>sqliter/helpers.py</code>, <code>sqliter/constants.py</code></p>"},{"location":"api-reference/helpers/#functions","title":"Functions","text":""},{"location":"api-reference/helpers/#infer_sqlite_type","title":"<code>infer_sqlite_type()</code>","text":"<p>Map a Python type to its corresponding SQLite column type. Used during table creation.</p> <pre><code>def infer_sqlite_type(\n    field_type: type | None,\n) -&gt; str:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>field_type</code> <code>type</code> | <code>None</code> required The Python type to map <p>Returns:</p> <p><code>str</code> -- The SQLite column type (e.g., <code>\"INTEGER\"</code>, <code>\"TEXT\"</code>). Defaults to <code>\"TEXT\"</code> if the type is <code>None</code> or not recognized.</p> <p>Example:</p> <pre><code>from sqliter.helpers import infer_sqlite_type\n\ninfer_sqlite_type(int)    # \"INTEGER\"\ninfer_sqlite_type(str)    # \"TEXT\"\ninfer_sqlite_type(float)  # \"REAL\"\ninfer_sqlite_type(None)   # \"TEXT\"\n</code></pre>"},{"location":"api-reference/helpers/#to_unix_timestamp","title":"<code>to_unix_timestamp()</code>","text":"<p>Convert a <code>datetime</code> or <code>date</code> object to a Unix timestamp (integer) in UTC. Naive datetimes are assumed to be in the user's local timezone.</p> <pre><code>def to_unix_timestamp(\n    value: datetime.date | datetime.datetime,\n) -&gt; int:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>value</code> <code>datetime.date</code> | <code>datetime.datetime</code> required The value to convert <p>Returns:</p> <p><code>int</code> -- Unix timestamp.</p> <p>Raises:</p> <ul> <li><code>TypeError</code> -- If <code>value</code> is not a <code>datetime</code> or <code>date</code> object.</li> </ul> <p>Example:</p> <pre><code>import datetime\nfrom sqliter.helpers import to_unix_timestamp\n\ndt = datetime.datetime(2024, 1, 15, 12, 0, 0)\nts = to_unix_timestamp(dt)  # e.g. 1705320000\n</code></pre>"},{"location":"api-reference/helpers/#from_unix_timestamp","title":"<code>from_unix_timestamp()</code>","text":"<p>Convert a Unix timestamp back to a <code>datetime</code> or <code>date</code> object, optionally converting to the user's local timezone.</p> <pre><code>def from_unix_timestamp(\n    value: int,\n    to_type: type,\n    *,\n    localize: bool = True,\n) -&gt; datetime.date | datetime.datetime:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>value</code> <code>int</code> required The Unix timestamp <code>to_type</code> <code>type</code> required Target type (<code>datetime.datetime</code> or <code>datetime.date</code>) <code>localize</code> <code>bool</code> <code>True</code> If <code>True</code>, convert to local timezone <p>Returns:</p> <p><code>datetime.date | datetime.datetime</code> -- The converted value.</p> <p>Raises:</p> <ul> <li><code>TypeError</code> -- If <code>to_type</code> is not <code>datetime.datetime</code> or   <code>datetime.date</code>.</li> </ul> <p>Example:</p> <pre><code>import datetime\nfrom sqliter.helpers import from_unix_timestamp\n\ndt = from_unix_timestamp(1705320000, datetime.datetime)\nd = from_unix_timestamp(1705320000, datetime.date)\n</code></pre>"},{"location":"api-reference/helpers/#constants","title":"Constants","text":""},{"location":"api-reference/helpers/#operator_mapping","title":"<code>OPERATOR_MAPPING</code>","text":"<p>Maps SQLiter filter operator suffixes to their SQL equivalents. Used by <code>QueryBuilder.filter()</code>.</p> Operator SQL Description <code>__lt</code> <code>&lt;</code> Less than <code>__lte</code> <code>&lt;=</code> Less than or equal <code>__gt</code> <code>&gt;</code> Greater than <code>__gte</code> <code>&gt;=</code> Greater than or equal <code>__eq</code> <code>=</code> Equal (default when no suffix) <code>__ne</code> <code>!=</code> Not equal <code>__in</code> <code>IN</code> Value in list <code>__not_in</code> <code>NOT IN</code> Value not in list <code>__isnull</code> <code>IS NULL</code> Field is NULL <code>__notnull</code> <code>IS NOT NULL</code> Field is not NULL <code>__like</code> <code>LIKE</code> Raw SQL LIKE pattern <code>__startswith</code> <code>GLOB</code> Case-sensitive starts with <code>__endswith</code> <code>GLOB</code> Case-sensitive ends with <code>__contains</code> <code>GLOB</code> Case-sensitive contains <code>__istartswith</code> <code>LIKE</code> Case-insensitive starts with <code>__iendswith</code> <code>LIKE</code> Case-insensitive ends with <code>__icontains</code> <code>LIKE</code> Case-insensitive contains <p>Note</p> <p>The <code>__startswith</code>, <code>__endswith</code>, and <code>__contains</code> operators use SQLite's <code>GLOB</code> for case-sensitive matching. The <code>i</code>-prefixed variants use <code>LIKE</code> for case-insensitive matching. The <code>__like</code> operator expects a full SQL <code>LIKE</code> pattern (including any <code>%</code> wildcards).</p>"},{"location":"api-reference/helpers/#sqlite_type_mapping","title":"<code>SQLITE_TYPE_MAPPING</code>","text":"<p>Maps Python types to SQLite column types. Used by <code>infer_sqlite_type()</code>.</p> Python Type SQLite Type Notes <code>int</code> <code>INTEGER</code> <code>float</code> <code>REAL</code> <code>str</code> <code>TEXT</code> <code>bool</code> <code>INTEGER</code> Stored as 0 or 1 <code>bytes</code> <code>BLOB</code> <code>datetime.datetime</code> <code>INTEGER</code> Stored as Unix timestamp <code>datetime.date</code> <code>INTEGER</code> Stored as Unix timestamp <code>list</code> <code>BLOB</code> Serialized with <code>pickle</code> <code>dict</code> <code>BLOB</code> Serialized with <code>pickle</code> <code>set</code> <code>BLOB</code> Serialized with <code>pickle</code> <code>tuple</code> <code>BLOB</code> Serialized with <code>pickle</code>"},{"location":"api-reference/many-to-many/","title":"Many-to-Many (ORM)","text":"<p>The ORM module provides a <code>ManyToMany</code> descriptor and manager API for many-to-many relationships. Junction tables are created automatically when you call <code>SqliterDB.create_table()</code> on a model that defines an M2M field.</p> <pre><code>from sqliter.orm import BaseDBModel, ManyToMany\n</code></pre> <p>Sources: <code>sqliter/orm/m2m.py</code>, <code>sqliter/orm/registry.py</code>, <code>sqliter/sqliter.py</code></p>"},{"location":"api-reference/many-to-many/#manytomanyt","title":"<code>ManyToMany[T]</code>","text":"<p>Descriptor used on ORM models.</p> <pre><code>class ManyToMany(Generic[T]):\n    def __init__(\n        self,\n        to_model: type[T] | str,\n        *,\n        through: str | None = None,\n        related_name: str | None = None,\n        symmetrical: bool = False,\n    ) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>to_model</code> <code>type[T]</code> | <code>str</code> required Related model or forward ref <code>through</code> <code>str</code> | <code>None</code> <code>None</code> Custom junction table name <code>related_name</code> <code>str</code> | <code>None</code> <code>None</code> Reverse accessor name <code>symmetrical</code> <code>bool</code> <code>False</code> Self-referential symmetry <p>Notes:</p> <ul> <li>When <code>symmetrical=True</code> and <code>to_model</code> is the same class, SQLiter   stores a single row per pair and returns the relationship from either   side. No reverse accessor is created for symmetrical self-relations.</li> <li><code>to_model</code> can be a string forward ref. The relationship resolves when   the target model class is registered.</li> <li>Reverse accessors are created automatically when <code>related_name</code> is set   or auto-generated.</li> </ul>"},{"location":"api-reference/many-to-many/#manytomanymanager","title":"<code>ManyToManyManager</code>","text":"<p>Returned when accessing the descriptor from an instance.</p> <pre><code>tags = article.tags\n</code></pre> <p>Methods:</p> <ul> <li><code>add(*instances) -&gt; None</code></li> <li><code>remove(*instances) -&gt; None</code></li> <li><code>clear() -&gt; None</code></li> <li><code>set(*instances) -&gt; None</code></li> <li><code>fetch_all() -&gt; list[T]</code></li> <li><code>fetch_one() -&gt; T | None</code></li> <li><code>count() -&gt; int</code></li> <li><code>exists() -&gt; bool</code></li> <li><code>filter(**kwargs) -&gt; QueryBuilder[Any]</code></li> </ul> <p>All methods require a valid <code>db_context</code>, which is set on instances returned from <code>SqliterDB</code> operations.</p>"},{"location":"api-reference/many-to-many/#reversemanytomany","title":"<code>ReverseManyToMany</code>","text":"<p>Reverse accessor descriptor automatically installed on the target model unless suppressed (symmetrical self-ref).</p> <pre><code>articles = tag.articles.fetch_all()\n</code></pre>"},{"location":"api-reference/many-to-many/#prefetchedm2mresult","title":"<code>PrefetchedM2MResult</code>","text":"<p>Returned when accessing an M2M relationship that was loaded via <code>prefetch_related()</code>. Wraps a cached list of related instances and provides the same interface as <code>ManyToManyManager</code>.</p> <pre><code>from sqliter.orm.m2m import PrefetchedM2MResult\n</code></pre> <p>Read methods (served from cache, no DB query):</p> <ul> <li><code>fetch_all() -&gt; list[T]</code></li> <li><code>fetch_one() -&gt; T | None</code></li> <li><code>count() -&gt; int</code></li> <li><code>exists() -&gt; bool</code></li> </ul> <p>Write methods (delegated to the real <code>ManyToManyManager</code>):</p> <ul> <li><code>add(*instances) -&gt; None</code></li> <li><code>remove(*instances) -&gt; None</code></li> <li><code>clear() -&gt; None</code></li> <li><code>set(*instances) -&gt; None</code></li> </ul> <p>Filter (falls back to a real DB query via the manager):</p> <ul> <li><code>filter(**kwargs) -&gt; QueryBuilder[Any]</code></li> </ul> <p>Example:</p> <pre><code>articles = db.select(Article).prefetch_related(\"tags\").fetch_all()\nguide = articles[0]\n\nisinstance(guide.tags, PrefetchedM2MResult)  # True\nguide.tags.count()       # served from cache\nguide.tags.add(new_tag)  # delegates to ManyToManyManager\n</code></pre>"},{"location":"api-reference/many-to-many/#prefetchedresult-reverse-fk","title":"<code>PrefetchedResult</code> (Reverse FK)","text":"<p>Returned when accessing a reverse FK relationship that was loaded via <code>prefetch_related()</code>. Wraps a cached list of related instances.</p> <pre><code>from sqliter.orm.query import PrefetchedResult\n</code></pre> <p>Read methods (served from cache):</p> <ul> <li><code>fetch_all() -&gt; list[BaseDBModel]</code></li> <li><code>fetch_one() -&gt; BaseDBModel | None</code></li> <li><code>count() -&gt; int</code></li> <li><code>exists() -&gt; bool</code></li> </ul> <p>Filter (falls back to a real DB query via <code>ReverseQuery</code>):</p> <ul> <li><code>filter(**kwargs) -&gt; ReverseQuery</code></li> </ul>"},{"location":"api-reference/many-to-many/#junction-tables","title":"Junction Tables","text":"<p>By default, the junction table name is generated from the two table names in alphabetical order (e.g., <code>articles_tags</code>). Use <code>through</code> to override it.</p> <p>Junction tables include:</p> <ul> <li><code>CASCADE</code> FK constraints</li> <li>A unique constraint on the pair</li> <li>Indexes on both FK columns</li> </ul>"},{"location":"api-reference/orm/","title":"ORM Mode","text":"<p>The ORM module extends the legacy <code>sqliter.model</code> with lazy loading, reverse relationships, and a descriptor-based <code>ForeignKey</code> class.</p> <pre><code>from sqliter.orm import BaseDBModel, ForeignKey, ManyToMany, ModelRegistry\n</code></pre> <p>Sources: <code>sqliter/orm/model.py</code>, <code>sqliter/orm/fields.py</code>, <code>sqliter/orm/m2m.py</code>, <code>sqliter/orm/registry.py</code>, <code>sqliter/orm/query.py</code></p> <p>See also: Guide -- ORM Foreign Keys, Guide -- Many-to-Many</p> <p>Note</p> <p>The ORM module is an alternative to the legacy <code>sqliter.model</code> import. Both modes use the same <code>SqliterDB</code> class for database operations. The key difference is how foreign key relationships are defined and accessed.</p>"},{"location":"api-reference/orm/#legacy-vs-orm-mode","title":"Legacy vs ORM Mode","text":"Feature Legacy (<code>sqliter.model</code>) ORM (<code>sqliter.orm</code>) FK definition <code>ForeignKey()</code> factory function <code>ForeignKey</code> descriptor class M2M definition Not available <code>ManyToMany</code> descriptor class FK access Manual ID lookup Lazy loading via <code>book.author.name</code> Reverse queries Not available <code>author.books.fetch_all()</code> Eager loading Not available <code>select_related(\"author\")</code> Import <code>from sqliter.model import BaseDBModel</code> <code>from sqliter.orm import BaseDBModel</code>"},{"location":"api-reference/orm/#ormbasedbmodel","title":"<code>orm.BaseDBModel</code>","text":"<p>Extends the legacy <code>BaseDBModel</code> with ORM features.</p> <pre><code>from sqliter.orm import BaseDBModel\n</code></pre> <p>Additional Class Variables:</p> Attribute Type Description <code>fk_descriptors</code> <code>ClassVar[dict[str, ForeignKey]]</code> FK descriptors for this class (not inherited) <p>Additional Instance Fields:</p> Field Type Default Description <code>db_context</code> <code>Any</code> | <code>None</code> <code>None</code> Database connection for lazy loading (excluded from serialization)"},{"location":"api-reference/orm/#overridden-behavior","title":"Overridden Behavior","text":"<p><code>__init__(**kwargs)</code></p> <p>Converts FK field values to <code>_id</code> fields before Pydantic validation. Accepts model instances, integer IDs, or <code>None</code>.</p> <pre><code># All equivalent:\nbook = Book(author=author_instance)  # Model instance\nbook = Book(author=42)               # Integer ID\nbook = Book(author_id=42)            # Direct _id field\n</code></pre> <p><code>model_dump(**kwargs)</code></p> <p>Excludes FK descriptor fields (like <code>author</code>) from serialization. Only the <code>_id</code> fields (like <code>author_id</code>) are included.</p> <p><code>__getattribute__(name)</code></p> <p>Intercepts FK field access to provide lazy loading. Returns a <code>LazyLoader</code> that queries the database on first attribute access. Returns <code>None</code> for null FK values.</p> <p><code>__setattr__(name, value)</code></p> <p>Intercepts FK field assignment. Accepts model instances, integer IDs, or <code>None</code>. Clears the FK cache when an <code>_id</code> field changes.</p>"},{"location":"api-reference/orm/#foreignkeyt","title":"<code>ForeignKey[T]</code>","text":"<p>Generic descriptor class for FK fields providing lazy loading and type safety.</p> <pre><code>from sqliter.orm import ForeignKey\n</code></pre> <pre><code>class ForeignKey(Generic[T]):\n    def __init__(\n        self,\n        to_model: type[T],\n        *,\n        on_delete: FKAction = \"RESTRICT\",\n        on_update: FKAction = \"RESTRICT\",\n        null: bool = False,\n        unique: bool = False,\n        related_name: str | None = None,\n        db_column: str | None = None,\n    ) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>to_model</code> <code>type[T]</code> required The related model class <code>on_delete</code> <code>FKAction</code> <code>\"RESTRICT\"</code> Action when related record is deleted <code>on_update</code> <code>FKAction</code> <code>\"RESTRICT\"</code> Action when related record's PK is updated <code>null</code> <code>bool</code> <code>False</code> Whether FK can be null <code>unique</code> <code>bool</code> <code>False</code> Whether FK must be unique (one-to-one) <code>related_name</code> <code>str</code> | <code>None</code> <code>None</code> Name for reverse relationship (auto-generated if <code>None</code>) <code>db_column</code> <code>str</code> | <code>None</code> <code>None</code> Custom column name for <code>_id</code> field <p>Example:</p> <pre><code>from sqliter.orm import BaseDBModel, ForeignKey\n\n\nclass Author(BaseDBModel):\n    name: str\n\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(\n        Author, on_delete=\"CASCADE\"\n    )\n</code></pre>"},{"location":"api-reference/orm/#foreignkeydescriptor","title":"<code>ForeignKeyDescriptor</code>","text":"<p>Caution</p> <p><code>ForeignKeyDescriptor</code> is a backwards-compatibility alias for <code>ForeignKey</code>. Use <code>ForeignKey</code> directly.</p>"},{"location":"api-reference/orm/#manytomanyt","title":"<code>ManyToMany[T]</code>","text":"<p>Descriptor class for many-to-many relationships (ORM mode only).</p> <p>See Many-to-Many for full usage and manager API.</p>"},{"location":"api-reference/orm/#notes","title":"Notes","text":"<ul> <li>Accessing the descriptor on an instance returns a <code>ManyToManyManager</code>.</li> <li>Reverse accessors are auto-generated when <code>related_name</code> is omitted.</li> <li>Self-referential <code>symmetrical=True</code> relationships store a single row   per pair and suppress the reverse accessor.</li> </ul>"},{"location":"api-reference/orm/#lazyloadert","title":"<code>LazyLoader[T]</code>","text":"<p>Transparent proxy that lazy-loads a related object when its attributes are accessed. Returned by FK field access on ORM model instances.</p> <pre><code>class LazyLoader(Generic[T]):\n    def __init__(\n        self,\n        instance: object,\n        to_model: type[T],\n        fk_id: int | None,\n        db_context: SqliterDB | None,\n    ) -&gt; None:\n</code></pre>"},{"location":"api-reference/orm/#properties","title":"Properties","text":"Property Type Description <code>db_context</code> <code>object</code> The database context (for validity checking)"},{"location":"api-reference/orm/#methods","title":"Methods","text":"<p><code>__getattr__(name)</code></p> <p>Loads the related object from the database on first access, then delegates attribute access to it. Raises <code>AttributeError</code> if the FK is null or the object is not found.</p> <p><code>__eq__(other)</code></p> <p>Compares based on the loaded object. Loads the object if not already cached. Returns <code>True</code> if <code>other</code> equals the loaded object, or if both are <code>None</code>.</p> <p><code>__repr__()</code></p> <p>Returns <code>&lt;LazyLoader unloaded for ModelName id=N&gt;</code> before loading, or <code>&lt;LazyLoader loaded: &lt;repr&gt;&gt;</code> after loading.</p> <p>Note</p> <p><code>LazyLoader</code> is unhashable (<code>__hash__ = None</code>) because its equality depends on mutable cached state.</p>"},{"location":"api-reference/orm/#modelregistry","title":"<code>ModelRegistry</code>","text":"<p>Class-level registry for ORM models, FK relationships, and pending reverse relationships. Uses automatic setup via the descriptor <code>__set_name__</code> hook -- no manual registration required.</p> <pre><code>from sqliter.orm import ModelRegistry\n</code></pre>"},{"location":"api-reference/orm/#register_model","title":"<code>register_model()</code>","text":"<p>Register a model class in the global registry.</p> <pre><code>@classmethod\ndef register_model(\n    cls,\n    model_class: type[Any],\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>model_class</code> <code>type[Any]</code> The model class to register <p>Also processes any pending reverse relationships for this model.</p>"},{"location":"api-reference/orm/#register_foreign_key","title":"<code>register_foreign_key()</code>","text":"<p>Register a FK relationship.</p> <pre><code>@classmethod\ndef register_foreign_key(\n    cls,\n    from_model: type[Any],\n    to_model: type[Any],\n    fk_field: str,\n    on_delete: str,\n    related_name: str | None = None,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>from_model</code> <code>type[Any]</code> The model with the FK field <code>to_model</code> <code>type[Any]</code> The referenced model <code>fk_field</code> <code>str</code> Name of the FK field <code>on_delete</code> <code>str</code> Delete action <code>related_name</code> <code>str</code> | <code>None</code> Reverse relationship name"},{"location":"api-reference/orm/#get_model","title":"<code>get_model()</code>","text":"<p>Get a model class by table name.</p> <pre><code>@classmethod\ndef get_model(\n    cls,\n    table_name: str,\n) -&gt; type[Any] | None:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>table_name</code> <code>str</code> Table name to look up <p>Returns:</p> <p><code>type[Any] | None</code> -- The model class, or <code>None</code> if not found.</p>"},{"location":"api-reference/orm/#get_foreign_keys","title":"<code>get_foreign_keys()</code>","text":"<p>Get FK relationships for a model by table name.</p> <pre><code>@classmethod\ndef get_foreign_keys(\n    cls,\n    table_name: str,\n) -&gt; list[dict[str, Any]]:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>table_name</code> <code>str</code> Table name to look up <p>Returns:</p> <p><code>list[dict[str, Any]]</code> -- List of FK relationship dictionaries with keys: <code>to_model</code>, <code>fk_field</code>, <code>on_delete</code>, <code>related_name</code>.</p>"},{"location":"api-reference/orm/#add_reverse_relationship","title":"<code>add_reverse_relationship()</code>","text":"<p>Add a reverse relationship descriptor to the target model. Called automatically by <code>ForeignKey.__set_name__()</code> during class creation. If the target model does not exist yet, stores the relationship as pending.</p> <pre><code>@classmethod\ndef add_reverse_relationship(\n    cls,\n    from_model: type[Any],\n    to_model: type[Any],\n    fk_field: str,\n    related_name: str,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>from_model</code> <code>type[Any]</code> Model with the FK (e.g., <code>Book</code>) <code>to_model</code> <code>type[Any]</code> Referenced model (e.g., <code>Author</code>) <code>fk_field</code> <code>str</code> FK field name (e.g., <code>\"author\"</code>) <code>related_name</code> <code>str</code> Reverse relationship name (e.g., <code>\"books\"</code>)"},{"location":"api-reference/orm/#reversequery","title":"<code>ReverseQuery</code>","text":"<p>Query builder for reverse relationships. Returned when accessing a reverse relationship on a model instance (e.g., <code>author.books</code>). Delegates to <code>QueryBuilder</code> for SQL execution.</p> <pre><code>class ReverseQuery:\n    def __init__(\n        self,\n        instance: HasPKAndContext,\n        to_model: type[BaseDBModel],\n        fk_field: str,\n        db_context: SqliterDB | None,\n    ) -&gt; None:\n</code></pre>"},{"location":"api-reference/orm/#filter","title":"<code>filter()</code>","text":"<p>Add filter conditions to the reverse query.</p> <pre><code>def filter(\n    self,\n    **kwargs: Any,\n) -&gt; ReverseQuery:\n</code></pre> <p>Returns: <code>ReverseQuery</code> for method chaining.</p>"},{"location":"api-reference/orm/#limit","title":"<code>limit()</code>","text":"<p>Set a limit on query results.</p> <pre><code>def limit(self, count: int) -&gt; ReverseQuery:\n</code></pre> <p>Returns: <code>ReverseQuery</code> for method chaining.</p>"},{"location":"api-reference/orm/#offset","title":"<code>offset()</code>","text":"<p>Set an offset on query results.</p> <pre><code>def offset(self, count: int) -&gt; ReverseQuery:\n</code></pre> <p>Returns: <code>ReverseQuery</code> for method chaining.</p>"},{"location":"api-reference/orm/#fetch_all","title":"<code>fetch_all()</code>","text":"<p>Execute the query and return all matching related objects.</p> <pre><code>def fetch_all(self) -&gt; list[BaseDBModel]:\n</code></pre> <p>Returns: <code>list[BaseDBModel]</code> -- Related model instances.</p>"},{"location":"api-reference/orm/#fetch_one","title":"<code>fetch_one()</code>","text":"<p>Execute the query and return a single result.</p> <pre><code>def fetch_one(self) -&gt; BaseDBModel | None:\n</code></pre> <p>Returns: <code>BaseDBModel | None</code> -- A single related instance or <code>None</code>.</p>"},{"location":"api-reference/orm/#count","title":"<code>count()</code>","text":"<p>Count the number of related objects.</p> <pre><code>def count(self) -&gt; int:\n</code></pre> <p>Returns: <code>int</code> -- Number of matching related objects.</p>"},{"location":"api-reference/orm/#exists","title":"<code>exists()</code>","text":"<p>Check if any related objects exist.</p> <pre><code>def exists(self) -&gt; bool:\n</code></pre> <p>Returns: <code>bool</code> -- <code>True</code> if at least one related object exists.</p> <p>Example:</p> <pre><code># Fetch all books by an author\nbooks = author.books.fetch_all()\n\n# Filter and count\ncount = author.books.filter(title__contains=\"Python\").count()\n\n# Check existence\nhas_books = author.books.exists()\n</code></pre>"},{"location":"api-reference/orm/#reverserelationship","title":"<code>ReverseRelationship</code>","text":"<p>Descriptor that returns a <code>ReverseQuery</code> when accessed on a model instance. Added automatically to models by <code>ForeignKey.__set_name__()</code> during class creation.</p> <pre><code>class ReverseRelationship:\n    def __init__(\n        self,\n        from_model: type[BaseDBModel],\n        fk_field: str,\n        related_name: str,\n    ) -&gt; None:\n</code></pre> <p>Descriptor Protocol:</p> <ul> <li>On a class: returns the <code>ReverseRelationship</code> descriptor itself.</li> <li>On an instance: returns a <code>ReverseQuery</code> bound to that instance.</li> <li><code>__set__</code>: Raises <code>AttributeError</code>. Reverse relationships are   read-only.</li> </ul>"},{"location":"api-reference/orm/#protocols","title":"Protocols","text":""},{"location":"api-reference/orm/#haspk","title":"<code>HasPK</code>","text":"<p>Runtime-checkable protocol for objects that have a <code>pk</code> attribute. Used for duck-typed FK assignment.</p> <pre><code>@runtime_checkable\nclass HasPK(Protocol):\n    pk: int | None\n</code></pre>"},{"location":"api-reference/orm/#haspkandcontext","title":"<code>HasPKAndContext</code>","text":"<p>Runtime-checkable protocol for model instances with <code>pk</code> and <code>db_context</code>. Used by <code>ReverseQuery</code>.</p> <pre><code>@runtime_checkable\nclass HasPKAndContext(Protocol):\n    pk: int | None\n    db_context: SqliterDB | None\n</code></pre>"},{"location":"api-reference/query-builder/","title":"QueryBuilder","text":"<p>Fluent API for constructing and executing database queries. Instances are created by <code>SqliterDB.select()</code> -- you do not instantiate <code>QueryBuilder</code> directly.</p> <pre><code>results = db.select(User).filter(age__gt=18).order(\"name\").fetch_all()\n</code></pre> <p>Source: <code>sqliter/query/query.py</code></p> <p>See also: Guide -- Filtering, Guide -- Ordering, Guide -- Field Control, Guide -- Caching</p>"},{"location":"api-reference/query-builder/#type-parameters","title":"Type Parameters","text":"<pre><code>T = TypeVar(\"T\", bound=BaseDBModel)\n\nclass QueryBuilder(Generic[T]):\n    ...\n</code></pre> <p><code>QueryBuilder</code> is generic over <code>T</code>, the model class. All fetch methods return instances of <code>T</code>.</p>"},{"location":"api-reference/query-builder/#type-aliases","title":"Type Aliases","text":""},{"location":"api-reference/query-builder/#filtervalue","title":"<code>FilterValue</code>","text":"<p>The allowed types for filter values:</p> <pre><code>FilterValue = Union[\n    str, int, float, bool, None,\n    list[Union[str, int, float, bool]],\n]\n</code></pre>"},{"location":"api-reference/query-builder/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    db: SqliterDB,\n    model_class: type[T],\n    fields: list[str] | None = None,\n) -&gt; None:\n</code></pre> <p>Note</p> <p>You should not call this directly. Use <code>db.select(Model)</code> instead.</p> <p>Parameters:</p> Parameter Type Default Description <code>db</code> <code>SqliterDB</code> required Database connection <code>model_class</code> <code>type[T]</code> required The model class to query <code>fields</code> <code>list[str]</code> | <code>None</code> <code>None</code> Fields to select (all if <code>None</code>)"},{"location":"api-reference/query-builder/#filter-methods","title":"Filter Methods","text":""},{"location":"api-reference/query-builder/#filter","title":"<code>filter()</code>","text":"<p>Apply filter conditions to the query. Supports operator suffixes on field names and relationship traversal.</p> <pre><code>def filter(\n    self,\n    **conditions: FilterValue,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>**conditions</code> <code>FilterValue</code> Field-operator pairs as keyword arguments <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>InvalidFilterError</code> -- If a   field does not exist on the model.</li> <li><code>InvalidRelationshipError</code>   -- If a relationship traversal path is invalid.</li> <li><code>TypeError</code> -- If a list is passed for a scalar operator, or a   non-string for a string operator.</li> </ul> <p>Example:</p> <pre><code># Simple equality (default __eq)\ndb.select(User).filter(name=\"Alice\")\n\n# Comparison operators\ndb.select(User).filter(age__gt=18, age__lt=65)\n\n# Multiple chained calls (AND logic)\ndb.select(User).filter(active=True).filter(age__gte=21)\n\n# Relationship traversal (ORM mode)\ndb.select(Book).filter(author__name=\"Alice\")\n</code></pre>"},{"location":"api-reference/query-builder/#filter-operators","title":"Filter Operators","text":"Operator SQL Value Type Description (none) <code>=</code> scalar Equality (default) <code>__eq</code> <code>=</code> scalar Explicit equality <code>__ne</code> <code>!=</code> scalar Not equal <code>__gt</code> <code>&gt;</code> scalar Greater than <code>__lt</code> <code>&lt;</code> scalar Less than <code>__gte</code> <code>&gt;=</code> scalar Greater than or equal <code>__lte</code> <code>&lt;=</code> scalar Less than or equal <code>__in</code> <code>IN</code> <code>list</code> Value in list <code>__not_in</code> <code>NOT IN</code> <code>list</code> Value not in list <code>__isnull</code> <code>IS NULL</code> <code>bool</code> Field is NULL (pass <code>True</code>) <code>__notnull</code> <code>IS NOT NULL</code> <code>bool</code> Field is not NULL (pass <code>True</code>) <code>__like</code> <code>LIKE</code> <code>str</code> Raw SQL LIKE pattern (user provides <code>%</code> wildcards) <code>__startswith</code> <code>GLOB</code> <code>str</code> Case-sensitive starts with <code>__endswith</code> <code>GLOB</code> <code>str</code> Case-sensitive ends with <code>__contains</code> <code>GLOB</code> <code>str</code> Case-sensitive contains <code>__istartswith</code> <code>LIKE</code> <code>str</code> Case-insensitive starts with <code>__iendswith</code> <code>LIKE</code> <code>str</code> Case-insensitive ends with <code>__icontains</code> <code>LIKE</code> <code>str</code> Case-insensitive contains"},{"location":"api-reference/query-builder/#field-selection","title":"Field Selection","text":""},{"location":"api-reference/query-builder/#fields","title":"<code>fields()</code>","text":"<p>Specify which fields to include in the query results.</p> <pre><code>def fields(\n    self,\n    fields: list[str] | None = None,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>fields</code> <code>list[str]</code> | <code>None</code> <code>None</code> Fields to select; <code>pk</code> is always included <p>Returns: <code>Self</code> for method chaining.</p> <p>Example:</p> <pre><code>db.select(User).fields([\"name\", \"email\"]).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#exclude","title":"<code>exclude()</code>","text":"<p>Specify which fields to exclude from the query results.</p> <pre><code>def exclude(\n    self,\n    fields: list[str] | None = None,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>fields</code> <code>list[str]</code> | <code>None</code> <code>None</code> Fields to exclude <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> -- If <code>pk</code> is excluded, if invalid fields are   specified, or if exclusion leaves no fields.</li> </ul> <p>Example:</p> <pre><code>db.select(User).exclude([\"password_hash\"]).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#only","title":"<code>only()</code>","text":"<p>Select a single field (plus <code>pk</code>).</p> <pre><code>def only(\n    self,\n    field: str,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>field</code> <code>str</code> required The single field to select <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> -- If the field does not exist.</li> </ul> <p>Example:</p> <pre><code>db.select(User).only(\"email\").fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#relationships","title":"Relationships","text":""},{"location":"api-reference/query-builder/#select_related","title":"<code>select_related()</code>","text":"<p>Specify FK relationships to eager load via SQL JOINs. Reduces the N+1 query problem by fetching related objects in a single query.</p> <pre><code>def select_related(\n    self,\n    *paths: str,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>*paths</code> <code>str</code> One or more relationship paths to eager load <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>InvalidRelationshipError</code>   -- If a path contains invalid fields.</li> </ul> <p>Example:</p> <pre><code># Single level\nbooks = db.select(Book).select_related(\"author\").fetch_all()\n# book.author.name  -- no additional query needed\n\n# Nested\ncomments = db.select(Comment).select_related(\n    \"post__author\"\n).fetch_all()\n\n# Multiple paths\nbooks = db.select(Book).select_related(\n    \"author\", \"publisher\"\n).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#prefetch_related","title":"<code>prefetch_related()</code>","text":"<p>Specify reverse FK and M2M relationships to eager load via a second query. Reduces the N+1 query problem for reverse relationships.</p> <pre><code>def prefetch_related(\n    self,\n    *paths: str,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>*paths</code> <code>str</code> One or more reverse FK or M2M relationship names <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>InvalidPrefetchError</code> -- If   a path is not a valid reverse FK or M2M relationship. Forward FK   paths (which should use <code>select_related()</code>) also raise this error.</li> </ul> <p>Example:</p> <pre><code># Reverse FK\nauthors = db.select(Author).prefetch_related(\"books\").fetch_all()\n# author.books.fetch_all()  -- no additional query\n\n# M2M (forward)\narticles = db.select(Article).prefetch_related(\"tags\").fetch_all()\n\n# M2M (reverse)\ntags = db.select(Tag).prefetch_related(\"articles\").fetch_all()\n\n# Multiple paths\nauthors = db.select(Author).prefetch_related(\n    \"books\", \"reviews\"\n).fetch_all()\n\n# Combined with select_related\nbooks = db.select(Book).select_related(\"author\").prefetch_related().fetch_all()\n</code></pre> <p>Note</p> <p>Use <code>select_related()</code> for forward FK relationships (e.g., <code>book.author</code>) and <code>prefetch_related()</code> for reverse FK and M2M relationships (e.g., <code>author.books</code>, <code>article.tags</code>).</p>"},{"location":"api-reference/query-builder/#pagination","title":"Pagination","text":""},{"location":"api-reference/query-builder/#limit","title":"<code>limit()</code>","text":"<p>Limit the number of results returned.</p> <pre><code>def limit(\n    self,\n    limit_value: int,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>limit_value</code> <code>int</code> required Maximum number of records <p>Returns: <code>Self</code> for method chaining.</p>"},{"location":"api-reference/query-builder/#offset","title":"<code>offset()</code>","text":"<p>Skip a number of records before returning results.</p> <pre><code>def offset(\n    self,\n    offset_value: int,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>offset_value</code> <code>int</code> required Number of records to skip <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>InvalidOffsetError</code> -- If the   offset value is negative.</li> </ul> <p>Note</p> <p>If <code>offset()</code> is called without a prior <code>limit()</code>, the limit is automatically set to <code>-1</code> (unlimited) to satisfy SQLite's requirement that <code>OFFSET</code> must be paired with <code>LIMIT</code>.</p> <p>Example:</p> <pre><code># Pagination: page 2, 10 items per page\ndb.select(User).limit(10).offset(10).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#ordering","title":"Ordering","text":""},{"location":"api-reference/query-builder/#order","title":"<code>order()</code>","text":"<p>Order the query results by a field.</p> <pre><code>def order(\n    self,\n    order_by_field: str | None = None,\n    direction: str | None = None,\n    *,\n    reverse: bool = False,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>order_by_field</code> <code>str</code> | <code>None</code> <code>None</code> Field to order by; defaults to <code>pk</code> <code>direction</code> <code>str</code> | <code>None</code> <code>None</code> Deprecated. Use <code>reverse</code> instead <code>reverse</code> <code>bool</code> <code>False</code> If <code>True</code>, sort descending <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>InvalidOrderError</code> -- If the   field does not exist, or if both <code>direction</code> and <code>reverse</code> are   specified.</li> </ul> <p>Warns:</p> <ul> <li><code>DeprecationWarning</code> -- If <code>direction</code> is used.</li> </ul> <p>Caution</p> <p>The <code>direction</code> parameter is deprecated. Use <code>reverse=True</code> for descending order instead.</p> <p>Example:</p> <pre><code># Ascending (default)\ndb.select(User).order(\"name\").fetch_all()\n\n# Descending\ndb.select(User).order(\"created_at\", reverse=True).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#cache-control","title":"Cache Control","text":""},{"location":"api-reference/query-builder/#bypass_cache","title":"<code>bypass_cache()</code>","text":"<p>Force this query to skip the cache and hit the database directly.</p> <pre><code>def bypass_cache(self) -&gt; Self:\n</code></pre> <p>Returns: <code>Self</code> for method chaining.</p> <p>Example:</p> <pre><code>fresh = db.select(User).bypass_cache().fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#cache_ttl","title":"<code>cache_ttl()</code>","text":"<p>Set a custom time-to-live for this query's cached result, overriding the global <code>cache_ttl</code>.</p> <pre><code>def cache_ttl(\n    self,\n    ttl: int,\n) -&gt; Self:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ttl</code> <code>int</code> required TTL in seconds <p>Returns: <code>Self</code> for method chaining.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> -- If <code>ttl</code> is negative.</li> </ul> <p>Example:</p> <pre><code># Cache this query for 60 seconds\ndb.select(User).cache_ttl(60).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#execution-methods","title":"Execution Methods","text":""},{"location":"api-reference/query-builder/#fetch_all","title":"<code>fetch_all()</code>","text":"<p>Execute the query and return all matching records.</p> <pre><code>def fetch_all(self) -&gt; list[T]:\n</code></pre> <p>Returns: <code>list[T]</code> -- List of model instances.</p> <p>Example:</p> <pre><code>users = db.select(User).filter(active=True).fetch_all()\n</code></pre>"},{"location":"api-reference/query-builder/#fetch_one","title":"<code>fetch_one()</code>","text":"<p>Execute the query and return a single record.</p> <pre><code>def fetch_one(self) -&gt; T | None:\n</code></pre> <p>Returns: <code>T | None</code> -- A model instance, or <code>None</code> if no match.</p>"},{"location":"api-reference/query-builder/#fetch_first","title":"<code>fetch_first()</code>","text":"<p>Fetch the first record (sets <code>LIMIT 1</code>).</p> <pre><code>def fetch_first(self) -&gt; T | None:\n</code></pre> <p>Returns: <code>T | None</code> -- The first model instance, or <code>None</code>.</p>"},{"location":"api-reference/query-builder/#fetch_last","title":"<code>fetch_last()</code>","text":"<p>Fetch the last record (orders by <code>rowid DESC</code>, sets <code>LIMIT 1</code>).</p> <pre><code>def fetch_last(self) -&gt; T | None:\n</code></pre> <p>Returns: <code>T | None</code> -- The last model instance, or <code>None</code>.</p>"},{"location":"api-reference/query-builder/#count","title":"<code>count()</code>","text":"<p>Count the number of matching records.</p> <pre><code>def count(self) -&gt; int:\n</code></pre> <p>Returns: <code>int</code> -- The count of matching records.</p> <p>Example:</p> <pre><code>total = db.select(User).filter(active=True).count()\n</code></pre>"},{"location":"api-reference/query-builder/#exists","title":"<code>exists()</code>","text":"<p>Check if any matching records exist.</p> <pre><code>def exists(self) -&gt; bool:\n</code></pre> <p>Returns: <code>bool</code> -- <code>True</code> if at least one record matches.</p> <p>Example:</p> <pre><code>if db.select(User).filter(email=\"alice@example.com\").exists():\n    print(\"User exists\")\n</code></pre>"},{"location":"api-reference/query-builder/#delete","title":"<code>delete()</code>","text":"<p>Delete all records matching the current query conditions.</p> <pre><code>def delete(self) -&gt; int:\n</code></pre> <p>Returns: <code>int</code> -- The number of records deleted.</p> <p>Raises:</p> <ul> <li><code>RecordDeletionError</code> -- If   there is an error deleting the records.</li> </ul> <p>Example:</p> <pre><code>deleted = db.select(User).filter(active=False).delete()\nprint(f\"Deleted {deleted} inactive users\")\n</code></pre>"},{"location":"api-reference/query-builder/#supporting-types","title":"Supporting Types","text":""},{"location":"api-reference/query-builder/#joininfo","title":"<code>JoinInfo</code>","text":"<p>Dataclass holding metadata for a JOIN clause. Used internally by <code>select_related()</code> and relationship filter traversal.</p> <pre><code>@dataclass\nclass JoinInfo:\n    alias: str\n    table_name: str\n    model_class: type[BaseDBModel]\n    fk_field: str\n    parent_alias: str\n    fk_column: str\n    join_type: str\n    path: str\n    is_nullable: bool\n</code></pre> <p>Fields:</p> Field Type Description <code>alias</code> <code>str</code> Table alias (e.g., <code>\"t1\"</code>, <code>\"t2\"</code>) <code>table_name</code> <code>str</code> Actual database table name <code>model_class</code> <code>type[BaseDBModel]</code> Model class for the joined table <code>fk_field</code> <code>str</code> FK field name on the parent model <code>parent_alias</code> <code>str</code> Alias of the parent table <code>fk_column</code> <code>str</code> FK column name (e.g., <code>\"author_id\"</code>) <code>join_type</code> <code>str</code> <code>\"LEFT\"</code> (nullable FK) or <code>\"INNER\"</code> (required FK) <code>path</code> <code>str</code> Full relationship path (e.g., <code>\"post__author\"</code>) <code>is_nullable</code> <code>bool</code> Whether the FK is nullable"},{"location":"api-reference/sqliterdb/","title":"SqliterDB","text":"<p>The main entry point for all database operations. Manages SQLite connections, table creation, CRUD operations, caching, and transactions.</p> <pre><code>from sqliter import SqliterDB\n</code></pre> <p>Source: <code>sqliter/sqliter.py</code></p> <p>See also: Guide -- Connecting, Guide -- Properties, Guide -- Tables, Guide -- Data Operations, Guide -- Caching, Guide -- Transactions</p>"},{"location":"api-reference/sqliterdb/#class-attribute","title":"Class Attribute","text":""},{"location":"api-reference/sqliterdb/#memory_db","title":"<code>MEMORY_DB</code>","text":"<p>Constant for in-memory database filename.</p> <pre><code>MEMORY_DB = \":memory:\"\n</code></pre>"},{"location":"api-reference/sqliterdb/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    db_filename: str | None = None,\n    *,\n    memory: bool = False,\n    auto_commit: bool = True,\n    debug: bool = False,\n    logger: logging.Logger | None = None,\n    reset: bool = False,\n    return_local_time: bool = True,\n    cache_enabled: bool = False,\n    cache_max_size: int = 1000,\n    cache_ttl: int | None = None,\n    cache_max_memory_mb: int | None = None,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>db_filename</code> <code>str</code> | <code>None</code> <code>None</code> Path to the SQLite database file <code>memory</code> <code>bool</code> <code>False</code> If <code>True</code>, create an in-memory database <code>auto_commit</code> <code>bool</code> <code>True</code> Auto-commit after each operation <code>debug</code> <code>bool</code> <code>False</code> Enable SQL debug logging <code>logger</code> <code>Logger</code> | <code>None</code> <code>None</code> Custom logger for debug output <code>reset</code> <code>bool</code> <code>False</code> Drop all tables on initialization <code>return_local_time</code> <code>bool</code> <code>True</code> Return local time for datetime fields <code>cache_enabled</code> <code>bool</code> <code>False</code> Enable query result caching <code>cache_max_size</code> <code>int</code> <code>1000</code> Max cached queries per table (LRU) <code>cache_ttl</code> <code>int</code> | <code>None</code> <code>None</code> Time-to-live for cache entries (seconds) <code>cache_max_memory_mb</code> <code>int</code> | <code>None</code> <code>None</code> Max memory for cache (MB) <p>Raises:</p> <ul> <li><code>ValueError</code> -- If no filename is provided for a non-memory   database, if <code>cache_max_size &lt;= 0</code>, if <code>cache_ttl &lt; 0</code>, or if   <code>cache_max_memory_mb &lt;= 0</code>.</li> </ul> <p>Example:</p> <pre><code># File-based database\ndb = SqliterDB(\"myapp.db\")\n\n# In-memory database\ndb = SqliterDB(memory=True)\n\n# With caching enabled\ndb = SqliterDB(\n    \"myapp.db\",\n    cache_enabled=True,\n    cache_ttl=300,\n    cache_max_memory_mb=50,\n)\n</code></pre>"},{"location":"api-reference/sqliterdb/#properties","title":"Properties","text":""},{"location":"api-reference/sqliterdb/#filename","title":"<code>filename</code>","text":"<p>Returns the database filename, or <code>None</code> if using an in-memory database.</p> Type Description <code>str</code> | <code>None</code> File path or <code>None</code> for in-memory"},{"location":"api-reference/sqliterdb/#is_memory","title":"<code>is_memory</code>","text":"<p>Returns <code>True</code> if the database is in-memory.</p> Type Description <code>bool</code> <code>True</code> for <code>:memory:</code> databases"},{"location":"api-reference/sqliterdb/#is_autocommit","title":"<code>is_autocommit</code>","text":"<p>Returns <code>True</code> if auto-commit is enabled.</p> Type Description <code>bool</code> Current auto-commit setting"},{"location":"api-reference/sqliterdb/#is_connected","title":"<code>is_connected</code>","text":"<p>Returns <code>True</code> if a database connection is currently open.</p> Type Description <code>bool</code> Connection status"},{"location":"api-reference/sqliterdb/#table_names","title":"<code>table_names</code>","text":"<p>Returns a list of all table names in the database. Temporarily connects if not already connected and restores the connection state afterward.</p> Type Description <code>list[str]</code> All user table names (excludes <code>sqlite_</code> system tables) <p>Example:</p> <pre><code>db = SqliterDB(\"myapp.db\")\nprint(db.table_names)  # [\"users\", \"posts\", ...]\n</code></pre>"},{"location":"api-reference/sqliterdb/#connection-methods","title":"Connection Methods","text":""},{"location":"api-reference/sqliterdb/#connect","title":"<code>connect()</code>","text":"<p>Establish a connection to the SQLite database. Enables foreign key constraint enforcement via <code>PRAGMA foreign_keys = ON</code>.</p> <pre><code>def connect(self) -&gt; sqlite3.Connection:\n</code></pre> <p>Returns:</p> <p><code>sqlite3.Connection</code> -- The SQLite connection object.</p> <p>Raises:</p> <ul> <li><code>DatabaseConnectionError</code>   -- If unable to connect.</li> </ul>"},{"location":"api-reference/sqliterdb/#close","title":"<code>close()</code>","text":"<p>Close the database connection. Commits pending changes if <code>auto_commit</code> is <code>True</code>. Clears the query cache and resets cache statistics.</p> <pre><code>def close(self) -&gt; None:\n</code></pre>"},{"location":"api-reference/sqliterdb/#commit","title":"<code>commit()</code>","text":"<p>Explicitly commit the current transaction.</p> <pre><code>def commit(self) -&gt; None:\n</code></pre>"},{"location":"api-reference/sqliterdb/#table-methods","title":"Table Methods","text":""},{"location":"api-reference/sqliterdb/#create_table","title":"<code>create_table()</code>","text":"<p>Create a database table based on a model class. Handles column definitions, primary keys, foreign key constraints, and indexes.</p> <pre><code>def create_table(\n    self,\n    model_class: type[BaseDBModel],\n    *,\n    exists_ok: bool = True,\n    force: bool = False,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_class</code> <code>type[BaseDBModel]</code> required The model class defining the table <code>exists_ok</code> <code>bool</code> <code>True</code> If <code>True</code>, do not raise if table exists <code>force</code> <code>bool</code> <code>False</code> If <code>True</code>, drop and recreate the table <p>Raises:</p> <ul> <li><code>TableCreationError</code> -- If there   is an error creating the table.</li> <li><code>InvalidIndexError</code> -- If index   fields do not exist in the model.</li> </ul> <p>Example:</p> <pre><code>db.create_table(User)\ndb.create_table(User, force=True)  # Drop and recreate\n</code></pre>"},{"location":"api-reference/sqliterdb/#drop_table","title":"<code>drop_table()</code>","text":"<p>Drop the table associated with a model class.</p> <pre><code>def drop_table(\n    self,\n    model_class: type[BaseDBModel],\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_class</code> <code>type[BaseDBModel]</code> required The model class whose table to drop <p>Raises:</p> <ul> <li><code>TableDeletionError</code> -- If there   is an error dropping the table.</li> </ul>"},{"location":"api-reference/sqliterdb/#crud-methods","title":"CRUD Methods","text":""},{"location":"api-reference/sqliterdb/#insert","title":"<code>insert()</code>","text":"<p>Insert a new record into the database. Sets <code>created_at</code> and <code>updated_at</code> timestamps automatically.</p> <pre><code>def insert(\n    self,\n    model_instance: T,\n    *,\n    timestamp_override: bool = False,\n) -&gt; T:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_instance</code> <code>T</code> required The model instance to insert <code>timestamp_override</code> <code>bool</code> <code>False</code> If <code>True</code>, respect provided non-zero timestamp values <p>Returns:</p> <p><code>T</code> -- A new model instance with <code>pk</code> set to the inserted row's ID.</p> <p>Raises:</p> <ul> <li><code>RecordInsertionError</code> -- If   there is an error during insertion.</li> <li><code>ForeignKeyConstraintError</code>   -- If a FK value does not exist in the referenced table.</li> </ul> <p>Example:</p> <pre><code>user = User(name=\"Alice\", email=\"alice@example.com\")\nsaved = db.insert(user)\nprint(saved.pk)  # e.g. 1\n</code></pre>"},{"location":"api-reference/sqliterdb/#bulk_insert","title":"<code>bulk_insert()</code>","text":"<p>Insert multiple records of the same model type in a single transaction. More efficient than calling <code>insert()</code> in a loop.</p> <pre><code>def bulk_insert(\n    self,\n    instances: Sequence[T],\n    *,\n    timestamp_override: bool = False,\n) -&gt; list[T]:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>instances</code> <code>Sequence[T]</code> required The model instances to insert <code>timestamp_override</code> <code>bool</code> <code>False</code> If <code>True</code>, respect provided non-zero timestamp values <p>Returns:</p> <p><code>list[T]</code> -- New model instances with <code>pk</code> set for each inserted row. Returns <code>[]</code> for an empty input sequence.</p> <p>Raises:</p> <ul> <li><code>RecordInsertionError</code> -- If   there is an error during insertion.</li> <li><code>ForeignKeyConstraintError</code>   -- If a FK value does not exist in the referenced table.</li> <li><code>ValueError</code> -- If instances contain mixed model types.</li> </ul> <p>Behavior:</p> <ul> <li>All records are inserted within a single transaction. If any   record fails, the entire batch is rolled back.</li> <li>When called inside a <code>with db:</code> context manager, the commit is   deferred to context exit.</li> <li>Cache is invalidated once after all records are inserted.</li> </ul> <p>Example:</p> <pre><code>users = [\n    User(name=\"Alice\", email=\"alice@example.com\"),\n    User(name=\"Bob\", email=\"bob@example.com\"),\n]\nsaved = db.bulk_insert(users)\nprint(saved[0].pk, saved[1].pk)  # e.g. 1, 2\n</code></pre>"},{"location":"api-reference/sqliterdb/#get","title":"<code>get()</code>","text":"<p>Retrieve a single record by its primary key.</p> <pre><code>def get(\n    self,\n    model_class: type[T],\n    primary_key_value: int,\n    *,\n    bypass_cache: bool = False,\n    cache_ttl: int | None = None,\n) -&gt; T | None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_class</code> <code>type[T]</code> required The model class <code>primary_key_value</code> <code>int</code> required The primary key value <code>bypass_cache</code> <code>bool</code> <code>False</code> Skip cache read/write for this lookup <code>cache_ttl</code> <code>int</code> | <code>None</code> <code>None</code> Optional TTL override for this specific lookup <p>Returns:</p> <p><code>T | None</code> -- The model instance if found, <code>None</code> otherwise.</p> <p>Raises:</p> <ul> <li><code>RecordFetchError</code> -- If there is   an error fetching the record.</li> <li><code>ValueError</code> -- If <code>cache_ttl</code> is negative.</li> </ul> <p>Example:</p> <pre><code>user = db.get(User, 1)\nif user:\n    print(user.name)\n</code></pre> <p>Caching:</p> <p>When <code>cache_enabled=True</code>, <code>get()</code> uses the query cache. Use <code>bypass_cache=True</code> to force a fresh lookup, or <code>cache_ttl</code> to override the global cache TTL for this call.</p>"},{"location":"api-reference/sqliterdb/#update","title":"<code>update()</code>","text":"<p>Update an existing record. The model instance must have a valid <code>pk</code>. Automatically sets <code>updated_at</code> to the current time.</p> <pre><code>def update(\n    self,\n    model_instance: BaseDBModel,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_instance</code> <code>BaseDBModel</code> required The model instance to update <p>Raises:</p> <ul> <li><code>RecordUpdateError</code> -- If there   is an error updating the record.</li> <li><code>RecordNotFoundError</code> -- If no   record matches the <code>pk</code>.</li> </ul> <p>Example:</p> <pre><code>user = db.get(User, 1)\nuser.name = \"Bob\"\ndb.update(user)\n</code></pre>"},{"location":"api-reference/sqliterdb/#delete","title":"<code>delete()</code>","text":"<p>Delete a record by its primary key.</p> <pre><code>def delete(\n    self,\n    model_class: type[BaseDBModel],\n    primary_key_value: int | str,\n) -&gt; None:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_class</code> <code>type[BaseDBModel]</code> required The model class <code>primary_key_value</code> <code>int</code> | <code>str</code> required The primary key of the record to delete <p>Raises:</p> <ul> <li><code>RecordDeletionError</code> -- If   there is an error deleting the record.</li> <li><code>RecordNotFoundError</code> -- If no   record matches the <code>pk</code>.</li> <li><code>ForeignKeyConstraintError</code>   -- If the record is still referenced (with <code>RESTRICT</code>).</li> </ul> <p>Example:</p> <pre><code>db.delete(User, 1)\n</code></pre>"},{"location":"api-reference/sqliterdb/#select","title":"<code>select()</code>","text":"<p>Create a <code>QueryBuilder</code> for constructing queries with filters, ordering, pagination, and more.</p> <pre><code>def select(\n    self,\n    model_class: type[T],\n    fields: list[str] | None = None,\n    exclude: list[str] | None = None,\n) -&gt; QueryBuilder[T]:\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>model_class</code> <code>type[T]</code> required The model class to query <code>fields</code> <code>list[str]</code> | <code>None</code> <code>None</code> Fields to include <code>exclude</code> <code>list[str]</code> | <code>None</code> <code>None</code> Fields to exclude <p>Returns:</p> <p><code>QueryBuilder[T]</code> -- A query builder for method chaining.</p> <p>Example:</p> <pre><code># Simple query\nusers = db.select(User).fetch_all()\n\n# With filters and ordering\nusers = (\n    db.select(User)\n    .filter(active=True)\n    .order(\"name\")\n    .limit(10)\n    .fetch_all()\n)\n\n# Exclude fields\nusers = db.select(User, exclude=[\"password_hash\"]).fetch_all()\n</code></pre>"},{"location":"api-reference/sqliterdb/#cache-methods","title":"Cache Methods","text":""},{"location":"api-reference/sqliterdb/#get_cache_stats","title":"<code>get_cache_stats()</code>","text":"<p>Get cache performance statistics.</p> <pre><code>def get_cache_stats(self) -&gt; dict[str, int | float]:\n</code></pre> <p>Returns:</p> <p><code>dict[str, int | float]</code> -- Dictionary with keys:</p> Key Type Description <code>hits</code> <code>int</code> Number of cache hits <code>misses</code> <code>int</code> Number of cache misses <code>total</code> <code>int</code> Total cache lookups <code>hit_rate</code> <code>float</code> Hit rate as percentage (0--100) <p>Example:</p> <pre><code>stats = db.get_cache_stats()\nprint(f\"Hit rate: {stats['hit_rate']}%\")\n</code></pre>"},{"location":"api-reference/sqliterdb/#clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached query results. Cache statistics (hits/misses) are preserved.</p> <pre><code>def clear_cache(self) -&gt; None:\n</code></pre>"},{"location":"api-reference/sqliterdb/#context-manager","title":"Context Manager","text":"<p><code>SqliterDB</code> can be used as a context manager for transaction management. Within a <code>with</code> block, auto-commit is suppressed and all operations are wrapped in a single transaction.</p> <pre><code>def __enter__(self) -&gt; Self:\ndef __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n</code></pre> <p>Behavior:</p> <ul> <li><code>__enter__</code>: Opens a connection and begins a transaction.</li> <li><code>__exit__</code> (no exception): Commits the transaction and closes   the connection.</li> <li><code>__exit__</code> (exception raised): Rolls back the transaction and   closes the connection.</li> <li>Cache is cleared on exit in both cases.</li> </ul> <p>Example:</p> <pre><code>db = SqliterDB(\"myapp.db\")\n\nwith db:\n    db.create_table(User)\n    db.insert(User(name=\"Alice\"))\n    db.insert(User(name=\"Bob\"))\n    # Both inserts are committed together on exit\n\n# If an exception occurs, both inserts are rolled back\n</code></pre> <p>See also: Guide -- Transactions</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This is an auto-generated log of all the changes that have been made to the project since the first release, with the latest changes at the top.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0170-january-31-2026","title":"0.17.0 (January 31, 2026)","text":"<p>New Features</p> <ul> <li>Feat: add many-to-many relationship support (#116) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0160-january-30-2026","title":"0.16.0 (January 30, 2026)","text":"<p>New Features</p> <ul> <li>Add caching controls to SqliterDB.get (#114) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Docs: add comprehensive API reference section (#113) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0150-january-29-2026","title":"0.15.0 (January 29, 2026)","text":"<p>Closed Issues</p> <ul> <li>Improve LazyLoader type hints for mypy strict mode (#109) by seapagan</li> </ul> <p>New Features</p> <ul> <li>Fix ORM typing in strict mypy (nullable FKs, db.get) (#111) by seapagan</li> <li>Feat: add select_related() eager loading and relationship filter traversal (#110) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Docs: address PR #101 review improvements (#108) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0140-january-25-2026","title":"0.14.0 (January 25, 2026)","text":"<p>Closed Issues</p> <ul> <li>Transaction rollback is broken (#104) by seapagan</li> </ul> <p>New Features</p> <ul> <li>Add a TUI Demo Application to show off the library features (#103) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix transaction rollback bug (Issue #104) (#106) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0130-january-19-2026","title":"0.13.0 (January 19, 2026)","text":"<p>New Features</p> <ul> <li>Add ORM submodule with lazy loading and reverse relationships (#101) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0120-january-17-2026","title":"0.12.0 (January 17, 2026)","text":"<p>New Features</p> <ul> <li>Add foreign key support (Phase 1) (#99) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0110-january-11-2026","title":"0.11.0 (January 11, 2026)","text":"<p>New Features</p> <ul> <li>Add optional query result caching with LRU eviction (#96) by seapagan</li> <li>Migrate from pre-commit to prek (#94) by seapagan</li> </ul> <p>Security</p> <ul> <li>Fix security vulnerabilities in dependencies (#95) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0100-december-15-2025","title":"0.10.0 (December 15, 2025)","text":"<p>Bug Fixes</p> <ul> <li>Ensure python 3.14 compatability (#87) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#091-december-09-2025","title":"0.9.1 (December 09, 2025)","text":"<p>Dependency Updates</p> <ul> <li>Bump requests from 2.32.3 to 2.32.4 (#85) by dependabot[bot]</li> <li>Bump urllib3 from 2.4.0 to 2.6.0 (#83) by dependabot[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#090-december-09-2025","title":"0.9.0 (December 09, 2025)","text":"<p>[!CAUTION]</p> <p>This library is currently NOT compatible with Python 3.14. I am working on fixing this.</p> <p>New Features</p> <ul> <li>Mark as typed library and update deps (#81) by seapagan</li> <li>Update ruff and fix linting issues; improve logging in demo (#70) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Bump urllib3 from 2.4.0 to 2.6.0 (#80) by dependabot[bot]</li> <li>Chore(deps): update actions/checkout action to v6 (#79) by renovate[bot]</li> <li>Chore(deps): update astral-sh/setup-uv action to v7 (#78) by renovate[bot]</li> <li>Bump requests from 2.32.3 to 2.32.4 (#75) by dependabot[bot]</li> <li>Chore(deps): update astral-sh/setup-uv action to v6 (#72) by renovate[bot]</li> <li>Bump jinja2 from 3.1.5 to 3.1.6 (#68) by dependabot[bot]</li> <li>Bump cryptography from 44.0.0 to 44.0.1 (#66) by dependabot[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#080-january-28-2025","title":"0.8.0 (January 28, 2025)","text":"<p>New Features</p> <ul> <li>Implement list, dict, tuple and set as valid field types (#63) by seapagan</li> <li>Add delete() method to QueryBuilder with comprehensive test coverage (#61) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Update astral-sh/setup-uv action to v5 (#59) by renovate[bot]</li> <li>Update astral-sh/setup-uv action to v4 (#57) by renovate[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#070-october-31-2024","title":"0.7.0 (October 31, 2024)","text":"<p>New Features</p> <ul> <li>Support the <code>date</code> and <code>datetime</code> types (#52) by seapagan</li> <li>Add <code>created_at</code> and <code>updated_at</code> timestamps to the BaseDBModel (#49) by seapagan</li> <li>Add some useful properties to the SqliterDB class instance (#48) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix missing commits from the previous PR (#49) (#50) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#060-october-12-2024","title":"0.6.0 (October 12, 2024)","text":"<p>New Features</p> <ul> <li>Add ability to mark a field as UNIQUE (#46) by seapagan</li> <li>Implement user-defined indexes (#45) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context-manager ignores the <code>auto_commit</code> setting. (#43) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#050-september-30-2024","title":"0.5.0 (September 30, 2024)","text":"<p>Breaking Change!</p> <p>This release removes the <code>create_pk</code> and <code>primary_key</code> attributes from the Model <code>Meta</code> Class. Now, an auto-incrementing primary key is created by default and the name of the primary key is always <code>pk</code>.</p> <p>Closed Issues</p> <ul> <li>Auto-generated primary key not returned by the Model (#37) by seapagan</li> </ul> <p>Breaking Changes</p> <ul> <li>Always create a <code>pk</code> primary auto-incrementing key (#39) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix <code>null</code> filter when combined with others and add tests (#40) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Refactor web docs layout and improve content (#36) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#040-september-27-2024","title":"0.4.0 (September 27, 2024)","text":"<p>New Features</p> <ul> <li>Add <code>exists_ok</code> and <code>force</code> flags to <code>create_table</code> (#34) by seapagan</li> <li>Add <code>reset=</code> to SqliterDB(), to drop all existing tables (#33) by seapagan</li> <li>Order by primary key if no field specified to <code>order()</code> (#32) by seapagan</li> <li>Add <code>drop_table</code> method (#31) by seapagan</li> <li>Add debug logging option (#29) by seapagan</li> <li>Create relevant database fields depending on the Model types (#27) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add test coverage where missing (#28) by seapagan</li> </ul> <p>Refactoring</p> <ul> <li>Perform some internal refactoring, mostly arranging the tests. (#30) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Add a documentation website and trim down the README (#25) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#030-september-23-2024","title":"0.3.0 (September 23, 2024)","text":"<p>Breaking Changes</p> <ul> <li>Rename 'create_id' to 'create_pk' (#23) by seapagan</li> </ul> <p>New Features</p> <ul> <li>Deprecate 'direction=' for 'reverse=' in <code>order()</code> method. (#24) by seapagan</li> <li>Add improved table name generation (#21) by seapagan</li> <li>Implement an in-memory database option (#15) by seapagan</li> <li>Allow selecting a subset of the database fields instead of all them (#12) by seapagan</li> <li>Improve dev tooling and contributor documentation (#11) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Update dependency ruff to v0.6.7 (#19) by renovate[bot]</li> <li>Update dependency pydantic to v2.9.2 (#18) by renovate[bot]</li> <li>Update dependency idna to v3.10 (#17) by renovate[bot]</li> <li>Update dependency zipp to v3.20.2 (#16) by renovate[bot]</li> <li>Update astral-sh/setup-uv action to v3 (#10) by renovate[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#020-september-14-2024","title":"0.2.0 (September 14, 2024)","text":"<p>New Features</p> <ul> <li>Default to auto_create=True, and add 'commit()' &amp; 'close()' methods (#9) by seapagan</li> <li>Add more advanced filtering options (#7) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context manager commits on exit (#8) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#011-september-12-2024","title":"0.1.1 (September 12, 2024)","text":"<p>Just a documentation fix - README was old version</p> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#010-september-12-2024","title":"0.1.0 (September 12, 2024)","text":"<p>New Features</p> <ul> <li>Remove transaction exception (TransactionError) (#4) by seapagan</li> <li>Improve error handling across the library (#3) by seapagan</li> <li>Add 'limit', 'offset' and 'order' methods (#2) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add a full test suite to the existing code. (#1) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Configure Renovate (#5) by renovate[bot]</li> </ul> <p>This changelog was generated using github-changelog-md by Seapagan</p>"},{"location":"contributing/","title":"Contributing to SQLiter","text":"<p>Thank you for your interest in contributing to SQLiter! We welcome all contributions, big or small.</p> <p>If you are not sure where to start, please take a look at the open issues. If you have an idea for a new feature or would like to report a bug, please open a new issue.</p> <p>We also welcome contributions to the documentation. If you find any errors or would like to suggest improvements, please open a new issue or submit a pull</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>This project requires Python 3.9 or higher.</li> </ul> <ul> <li>We use uv to manage our dependencies. You should have this installed as well. You can install <code>uv</code> by following the instructions on their website.</li> </ul> <p><code>uv</code> can be used to actually install Python, even if you do not have it installed locally (either by system, pyenv or similar).</p> <p>For example, to install Python 3.12 using <code>uv</code>, you can run the following command:</p> <pre><code>uv python install 3.12\n</code></pre> <p>If you already have a Python version installed, uv will use this.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please make sure you have read and understood our Code of Conduct and License.</p> <p>To get started, follow these steps:</p> <ol> <li>Fork the repository and clone it to your local machine.</li> <li>Install the required dependencies (see next section).</li> <li>Create a new branch for your changes: <code>git checkout -b my-new-feature</code>.</li> <li>Make your changes and commit them: <code>git commit -am 'Add some feature'</code>.</li> <li>Push your changes to your fork: <code>git push origin my-new-feature</code>.</li> <li>Create a new pull request.</li> </ol>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Run the following command to create a local virtualenv and install the required dependencies. We need the optional extras installed so the tests pass:</p> <pre><code>uv sync --all-extras\n</code></pre> <p>The <code>.venv</code> folder is already in the <code>.gitignore</code> file so will not be committed to the repository. This is where the virtual environment will be created.</p> <p>You then need to activate the virtual environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>From here you can start working on the project. If you are using an IDE such as VSCode or PyCharm, you can set their Python interpreter setting to use the virtual environment that has just been created.</p>"},{"location":"contributing/#install-git-pre-commit-hooks","title":"Install Git Pre-Commit hooks","text":"<p>Please do this if you are intending to submit a PR. It will check commits locally before they are pushed up to the Repo.</p> <pre><code>$ prek install\nprek installed at .git/hooks/pre-commit\n</code></pre> <p>This will ensure that all code meets the required linting standard before being committed.</p>"},{"location":"contributing/#run-checks-manually","title":"Run checks manually","text":"<p>You can run these checks manually on all staged files using the below command :</p> <pre><code>poe pre\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using pytest for testing. Tests will automatically be run when you submit a pull request. You can also run them manually using the following command:</p> <pre><code>pytest\n</code></pre> <p>If you add any new features, please add tests for them. This will help us to ensure that the code is working as expected and will prevent any regressions.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>The changelog is automatically generated using github-changelog-md, so please do not edit it manually.</p> <p>For maintainers, there is a POE task that will run this and update the changelog file.</p> <pre><code>poe changelog\n</code></pre> <p>You would also need to add a GitHub Personal Access Token to a local config file as usual. See the section in that tools Documentation for information.</p> <p>However, you should NOT include a change to the <code>CHANGELOG.md</code> file in any Pull Requests. This will be handled by the maintainers when a new release is made. Your GitHub username will be added to the changelog automatically beside your PR.</p>"},{"location":"contributing/#convenience-tasks","title":"Convenience Tasks","text":"<p>There are a few other convenience tasks that can be run using the <code>poe</code> command. These are defined in the <code>pyproject.toml</code> file.</p> <p>Each of these tasks can have extra options added which will be passed to the underlying tool.</p> <p>Run <code>mypy</code> on the code base in strict mode:</p> <pre><code>poe mypy\n</code></pre> <p>Format the code using <code>ruff format</code>:</p> <pre><code>poe format\n</code></pre> <p>Lint the code using <code>ruff check</code>:</p> <pre><code>poe ruff\n</code></pre>"},{"location":"contributing/#documentation-tasks","title":"Documentation Tasks","text":"<p>These are to help with developing and updating the documentation.</p> <ul> <li><code>poe docs:serve</code> - Serve the MkDocs locally for testing and development</li> <li><code>poe docs:serve:all</code> - Same as above, but opens to all interfaces so you can   view it on other devices on your network</li> <li><code>poe docs:build</code> - Build the MkDocs site into the <code>dist</code> folder</li> <li><code>poe docs:publish</code> - Publish the docs to your GitHub pages. Note that only   those with write-access to this repo can do this.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<p>Here are some guidelines to follow when contributing to SQLiter:</p> <ul> <li>Do not update the version number in the <code>pyproject.toml</code> file. This will be   done by the maintainers when a new release is made.</li> <li>Follow the PEP 8 style guide. The   prek hooks will check for this. We are using   Ruff as both a linter and code formatter.</li> <li>Try to have no linting errors or warnings. The prek hooks will check for   this also.</li> <li>MyPy is installed and we are using   type hints. Please try to add type hints to your code. If you see any areas of   the code that are missing type hints, please feel free to open a PR and add   them \ud83d\ude01!</li> <li>Write clear and concise commit messages.</li> <li>Write tests for your code.</li> <li>Make sure your code passes all tests before submitting a pull request.</li> <li>Document your code using   docstrings.</li> <li>Use GitHub issues   to report bugs or suggest new features.</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>If you have any questions or need help with contributing, please contact me @seapagan on GitHub. You can also use the GitHub Discussions feature.</p> <p>Happy contributing!</p>"},{"location":"guide/caching/","title":"Query Result Caching","text":"<p>SQLiter provides optional query result caching to improve performance by reducing database queries for frequently accessed data. The cache uses an LRU (Least Recently Used) eviction strategy and automatically invalidates when data is modified.</p> <p>Caching applies to both query builder results (via <code>select()</code>) and primary-key lookups with <code>db.get()</code> when <code>cache_enabled=True</code>.</p>"},{"location":"guide/caching/#enabling-caching","title":"Enabling Caching","text":"<p>Caching is opt-in and disabled by default. To enable caching, set <code>cache_enabled=True</code> when creating the database connection:</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(\"my_database.db\", cache_enabled=True)\n</code></pre>"},{"location":"guide/caching/#cache-configuration","title":"Cache Configuration","text":""},{"location":"guide/caching/#basic-configuration","title":"Basic Configuration","text":"<pre><code>db = SqliterDB(\n    \"my_database.db\",\n    cache_enabled=True,      # Enable caching (required)\n    cache_max_size=1000,     # Max cached queries per table (default: 1000)\n    cache_ttl=60,            # Time-to-live in seconds (default: None)\n    cache_max_memory_mb=100, # Memory limit per table in MB (default: None)\n)\n</code></pre>"},{"location":"guide/caching/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>cache_enabled</code> (<code>bool</code>, default: <code>False</code>): Enable or disable caching.</li> <li><code>cache_max_size</code> (<code>int</code>, default: <code>1000</code>): Maximum number of cached query   results per table. When exceeded, the least recently used entries are evicted.</li> <li><code>cache_ttl</code> (<code>int | None</code>, default: <code>None</code>): Default time-to-live for cached   results, in seconds. After this time, entries expire and are removed on next   access.</li> <li><code>cache_max_memory_mb</code> (<code>int | None</code>, default: <code>None</code>): Optional memory   limit per table, in megabytes. When exceeded, the least recently used entries   are evicted until under the limit.</li> </ul>"},{"location":"guide/caching/#how-caching-works","title":"How Caching Works","text":""},{"location":"guide/caching/#cache-key-generation","title":"Cache Key Generation","text":"<p>Each query generates a unique cache key based on:</p> <ul> <li>Table name</li> <li>Selected fields</li> <li>Filter conditions</li> <li>Order by clauses</li> <li>Limit and offset values</li> <li>Fetch mode (single vs list)</li> </ul> <p>This means different queries produce different cache entries:</p> <pre><code># These are cached separately\ndb.select(User).filter(name=\"Alice\").fetch_all()\ndb.select(User).filter(name=\"Bob\").fetch_all()\n\n# These are also cached separately (different fields)\ndb.select(User).only(\"name\").fetch_all()\ndb.select(User).fetch_all()\n</code></pre>"},{"location":"guide/caching/#cache-invalidation","title":"Cache Invalidation","text":"<p>The cache automatically invalidates when data is modified. Any write operation (insert, update, delete) on a table clears all cached queries for that table:</p> <pre><code># Query and cache the result\nusers = db.select(User).fetch_all()  # Cached\n\n# Insert new data - INVALIDATES cache for User table\ndb.insert(User(name=\"Charlie\", age=25))\n\n# This query hits the database again (cache was invalidated)\nusers = db.select(User).fetch_all()\n</code></pre>"},{"location":"guide/caching/#per-instance-scope","title":"Per-Instance Scope","text":"<p>The cache is tied to the database connection instance and is automatically cleared when:</p> <ul> <li>The connection is closed: <code>db.close()</code></li> <li>Exiting a context manager: <code>with SqliterDB(...) as db:</code></li> <li>The connection is deleted</li> </ul> <pre><code>with SqliterDB(\"mydb.db\", cache_enabled=True) as db:\n    db.select(User).fetch_all()  # Cached\n    # Cache is cleared when exiting context\n# Cache is empty here\n</code></pre>"},{"location":"guide/caching/#limitations","title":"Limitations","text":""},{"location":"guide/caching/#cache-key-type-compatibility","title":"Cache Key Type Compatibility","text":"<p>Cache keys are generated by sorting filter conditions to ensure consistency. This requires that filter values be comparable with each other.</p> <p>\u274c This will fail:</p> <pre><code># First query succeeds\ndb.select(User).filter(name=\"Alice\", age=30).fetch_all()\n\n# Second query fails at fetch time when generating cache key\ndb.select(User).filter(name=42, age=30).fetch_all()  # ValueError!\n</code></pre> <p>The second query fails when <code>fetch_all()</code> is called because Python cannot sort mixed types (strings vs numbers) when generating the cache key. The <code>filter()</code> call itself succeeds - the error occurs during cache key generation.</p> <p>\u2713 Correct usage:</p> <pre><code># Use consistent types for each field\ndb.select(User).filter(name=\"Alice\", age=30).fetch_all()\ndb.select(User).filter(name=\"Bob\", age=40).fetch_all()  # Works fine\n</code></pre> <p>This limitation only affects queries with incompatible value types for the same field. Normal filtering patterns (strings, numbers, dates used consistently) work without issues.</p>"},{"location":"guide/caching/#cache-statistics","title":"Cache Statistics","text":"<p>Track cache performance with the <code>get_cache_stats()</code> method:</p> <pre><code>stats = db.get_cache_stats()\nprint(stats)\n# Output: {\"hits\": 150, \"misses\": 50, \"total\": 200, \"hit_rate\": 75.0}\n</code></pre> <ul> <li><code>hits</code>: Number of times a cached result was returned</li> <li><code>misses</code>: Number of times the database was queried (cache miss)</li> <li><code>total</code>: Total cache lookups (hits + misses)</li> <li><code>hit_rate</code>: Percentage of cache hits (0-100)</li> </ul>"},{"location":"guide/caching/#clearing-the-cache","title":"Clearing the Cache","text":"<p>Manually clear all cached query results using the <code>clear_cache()</code> method:</p> <pre><code># Cache some queries\ndb.select(User).fetch_all()\ndb.select(User).filter(name=\"Alice\").fetch_one()\n\n# Clear all cached entries from all tables\ndb.clear_cache()\n</code></pre> <p>Use cases for <code>clear_cache()</code>:</p> <ul> <li>Force fresh data: After external database changes, clear the cache to ensure   subsequent queries fetch the latest data</li> <li>Free memory: Explicitly release memory used by cached results when needed</li> <li>Reset state: Clear cached data before running tests or batch operations</li> <li>Data synchronization: When the database is modified by another process or   connection</li> </ul>"},{"location":"guide/caching/#example-force-fresh-queries-after-external-changes","title":"Example: Force fresh queries after external changes","text":"<pre><code># Query and cache results\nusers = db.select(User).fetch_all()\n\n# External process modifies the database...\n# Clear the cache to force fresh queries\ndb.clear_cache()\n\n# This query now fetches fresh data from the database\nusers = db.select(User).fetch_all()\n</code></pre> <p>Note: <code>clear_cache()</code> does not reset cache statistics (hits/misses). It only removes the cached query results themselves.</p>"},{"location":"guide/caching/#query-level-controls","title":"Query-Level Controls","text":""},{"location":"guide/caching/#bypassing-the-cache","title":"Bypassing the Cache","text":"<p>Force a specific query to skip the cache and always fetch fresh data from the database:</p> <pre><code># Force fresh data, bypassing cache\nuser = db.select(User).filter(name=\"Alice\").bypass_cache().fetch_one()\n</code></pre> <p>Use cases:</p> <ul> <li>Fetching real-time data that may have changed externally</li> <li>Debugging queries to verify database content</li> <li>Admin operations that require absolute freshness</li> </ul> <p>You can also bypass caching for a single <code>get()</code> call:</p> <pre><code>user = db.get(User, 1, bypass_cache=True)\n</code></pre>"},{"location":"guide/caching/#per-query-ttl","title":"Per-Query TTL","text":"<p>Override the global <code>cache_ttl</code> setting for a specific query:</p> <pre><code># Cache this result for 5 minutes (300 seconds)\nusers = db.select(User).cache_ttl(300).fetch_all()\n</code></pre> <p>Use cases:</p> <ul> <li>Shorter TTL for frequently changing data</li> <li>Longer TTL for rarely changing reference data</li> </ul> <p>You can override TTL for a single <code>get()</code> call as well:</p> <pre><code>user = db.get(User, 1, cache_ttl=300)\n</code></pre> <ul> <li>Different TTL requirements for different query types</li> </ul>"},{"location":"guide/caching/#empty-result-caching","title":"Empty Result Caching","text":"<p>Both <code>None</code> and empty list <code>[]</code> results are cached:</p> <pre><code># Query that returns no result (fetch_one)\nresult = db.select(User).filter(name=\"NonExistent\").fetch_one()\n# Returns: None (cached)\n\n# Query that returns no results (fetch_all)\nresults = db.select(User).filter(age__gt=200).fetch_all()\n# Returns: [] (cached)\n</code></pre>"},{"location":"guide/caching/#memory-limiting","title":"Memory Limiting","text":"<p>Use <code>cache_max_memory_mb</code> to prevent the cache from consuming too much memory:</p> <pre><code># Limit cache to 10MB per table\ndb = SqliterDB(\"mydb.db\", cache_enabled=True, cache_max_memory_mb=10)\n</code></pre> <p>When the memory limit is exceeded:</p> <ol> <li>The cache evicts the least recently used entries</li> <li>Continues evicting until there's room for the new entry</li> <li>Memory usage is tracked per table</li> </ol>"},{"location":"guide/caching/#best-practices","title":"Best Practices","text":""},{"location":"guide/caching/#when-to-enable-caching","title":"When to Enable Caching","text":"<p>Caching is beneficial when:</p> <ul> <li>You have read-heavy workloads</li> <li>The same queries are executed repeatedly</li> <li>Data doesn't change frequently</li> <li>Query execution time is significant</li> </ul>"},{"location":"guide/caching/#when-to-bypass-cache","title":"When to Bypass Cache","text":"<p>Use <code>bypass_cache()</code> when:</p> <ul> <li>You need guaranteed fresh data</li> <li>Debugging data consistency issues</li> <li>Performing administrative operations</li> </ul>"},{"location":"guide/caching/#ttl-guidelines","title":"TTL Guidelines","text":"<ul> <li>Short TTL (1-60 seconds): Frequently changing data, user sessions</li> <li>Medium TTL (1-10 minutes): Moderately changing data, dashboards</li> <li>Long TTL (10+ minutes): Rarely changing data, configuration/reference data</li> <li>No TTL: Cache until invalidated by writes</li> </ul>"},{"location":"guide/caching/#memory-limits","title":"Memory Limits","text":"<p>Set <code>cache_max_memory_mb</code> when:</p> <ul> <li>Running in memory-constrained environments</li> <li>Caching large result sets</li> <li>Preventing cache from growing unbounded</li> </ul>"},{"location":"guide/caching/#trade-offs","title":"Trade-offs","text":""},{"location":"guide/caching/#advantages","title":"Advantages","text":"<ul> <li>Reduced database load: Fewer queries hit the database</li> <li>Faster response times: Cached results return instantly</li> <li>Lower CPU usage: Avoid query parsing and execution overhead</li> <li>Better scalability: Handle more read requests with same resources</li> </ul>"},{"location":"guide/caching/#disadvantages","title":"Disadvantages","text":"<ul> <li>Memory consumption: Cached data occupies RAM</li> <li>Stale data risk: Cache may serve outdated data until invalidated</li> <li>Complexity: Additional configuration and monitoring</li> <li>Memory overhead: Each cached entry uses memory for objects and metadata</li> </ul>"},{"location":"guide/caching/#recommendations","title":"Recommendations","text":"<ul> <li>Start with caching disabled, enable only when needed</li> <li>Monitor cache statistics to measure effectiveness</li> <li>Use memory limits to prevent unbounded growth</li> <li>Set appropriate TTLs based on data change frequency</li> <li>Profile before and after to measure performance gains</li> </ul>"},{"location":"guide/connecting/","title":"Connecting to the Database","text":""},{"location":"guide/connecting/#creating-a-connection","title":"Creating a Connection","text":"<p>To connect to a database (and create the file if it does not already exist), you create an instance of the <code>SqliterDB</code> class. This will automatically take care of connecting to or creating the database file.</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(\"your_database.db\")\n</code></pre> <p>The default behavior is to automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>It is then up to you to manually commit changes using the <code>commit()</code> method. This can be useful when you want to perform multiple operations in a single transaction without the overhead of committing after each operation.</p>"},{"location":"guide/connecting/#using-an-in-memory-database","title":"Using an In-Memory Database","text":"<p>If you want to use an in-memory database, you can set <code>memory=True</code> when creating the database connection:</p> <pre><code>db = SqliterDB(memory=True)\n</code></pre> <p>This will create an in-memory database that is not persisted to disk. If you also specify a database name, it will be ignored.</p> <pre><code>db = SqliterDB(\"ignored.db\", memory=True)\n</code></pre> <p>The <code>ignored.db</code> file will not be created, and the database will be in-memory. If you do not specify a database name, and do NOT set <code>memory=True</code>, an exception will be raised.</p> <p>Note</p> <p>You can also use <code>\":memory:\"</code> as the database name (same as normal with Sqlite) to create an in-memory database, this is just a cleaner and more descriptive way to do it.</p> <pre><code>db = SqliterDB(\":memory:\")\n</code></pre>"},{"location":"guide/connecting/#resetting-the-database","title":"Resetting the Database","text":"<p>If you want to reset an existing database when you create the SqliterDB object, you can pass <code>reset=True</code>:</p> <pre><code>db = SqliterDB(\"your_database.db\", reset=True)\n</code></pre> <p>This will effectively drop all user tables from the database. The file itself is not deleted, only the tables are dropped.</p>"},{"location":"guide/connecting/#caching-options","title":"Caching Options","text":"<p>SQLiter provides optional query result caching to improve performance by reducing database queries. See the Caching page for detailed information.</p> <pre><code>db = SqliterDB(\n    \"your_database.db\",\n    cache_enabled=True,        # Enable caching (default: False)\n    cache_max_size=1000,       # Max cached queries per table\n    cache_ttl=60,              # Time-to-live in seconds (None = no expiry)\n    cache_max_memory_mb=100,   # Memory limit per table in MB\n)\n</code></pre>"},{"location":"guide/connecting/#database-properties","title":"Database Properties","text":"<p>The <code>SqliterDB</code> class provides several properties to access information about the database instance once it has been created. See the Properties page (next) for more details.</p>"},{"location":"guide/data-operations/","title":"Data Operations","text":""},{"location":"guide/data-operations/#inserting-records","title":"Inserting Records","text":"<p>The <code>insert()</code> method is used to add records to the database. You pass an instance of your model class to the method, and SQLiter will insert the record into the correct table:</p> <pre><code>user = User(name=\"Jane Doe\", age=25, email=\"jane@example.com\")\nresult = db.insert(user)\n</code></pre> <p>The <code>result</code> variable will contain a new instance of the model, with the primary key value set to the newly-created primary key in the database. You should use this instance to access the primary key value and other fields:</p> <pre><code>print(f\"New record inserted with primary key: {result.pk}\")\nprint(f\"Name: {result.name}, Age: {result.age}, Email: {result.email}\")\n</code></pre>"},{"location":"guide/data-operations/#overriding-the-timestamps","title":"Overriding the Timestamps","text":"<p>By default, SQLiter will automatically set the <code>created_at</code> and <code>updated_at</code> fields to the current Unix timestamp in UTC when a record is inserted. If you want to override this behavior, you can set the <code>created_at</code> and <code>updated_at</code> fields manually before calling <code>insert()</code>:</p> <pre><code>import time\n\nuser.created_at = int(time.time())\nuser.updated_at = int(time.time())\n</code></pre> <p>However, by default this is disabled. Any model passed to <code>insert()</code> will have the <code>created_at</code> and <code>updated_at</code> fields set automatically and ignore any values passed in these 2 fields.</p> <p>If you want to enable this feature, you can set the <code>timestamp_override</code> flag to <code>True</code> when inserting the record:</p> <pre><code>result = db.insert(user, timestamp_override=True)\n</code></pre> <p>Important</p> <p>The <code>insert()</code> method will raise a <code>RecordInsertionError</code> if you try to insert a record with a primary key that already exists in the table or if the table does not exist.</p>"},{"location":"guide/data-operations/#bulk-inserting-records","title":"Bulk Inserting Records","text":"<p>Use <code>bulk_insert()</code> to insert multiple records of the same model in a single transaction. This is more efficient than calling <code>insert()</code> in a loop because all records are committed together:</p> <pre><code>users = [\n    User(name=\"Alice\", age=30, email=\"alice@example.com\"),\n    User(name=\"Bob\", age=25, email=\"bob@example.com\"),\n    User(name=\"Carol\", age=28, email=\"carol@example.com\"),\n]\nresults = db.bulk_insert(users)\n</code></pre> <p>The returned list contains new model instances with primary keys assigned:</p> <pre><code>for user in results:\n    print(f\"Inserted {user.name} with pk={user.pk}\")\n</code></pre> <p>Passing an empty list returns <code>[]</code> without touching the database. If any record in the batch fails (for example, a foreign key constraint violation), the entire batch is rolled back and no records are inserted.</p>"},{"location":"guide/data-operations/#overriding-the-timestamps_1","title":"Overriding the Timestamps","text":"<p>Like <code>insert()</code>, <code>bulk_insert()</code> automatically sets <code>created_at</code> and <code>updated_at</code> on each record. Pass <code>timestamp_override=True</code> to preserve values you set manually:</p> <pre><code>results = db.bulk_insert(users, timestamp_override=True)\n</code></pre>"},{"location":"guide/data-operations/#using-with-transactions","title":"Using with Transactions","text":"<p>When called inside a <code>with db:</code> transaction context, <code>bulk_insert()</code> defers the commit to the context exit, so you can combine it with other operations in one atomic transaction:</p> <pre><code>with db:\n    authors = db.bulk_insert(author_list)\n    books = db.bulk_insert(book_list)\n    # Both batches committed together on exit\n</code></pre> <p>Important</p> <p>All instances passed to <code>bulk_insert()</code> must be of the same model type. Mixing different model types raises a <code>ValueError</code>.</p>"},{"location":"guide/data-operations/#querying-records","title":"Querying Records","text":"<p><code>SQLiter</code> provides a simple and intuitive API for querying records from the database, Starting with the <code>select()</code> method and chaining other methods to filter, order, limit, and offset the results:</p> <pre><code># Fetch all users\nall_users = db.select(User).fetch_all()\n\n# Filter users\nyoung_users = db.select(User).filter(age=25).fetch_all()\n\n# Order users\nordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n\n# Limit and offset\npaginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre> <p>Important</p> <p>The <code>select()</code> MUST come first, before any filtering, ordering, or pagination etc. This is the starting point for building your query.</p> <p>See Filtering Results for more advanced filtering options.</p>"},{"location":"guide/data-operations/#updating-records","title":"Updating Records","text":"<p>You can update records in the database by modifying the fields of the model instance and then calling the <code>update()</code> method. You just pass the model instance to the method:</p> <pre><code>user.age = 26\ndb.update(user)\n</code></pre> <p>Important</p> <p>The model you pass must have a primary key value set, otherwise an error will be raised. In other words, you use the instance of a model returned by the <code>insert()</code> method to update the record as it has the primary key value set, not the original instance you passed to <code>insert()</code>.</p> <p>You can also set the primary key value on the model instance manually before calling <code>update()</code> if you have that.</p> <p>On suffescul update, the <code>updated_at</code> field will be set to the current Unix timestamp in UTC by default.</p> <p>Warning</p> <p>Unlike with the <code>insert()</code> method, you CANNOT override the <code>updated_at</code> field when calling <code>update()</code>. It will always be set to the current Unix timestamp in UTC. This is to ensure that the <code>updated_at</code> field is always accurate.</p>"},{"location":"guide/data-operations/#deleting-records","title":"Deleting Records","text":"<p>SQLiter provides two ways to delete records:</p>"},{"location":"guide/data-operations/#single-record-deletion","title":"Single Record Deletion","text":"<p>To delete a single record from the database by its primary key, use the <code>delete()</code> method directly on the database instance:</p> <pre><code>db.delete(User, user.pk)\n</code></pre> <p>Important</p> <p>The single record deletion method will raise:</p> <ul> <li><code>RecordNotFoundError</code> if the record with the specified primary key is not found</li> <li><code>RecordDeletionError</code> if there's an error during the deletion process</li> </ul>"},{"location":"guide/data-operations/#query-based-deletion","title":"Query-Based Deletion","text":"<p>You can also use a query to delete records that match specific criteria. The <code>delete()</code> method will delete all records returned by the query and return an integer with the count of records deleted:</p> <pre><code># Delete all users over 30\ndeleted_count = db.select(User).filter(age__gt=30).delete()\n\n# Delete inactive users in a specific age range\ndeleted_count = db.select(User).filter(\n    age__gte=25,\n    age__lt=40,\n    status=\"inactive\"\n).delete()\n\n# Delete all records from a table\ndeleted_count = db.select(User).delete()\n</code></pre> <p>Note</p> <p>The query-based delete operation ignores any <code>limit()</code>, <code>offset()</code>, or <code>order()</code> clauses that might be in the query chain. It will always delete ALL records that match the filter conditions.</p>"},{"location":"guide/data-operations/#commit-your-changes","title":"Commit your changes","text":"<p>By default, SQLiter will automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>You can then manually commit changes using the <code>commit()</code> method:</p> <pre><code>db.commit()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>commit()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/data-operations/#close-the-connection","title":"Close the Connection","text":"<p>When you're done with the database connection, you should close it to release resources:</p> <pre><code>db.close()\n</code></pre> <p>Note that closing the connection will also commit any pending changes, unless <code>auto_commit</code> is set to <code>False</code>.</p> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/debug/","title":"Debug Logging","text":"<p>You can enable debug logging to see the SQL queries being executed by SQLiter. This can be useful for debugging and understanding the behavior of your application. It is disabled by default, and can be set on the <code>SqliterDB</code> class:</p> <pre><code>db = SqliterDB(\"your_database.db\", debug=True)\n</code></pre> <p>This will print the SQL queries to the console as they are executed. If there is an existing logger in your application then SQLiter will use that logger, otherwise it will create and use a new logger named <code>sqliter</code>.</p>"},{"location":"guide/exceptions/","title":"Exceptions","text":"<p>SQLiter includes several custom exceptions to handle specific errors that may occur during database operations. These exceptions inherit from a common base class, <code>SqliterError</code>, to ensure consistency across error messages and behavior.</p> <ul> <li><code>SqliterError</code>:<ul> <li>The base class for all exceptions in SQLiter. It captures the exception   context and chains any previous exceptions.</li> <li>Message: \"An error occurred in the SQLiter package.\"</li> </ul> </li> </ul> <ul> <li><code>DatabaseConnectionError</code>:<ul> <li>Raised when the SQLite database connection fails.</li> <li>Message: \"Failed to connect to the database: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOffsetError</code>:<ul> <li>Raised when an invalid offset value (0 or negative) is used in queries.</li> <li>Message: \"Invalid offset value: '{}'. Offset must be a positive   integer.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOrderError</code>:<ul> <li>Raised when an invalid order value is used in queries, such as a   non-existent field or an incorrect sorting direction.</li> <li>Message: \"Invalid order value - '{}'\"</li> </ul> </li> </ul> <ul> <li><code>TableCreationError</code>:<ul> <li>Raised when a table cannot be created in the database.</li> <li>Message: \"Failed to create the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordInsertionError</code>:<ul> <li>Raised when an error occurs during record insertion.</li> <li>Message: \"Failed to insert record into table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordUpdateError</code>:<ul> <li>Raised when an error occurs during record update.</li> <li>Message: \"Failed to update record in table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordNotFoundError</code>:<ul> <li>Raised when a record with the specified primary key is not found.</li> <li>Message: \"Failed to find a record for key '{}'\".</li> </ul> </li> </ul> <ul> <li><code>RecordFetchError</code>:<ul> <li>Raised when an error occurs while fetching records from the database.</li> <li>Message: \"Failed to fetch record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordDeletionError</code>:<ul> <li>Raised when an error occurs during record deletion.</li> <li>Message: \"Failed to delete record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidFilterError</code>:<ul> <li>Raised when an invalid filter field is used in a query.</li> <li>Message: \"Failed to apply filter: invalid field '{}'\".</li> </ul> </li> </ul> <ul> <li><code>TableDeletionError</code>:<ul> <li>Raised when a table cannot be deleted from the database.</li> <li>Message: \"Failed to delete the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li>SqlExecutionError<ul> <li>Raised when an error occurs during SQL query execution.</li> <li>Message: \"Failed to execute SQL: '{}'.\"</li> </ul> </li> </ul> <ul> <li>InvalidIndexError<ul> <li>Raised when an invalid index is specified for a model.</li> <li>Message: \"Invalid fields for indexing in model '{}': {}\"</li> </ul> </li> </ul>"},{"location":"guide/fields/","title":"Field Control","text":""},{"location":"guide/fields/#selecting-specific-fields","title":"Selecting Specific Fields","text":"<p>By default, all commands query and return all fields in the table. If you want to select only specific fields, you can pass them using the <code>fields()</code> method:</p> <pre><code>results = db.select(User).fields([\"name\", \"age\"]).fetch_all()\n</code></pre> <p>This will return only the <code>name</code> and <code>age</code> fields for each record.</p> <p>Note: When using <code>fields()</code>, unselected fields will not be present on the returned model instances. Only access fields you have selected.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, fields=[\"name\", \"age\"]).fetch_all()\n</code></pre> <p>Note that using the <code>fields()</code> method will override any fields specified in the 'select()' method.</p>"},{"location":"guide/fields/#excluding-specific-fields","title":"Excluding Specific Fields","text":"<p>If you want to exclude specific fields from the results, you can use the <code>exclude()</code> method:</p> <pre><code>results = db.select(User).exclude([\"email\"]).fetch_all()\n</code></pre> <p>This will return all fields except the <code>email</code> field.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, exclude=[\"email\"]).fetch_all()\n</code></pre>"},{"location":"guide/fields/#returning-exactly-one-explicit-field-only","title":"Returning exactly one explicit field only","text":"<p>If you only want to return a single field from the results, you can use the <code>only()</code> method:</p> <pre><code>result = db.select(User).only(\"name\").fetch_first()\n</code></pre> <p>This will return only the <code>name</code> field for the first record.</p> <p>This is exactly the same as using the <code>fields()</code> method with a single field, but very specific and obvious. There is NO equivalent argument to this in the <code>select()</code> method. An exception WILL be raised if you try to use this method with more than one field.</p>"},{"location":"guide/fields/#complex-data-types","title":"Complex Data Types","text":"<p>SQLiter supports storing complex Python data types in the database. The following types are supported:</p> <ul> <li><code>list[T]</code>: Lists of any type T</li> <li><code>dict[K, V]</code>: Dictionaries with keys of type K and values of type V</li> <li><code>set[T]</code>: Sets of any type T</li> <li><code>tuple[T, ...]</code>: Tuples of any type T</li> </ul> <p>These types are automatically serialized and stored as BLOBs in the database. Here's an example of using complex types:</p> <pre><code>from typing import Any\nfrom sqliter import Model\n\nclass UserPreferences(Model):\n    tags: list[str] = []  # List of string tags\n    metadata: dict[str, Any] = {}  # Dictionary with string keys and any value type\n    friends: set[int] = set()  # Set of user IDs\n    coordinates: tuple[float, float] = (0.0, 0.0)  # Tuple of two floats\n\n# Create and save an instance\nprefs = UserPreferences(\n    tags=[\"python\", \"sqlite\", \"orm\"],\n    metadata={\"theme\": \"dark\", \"notifications\": True},\n    friends={1, 2, 3},\n    coordinates=(51.5074, -0.1278)\n)\nprefs.save()\n\n# Query and use the complex types\nloaded_prefs = UserPreferences.get(prefs.id)\nprint(loaded_prefs.tags)  # ['python', 'sqlite', 'orm']\nprint(loaded_prefs.metadata[\"theme\"])  # 'dark'\nprint(1 in loaded_prefs.friends)  # True\nprint(loaded_prefs.coordinates)  # (51.5074, -0.1278)\n</code></pre> <p>The complex types are automatically validated using Pydantic's type system, ensuring that only values of the correct type can be stored. When querying, the values are automatically deserialized back into their original Python types.</p> <p>Note that since these types are stored as BLOBs, you cannot perform SQL operations on their contents (like searching or filtering). If you need to search or filter based on these values, you should consider storing them in a different format or in separate tables.</p>"},{"location":"guide/filtering/","title":"Filtering Results","text":"<p>The <code>filter()</code> method in SQLiter supports various filter options to query records, and can be combined with other methods like <code>order()</code>, <code>limit()</code>, and <code>offset()</code> to build more complex queries:</p> <pre><code>result = db.select(User).filter(age__lte=30).limit(10).fetch_all()\n</code></pre> <p>It is possible to both add multiple filters in the same call, and to chain multiple filter calls together:</p> <pre><code>result = db.select(User).filter(age__gte=20, age__lte=30).fetch_all()\n</code></pre> <pre><code>result = db.select(User).filter(age__gte=20).filter(age__lte=30).fetch_all()\n</code></pre>"},{"location":"guide/filtering/#basic-filters","title":"Basic Filters","text":"<ul> <li><code>__eq</code>: Equal to (default if no operator is specified)<ul> <li>Example: <code>name=\"John\"</code> or <code>name__eq=\"John\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#null-checks","title":"Null Checks","text":"<ul> <li><code>__isnull</code>: Is NULL<ul> <li>Example: <code>email__isnull=True</code></li> </ul> </li> <li><code>__notnull</code>: Is NOT NULL<ul> <li>Example: <code>email__notnull=True</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>__lt</code>: Less than<ul> <li>Example: <code>age__lt=30</code></li> </ul> </li> <li><code>__lte</code>: Less than or equal to<ul> <li>Example: <code>age__lte=30</code></li> </ul> </li> <li><code>__gt</code>: Greater than<ul> <li>Example: <code>age__gt=30</code></li> </ul> </li> <li><code>__gte</code>: Greater than or equal to<ul> <li>Example: <code>age__gte=30</code></li> </ul> </li> <li><code>__ne</code>: Not equal to<ul> <li>Example: <code>status__ne=\"inactive\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#list-operations","title":"List Operations","text":"<ul> <li><code>__in</code>: In a list of values<ul> <li>Example: <code>status__in=[\"active\", \"pending\"]</code></li> </ul> </li> <li><code>__not_in</code>: Not in a list of values<ul> <li>Example: <code>category__not_in=[\"archived\", \"deleted\"]</code></li> </ul> </li> </ul> <p>Note: List values are only valid with <code>__in</code> and <code>__not_in</code> operators. Using lists with equality or comparison operators (<code>__eq</code>, <code>__lt</code>, <code>__gt</code>, etc.) will raise a <code>TypeError</code>. These operators require scalar values.</p>"},{"location":"guide/filtering/#pattern-matching","title":"Pattern Matching","text":""},{"location":"guide/filtering/#like-operator","title":"LIKE Operator","text":"<p>The <code>__like</code> operator provides SQL LIKE pattern matching with wildcards:</p> <ul> <li><code>%</code> matches any sequence of characters (including zero characters)</li> <li><code>_</code> matches any single character</li> </ul> <pre><code># Starts with 'A'\nusers = db.select(User).filter(name__like=\"A%\").fetch_all()\n\n# Ends with 'son'\nusers = db.select(User).filter(name__like=\"%son\").fetch_all()\n\n# Contains 'mid' anywhere\nusers = db.select(User).filter(description__like=\"%mid%\").fetch_all()\n\n# Exactly 3 characters ending in 'ob'\nusers = db.select(User).filter(name__like=\"_ob\").fetch_all()\n</code></pre>"},{"location":"guide/filtering/#case-sensitivity-limitations","title":"Case Sensitivity Limitations","text":"<p>SQLite's <code>LIKE</code> operator is case-insensitive only for ASCII characters (A-Z):</p> <pre><code># \u2705 Case-insensitive for ASCII\nusers = db.select(User).filter(name__like=\"alice\").fetch_all()\n# Matches: \"Alice\", \"ALICE\", \"alice\"\n\n# \u274c Case-SENSITIVE for non-ASCII Unicode characters\nusers = db.select(User).filter(name__like=\"caf\u00e9\").fetch_all()\n# Does NOT match: \"CAF\u00c9\" or \"Caf\u00e9\"\n# Only matches: \"caf\u00e9\"\n</code></pre> <p>For Unicode-aware case-insensitive matching, use the <code>__icontains</code>, <code>__istartswith</code>, or <code>__iendswith</code> operators instead:</p> <pre><code># \u2705 Case-insensitive for all Unicode characters\nusers = db.select(User).filter(name__icontains=\"caf\u00e9\").fetch_all()\n# Matches: \"caf\u00e9\", \"CAF\u00c9\", \"Caf\u00e9\", \"Grand Caf\u00e9\"\n\nusers = db.select(User).filter(name__istartswith=\"caf\u00e9\").fetch_all()\n# Matches: \"caf\u00e9\", \"CAF\u00c9\", \"Caf\u00e9 Noir\"\n</code></pre> <p>Warning</p> <p>The <code>LIKE</code> operator in SQLite is only case-insensitive for ASCII letters. If your data includes accented characters, non-Latin scripts, or any non-ASCII text, use <code>__icontains</code>, <code>__istartswith</code>, or <code>__iendswith</code> for reliable case-insensitive matching</p>"},{"location":"guide/filtering/#string-operations-case-sensitive","title":"String Operations (Case-Sensitive)","text":"<ul> <li><code>__startswith</code>: Starts with<ul> <li>Example: <code>name__startswith=\"A\"</code></li> </ul> </li> <li><code>__endswith</code>: Ends with<ul> <li>Example: <code>email__endswith=\".com\"</code></li> </ul> </li> <li><code>__contains</code>: Contains<ul> <li>Example: <code>description__contains=\"important\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#string-operations-case-insensitive","title":"String Operations (Case-Insensitive)","text":"<ul> <li><code>__istartswith</code>: Starts with (case-insensitive)<ul> <li>Example: <code>name__istartswith=\"a\"</code></li> </ul> </li> <li><code>__iendswith</code>: Ends with (case-insensitive)<ul> <li>Example: <code>email__iendswith=\".COM\"</code></li> </ul> </li> <li><code>__icontains</code>: Contains (case-insensitive)<ul> <li>Example: <code>description__icontains=\"IMPORTANT\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#relationship-filter-traversal","title":"Relationship Filter Traversal","text":"<p>Filter on fields across related models using double underscore (<code>__</code>) syntax. This feature works with ORM foreign keys (<code>sqliter.orm.ForeignKey</code>):</p> <pre><code>from sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# Filter by related model field\nbooks = db.select(Book).filter(author__name=\"Jane Austen\").fetch_all()\n\n# Works with all comparison operators\nbooks = db.select(Book).filter(author__name__like=\"Jane%\").fetch_all()\nbooks = db.select(Book).filter(author__name__in=[\"Jane\", \"Charles\"]).fetch_all()\n</code></pre> <p>This is equivalent to a SQL JOIN with WHERE clause on the related table.</p>"},{"location":"guide/filtering/#nested-relationships","title":"Nested Relationships","text":"<p>For relationships spanning multiple levels, chain the double underscore syntax:</p> <pre><code>class Comment(BaseDBModel):\n    text: str\n    book: ForeignKey[Book] = ForeignKey(Book, on_delete=\"CASCADE\")\n\n# Filter across two levels of relationships\ncomments = db.select(Comment).filter(book__author__name=\"Jane\").fetch_all()\n</code></pre>"},{"location":"guide/filtering/#combining-with-eager-loading","title":"Combining with Eager Loading","text":"<p>For best performance, combine relationship filters with <code>select_related()</code>:</p> <pre><code># Filter AND load in single query\nresults = (\n    db.select(Book)\n    .select_related(\"author\")\n    .filter(author__name__startswith=\"J\")\n    .fetch_all()\n)\n\nfor book in results:\n    print(f\"{book.title} by {book.author.name}\")  # No additional query\n</code></pre> <p>Note</p> <p>Relationship filter traversal only works with ORM foreign keys from <code>sqliter.orm.ForeignKey</code>. For explicit foreign keys, filter using the <code>_id</code> field directly (e.g., <code>author_id=42</code>).</p>"},{"location":"guide/foreign-keys/","title":"Foreign Keys","text":"<p>Foreign keys define relationships between models, enabling referential integrity in your database. When you define a foreign key, SQLiter ensures that the referenced record exists and automatically handles actions when the referenced record is deleted or updated.</p>"},{"location":"guide/foreign-keys/#two-approaches","title":"Two Approaches","text":"<p>SQLiter offers two ways to work with foreign keys:</p> Feature Explicit FK ORM FK Import <code>sqliter.model</code> <code>sqliter.orm</code> Syntax <code>author_id: int = ForeignKey(Author)</code> <code>author: ForeignKey[Author] = ForeignKey(Author)</code> Access related object Manual: <code>db.get(Author, book.author_id)</code> Automatic: <code>book.author.name</code> Reverse relationships Manual queries <code>author.books.fetch_all()</code> Lazy loading No Yes Caching N/A Yes (per instance) Overhead Minimal Slightly more"},{"location":"guide/foreign-keys/#which-should-i-use","title":"Which Should I Use?","text":""},{"location":"guide/foreign-keys/#use-explicit-foreign-keys-when","title":"Use Explicit Foreign Keys when","text":"<ul> <li>You want minimal abstraction over the database</li> <li>You're managing IDs manually anyway</li> <li>You don't need lazy loading or reverse relationships</li> <li>You want the simplest possible setup</li> <li>Performance is critical and you want to avoid any overhead</li> </ul> <p>Example:</p> <pre><code>from sqliter.model import BaseDBModel, ForeignKey\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# Manual access\nauthor = db.get(Author, book.author_id)\n</code></pre> <p>Read the Explicit Foreign Keys guide</p>"},{"location":"guide/foreign-keys/#use-orm-foreign-keys-when","title":"Use ORM Foreign Keys when","text":"<ul> <li>You want <code>book.author.name</code> style access</li> <li>You need reverse relationships (<code>author.books</code>)</li> <li>You prefer Django/SQLAlchemy-style patterns</li> <li>You want automatic caching of related objects</li> <li>Convenience is more important than minimal overhead</li> </ul> <p>Example:</p> <pre><code>from sqliter.orm import BaseDBModel, ForeignKey\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# Automatic lazy loading\nprint(book.author.name)\n\n# Reverse relationships\nfor book in author.books.fetch_all():\n    print(book.title)\n</code></pre> <p>Read the ORM Foreign Keys guide</p>"},{"location":"guide/foreign-keys/#performance-comparison","title":"Performance Comparison","text":"<p>Understanding the performance characteristics of each approach helps you make informed decisions based on your use case.</p>"},{"location":"guide/foreign-keys/#overhead-breakdown","title":"Overhead Breakdown","text":"Aspect Explicit FK ORM FK Memory overhead None Minimal (LazyLoader proxy per FK field) Query overhead None None (parameterized queries) Cache overhead None Small (one cached object per instance) Attribute access Direct field access Descriptor + proxy lookup Relationship queries Manual <code>db.select()</code> Built-in methods (same queries)"},{"location":"guide/foreign-keys/#query-comparison","title":"Query Comparison","text":"<p>Both approaches execute the same underlying SQL queries:</p> <pre><code># Explicit FK - Manual query\nauthor = db.get(Author, book.author_id)  # SELECT * FROM authors WHERE pk = ?\n\n# ORM FK - Automatic lazy loading\nauthor = book.author  # Same query: SELECT * FROM authors WHERE pk = ?\n</code></pre> <p>Key insight: The queries are identical. The difference is in convenience and when queries execute.</p>"},{"location":"guide/foreign-keys/#single-object-access","title":"Single Object Access","text":"<p>For accessing a single related object, the overhead is negligible:</p> <pre><code># Explicit FK: ~2 operations (field access + manual query)\nbook = db.get(Book, 1)\nauthor = db.get(Author, book.author_id)\n\n# ORM FK: ~3 operations (descriptor + proxy + automatic query)\nbook = db.get(Book, 1)\nauthor = book.author\n\n# Performance difference: Microseconds (typically &lt; 0.01ms)\n</code></pre> <p>Recommendation: Choose based on preference, not performance.</p>"},{"location":"guide/foreign-keys/#collections-and-loops","title":"Collections and Loops","text":"<p>For collections, ORM FK can cause N+1 query problems if not used carefully:</p> <pre><code># \u274c Explicit FK: Still need N+1 queries\nbooks = db.select(Book).fetch_all()\nfor book in books:\n    author = db.get(Author, book.author_id)  # N queries\n\n# \u274c ORM FK: Same N+1 problem\nbooks = db.select(Book).fetch_all()\nfor book in books:\n    print(book.author.name)  # N queries (lazy loading each author)\n\n# \u2705 Both approaches: Use reverse relationships to avoid N+1\nauthors = db.select(Author).fetch_all()\nfor author in authors:\n    books = author.books.fetch_all()  # One query per author\n    for book in books:\n        print(f\"{book.title} by {author.name}\")\n</code></pre> <p>Recommendation: Both approaches suffer from N+1 if used carelessly. Design your queries thoughtfully regardless of which approach you choose.</p>"},{"location":"guide/foreign-keys/#caching-benefits-orm-fk-only","title":"Caching Benefits (ORM FK Only)","text":"<p>ORM FK caches loaded objects, which helps in some scenarios:</p> <pre><code>book = db.get(Book, 1)\n\n# First access: Queries database\nauthor1 = book.author\n\n# Second access: Returns cached object (no query)\nauthor2 = book.author\n\n# Same instance\nassert author1 is author2\n</code></pre> <p>When caching helps:</p> <ul> <li>Multiple accesses to the same FK field on one instance</li> <li>Complex business logic that repeatedly checks relationships</li> </ul> <p>When caching doesn't help:</p> <ul> <li>One-time access patterns</li> <li>Different instances with the same FK value (each caches separately)</li> </ul>"},{"location":"guide/foreign-keys/#memory-considerations","title":"Memory Considerations","text":"<p>Explicit FK:</p> <ul> <li>Uses only primitive types (integers)</li> <li>No extra memory per instance</li> </ul> <p>ORM FK:</p> <ul> <li>Each FK field adds a <code>LazyLoader</code> proxy (~200 bytes)</li> <li>Each cached object adds the full object (~1KB typical model)</li> <li>For 1000 Book instances, expect ~1.2MB overhead (LazyLoader + cached authors)</li> </ul> <p>Recommendation: Memory overhead is negligible for typical applications. Only consider this for applications managing tens of thousands of objects in memory simultaneously.</p>"},{"location":"guide/foreign-keys/#choosing-based-on-performance","title":"Choosing Based on Performance","text":"Scenario Recommendation Reason CLI tools Either Performance difference is negligible Web APIs (read-heavy) ORM FK Convenience worth minimal overhead Web APIs (write-heavy) Either Both approaches have same write performance Batch processing (large collections) Explicit FK More control over when queries execute Interactive applications ORM FK Lazy loading feels more responsive High-traffic services Either Bottleneck is usually DB I/O, not FK overhead Memory-constrained Explicit FK Avoid caching overhead"},{"location":"guide/foreign-keys/#performance-best-practices","title":"Performance Best Practices","text":"<p>For both approaches:</p> <ol> <li>Use indexes - Foreign key columns are automatically indexed</li> <li>Avoid N+1 - Restructure queries to minimize relationship traversal</li> <li>Batch operations - Use transactions for multiple inserts/updates</li> <li>Profile first - Measure before optimizing</li> </ol> <p>For ORM FK specifically:</p> <ol> <li>Use reverse relationships - More efficient than iterating forward</li> <li>Cache locally - Store frequently accessed data in variables</li> <li>Know when lazy loading happens - Be aware of query timing</li> </ol> <p>Tip</p> <p>In practice, the performance difference between Explicit and ORM FK is rarely the bottleneck. Database I/O, network latency, and query structure have much larger impacts. Choose based on code maintainability and development speed rather than premature optimization.</p>"},{"location":"guide/foreign-keys/#common-features","title":"Common Features","text":"<p>Both approaches share these features:</p> <ul> <li>Database constraints: Proper foreign key constraints in SQLite</li> <li>Referential integrity: Ensures referenced records exist</li> <li>Foreign key actions: CASCADE, SET NULL, RESTRICT, NO ACTION</li> <li>Nullable foreign keys: Optional relationships with <code>null=True</code></li> <li>One-to-one relationships: Use <code>unique=True</code></li> <li>Automatic indexing: Indexes created on FK columns</li> <li>Same database: Both work with the same SQLite database</li> </ul>"},{"location":"guide/foreign-keys/#mixing-approaches","title":"Mixing Approaches","text":"<p>You can use both approaches in the same project. Models from <code>sqliter.model</code> and <code>sqliter.orm</code> can coexist and reference each other. However, ORM features (lazy loading, reverse relationships) only work with models that inherit from <code>sqliter.orm.BaseDBModel</code>.</p>"},{"location":"guide/guide/","title":"SQLiter Overview","text":"<p>SQLiter is a lightweight Python library designed to simplify database operations using Pydantic models. It provides a range of functionality including table creation, CRUD operations, querying, filtering, and more. This overview briefly introduces each feature.</p>"},{"location":"guide/guide/#basic-setup","title":"Basic Setup","text":"<p>To get started, import the necessary modules and define a Pydantic model for your table:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n</code></pre>"},{"location":"guide/guide/#table-creation","title":"Table Creation","text":"<p>SQLiter allows you to create tables automatically based on your models:</p> <pre><code>db.create_table(User)\n</code></pre> <p>This creates a table for the <code>User</code> model, with fields based on the attributes of the model.</p>"},{"location":"guide/guide/#inserting-records","title":"Inserting Records","text":"<p>Inserting records is straightforward with SQLiter:</p> <pre><code>user = User(name=\"John Doe\", age=30, email=\"john@example.com\")\nnew_record = db.insert(user)\n</code></pre> <p>If successful, <code>new_record</code> will contain a model the same as was passed to it, but including the newly-created primary key value.</p>"},{"location":"guide/guide/#basic-queries","title":"Basic Queries","text":"<p>You can easily query all records from a table:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre>"},{"location":"guide/guide/#filtering-results","title":"Filtering Results","text":"<p>SQLiter allows filtering of results using various conditions:</p> <pre><code>young_users = db.select(User).filter(age__lt=30).fetch_all()\n</code></pre>"},{"location":"guide/guide/#fetching-records","title":"Fetching Records","text":"<p>SQLiter provides methods to fetch multiple, single, or the last record in a table.</p>"},{"location":"guide/guide/#fetching-all-records","title":"Fetching All Records","text":"<p>The <code>fetch_all()</code> method retrieves all records from the table that match the query or filter:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre> <p>This returns a list of all matching records. If no record matches, an empty list is returned.</p>"},{"location":"guide/guide/#fetching-one-record","title":"Fetching One Record","text":"<p>The <code>fetch_one()</code> method retrieves a single record that matches the query or filter:</p> <pre><code>result = db.select(User).filter(name=\"John Doe\").fetch_one()\n</code></pre> <p>If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#fetching-the-last-record","title":"Fetching the Last Record","text":"<p>The <code>fetch_last()</code> method retrieves the last record in the table, typically based on the <code>rowid</code>:</p> <pre><code>last_user = db.select(User).fetch_last()\n</code></pre> <p>This fetches the most recently inserted record. If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#updating-records","title":"Updating Records","text":"<p>Records can be updated seamlessly. Simply modify the fields of the model instance and pass that to the <code>update()</code> method:</p> <pre><code>user.age = 31\ndb.update(user)\n</code></pre>"},{"location":"guide/guide/#deleting-records","title":"Deleting Records","text":"<p>SQLiter provides two ways to delete records:</p>"},{"location":"guide/guide/#single-record-deletion","title":"Single Record Deletion","text":"<p>To delete a single record by its primary key:</p> <pre><code>db.delete(User, 1)\n</code></pre> <p>Important</p> <p>The single record deletion method will raise:</p> <ul> <li><code>RecordNotFoundError</code> if the record with the specified primary key is not found</li> <li><code>RecordDeletionError</code> if there's an error during the deletion process</li> </ul> <p>Note</p> <p>You can get the primary key value from the record or model instance itself, e.g., <code>new_record.pk</code> and pass that as the second argument to the <code>delete()</code> method:</p> <pre><code>db.delete(User, new_record.pk)\n</code></pre>"},{"location":"guide/guide/#query-based-deletion","title":"Query-Based Deletion","text":"<p>You can also delete multiple records that match specific criteria using a query. The <code>delete()</code> method will delete all records that match the query and return the number of records deleted:</p> <pre><code># Delete all users over 30\ndeleted_count = db.select(User).filter(age__gt=30).delete()\n\n# Delete inactive users in a specific age range\ndeleted_count = db.select(User).filter(\n    age__gte=25,\n    age__lt=40,\n    status=\"inactive\"\n).delete()\n</code></pre> <p>Note</p> <p>The query-based delete operation ignores any <code>limit()</code>, <code>offset()</code>, or <code>order()</code> clauses that might be in the query chain. It will always delete ALL records that match the filter conditions.</p>"},{"location":"guide/guide/#advanced-query-features","title":"Advanced Query Features","text":""},{"location":"guide/guide/#ordering","title":"Ordering","text":"<p>SQLiter supports ordering of results by specific fields:</p> <pre><code>ordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre>"},{"location":"guide/guide/#limiting-and-offsetting","title":"Limiting and Offsetting","text":"<p>Pagination is supported through <code>limit()</code> and <code>offset()</code>:</p> <pre><code>paginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre>"},{"location":"guide/guide/#transactions","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager. This ensures that a group of operations are executed atomically, meaning either all of the operations succeed or none of them are applied.</p> <p>To use transactions, simply wrap the operations within a <code>with</code> block:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs here, both inserts will be rolled back\n</code></pre> <p>If an error occurs within the transaction block, all changes made inside the block will be rolled back automatically.</p> <p>If no errors occur, the transaction will commit and changes will be saved. The <code>close()</code> method will also be called when the context manager exits, so there is no need to call it manually.</p>"},{"location":"guide/guide/#closing-the-database","title":"Closing the Database","text":"<p>Always remember to close the connection when you're done:</p> <pre><code>db.close()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see above), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p> <p>This is a quick look at the core features of SQLiter. For more details on each functionality, see the next section.</p>"},{"location":"guide/many-to-many/","title":"Many-to-Many Relationships","text":"<p>SQLiter supports many-to-many (M2M) relationships in ORM mode using the <code>ManyToMany</code> descriptor. M2M relationships are backed by a junction table that SQLiter creates automatically.</p> <pre><code>from sqliter.orm import BaseDBModel, ManyToMany\n\nclass Tag(BaseDBModel):\n    name: str\n\nclass Article(BaseDBModel):\n    title: str\n    tags: ManyToMany[Tag] = ManyToMany(Tag)\n</code></pre> <p>You can also use a string forward reference for <code>to_model</code> when the target model is defined later. The relationship resolves when the target model is registered.</p> <pre><code>class Article(BaseDBModel):\n    title: str\n    tags: ManyToMany[\"Tag\"] = ManyToMany(\"Tag\")\n</code></pre>"},{"location":"guide/many-to-many/#creating-and-querying-relationships","title":"Creating and Querying Relationships","text":"<p>M2M access returns a <code>ManyToManyManager</code> that provides a small API:</p> <pre><code>article = db.insert(Article(title=\"Guide\"))\ntag = db.insert(Tag(name=\"python\"))\n\narticle.tags.add(tag)\narticle.tags.remove(tag)\narticle.tags.clear()\narticle.tags.set(tag)\n\ntags = article.tags.fetch_all()\ntag = article.tags.fetch_one()\ncount = article.tags.count()\nexists = article.tags.exists()\n</code></pre> <p><code>filter()</code> returns a <code>QueryBuilder</code> limited to related objects:</p> <pre><code>results = article.tags.filter(name=\"python\").fetch_all()\n</code></pre>"},{"location":"guide/many-to-many/#reverse-accessors","title":"Reverse Accessors","text":"<p>SQLiter adds a reverse accessor to the target model (unless suppressed). The name is auto-generated from the source model name or can be explicitly set with <code>related_name</code>.</p> <pre><code>class Article(BaseDBModel):\n    title: str\n    tags: ManyToMany[Tag] = ManyToMany(Tag, related_name=\"articles\")\n\ntag = db.insert(Tag(name=\"python\"))\narticles = tag.articles.fetch_all()\n</code></pre> <p>Type checkers and reverse accessors</p> <p>Reverse accessors are injected dynamically at runtime, so tools like mypy cannot infer their type automatically. If you want strict typing, use <code>cast()</code> at the call site:</p> <pre><code>from typing import Any, cast\n\narticles = cast(\"Any\", tag.articles).fetch_all()\n</code></pre>"},{"location":"guide/many-to-many/#custom-junction-table-name","title":"Custom Junction Table Name","text":"<p>Use <code>through</code> to control the junction table name:</p> <pre><code>class Post(BaseDBModel):\n    body: str\n    categories: ManyToMany[Category] = ManyToMany(\n        Category, through=\"post_category_links\"\n    )\n</code></pre>"},{"location":"guide/many-to-many/#self-referential-symmetry","title":"Self-Referential Symmetry","text":"<p>For self-referential relationships (e.g., friends), use <code>symmetrical=True</code>. SQLiter stores a single row per pair and returns the relationship from either side. No reverse accessor is created for symmetrical self-references.</p> <pre><code>class User(BaseDBModel):\n    name: str\n    friends: ManyToMany[User] = ManyToMany(\"User\", symmetrical=True)\n\nalice = db.insert(User(name=\"Alice\"))\nbob = db.insert(User(name=\"Bob\"))\n\nalice.friends.add(bob)\nassert {u.name for u in bob.friends.fetch_all()} == {\"Alice\"}\n</code></pre>"},{"location":"guide/many-to-many/#eager-loading-with-prefetch_related","title":"Eager Loading with prefetch_related()","text":"<p>When iterating over a queryset and accessing M2M relationships on each instance, you can hit the N+1 query problem. <code>prefetch_related()</code> solves this by fetching all related objects in a single extra query:</p> <pre><code># Without prefetch: 1 query for articles + N queries for tags\narticles = db.select(Article).fetch_all()\nfor article in articles:\n    tags = article.tags.fetch_all()  # hits the DB each time\n\n# With prefetch: 1 query for articles + 1 query for tags (2 total)\narticles = db.select(Article).prefetch_related(\"tags\").fetch_all()\nfor article in articles:\n    tags = article.tags.fetch_all()  # served from cache\n</code></pre>"},{"location":"guide/many-to-many/#forward-and-reverse-m2m","title":"Forward and Reverse M2M","text":"<p><code>prefetch_related()</code> works for both the forward side (where <code>ManyToMany</code> is defined) and the reverse side:</p> <pre><code># Forward: articles with their tags\narticles = db.select(Article).prefetch_related(\"tags\").fetch_all()\n\n# Reverse: tags with their articles\ntags = db.select(Tag).prefetch_related(\"articles\").fetch_all()\nfor tag in tags:\n    print(f\"{tag.name}: {tag.articles.count()} articles\")\n</code></pre>"},{"location":"guide/many-to-many/#symmetrical-self-referential-m2m","title":"Symmetrical Self-Referential M2M","text":"<p><code>prefetch_related()</code> handles symmetrical self-referential M2M correctly. Both directions of the relationship are resolved:</p> <pre><code>people = db.select(User).prefetch_related(\"friends\").fetch_all()\nfor person in people:\n    print(f\"{person.name}: {person.friends.count()} friends\")\n</code></pre>"},{"location":"guide/many-to-many/#prefetched-m2m-data-api","title":"Prefetched M2M Data API","text":"<p>Accessing a prefetched M2M relationship returns a <code>PrefetchedM2MResult</code> that provides the same read interface as <code>ManyToManyManager</code>:</p> <pre><code>article.tags.fetch_all()   # list of Tag instances\narticle.tags.fetch_one()   # first Tag or None\narticle.tags.count()       # number of tags\narticle.tags.exists()      # True if any tags exist\n</code></pre> <p>Write operations (<code>add</code>, <code>remove</code>, <code>clear</code>, <code>set</code>) are delegated to the real <code>ManyToManyManager</code>, so they work exactly as expected:</p> <pre><code>articles = db.select(Article).prefetch_related(\"tags\").fetch_all()\nguide = articles[0]\n\n# Write operations still work through the prefetched wrapper\nnew_tag = db.insert(Tag(name=\"new\"))\nguide.tags.add(new_tag)\nguide.tags.remove(new_tag)\n</code></pre> <p>Calling <code>filter()</code> on a prefetched M2M relationship falls back to a real database query.</p> <p>Tip</p> <p>For reverse FK relationships (e.g., <code>author.books</code>), <code>prefetch_related()</code> works the same way. See ORM Foreign Keys for details.</p>"},{"location":"guide/many-to-many/#notes","title":"Notes","text":"<ul> <li>M2M operations require a <code>db_context</code>, which is set when instances are   returned from <code>SqliterDB</code> methods like <code>insert()</code> and <code>get()</code>.</li> <li>Junction tables include <code>CASCADE</code> FK constraints, a unique pair   constraint, and indexes on both FK columns.</li> </ul>"},{"location":"guide/models/","title":"Models","text":"<p>Each individual table in your database should be represented by a model. This model should inherit from <code>BaseDBModel</code> and define the fields that should be stored in the table. Under the hood, the model is a Pydantic model, so you can use all the features of Pydantic models, such as default values, type hints, and validation.</p>"},{"location":"guide/models/#defining-models","title":"Defining Models","text":"<p>Models are defined like this:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n</code></pre> <p>You can create as many Models as you need, each representing a different table in your database. The fields in the model will be used to create the columns in the table.</p> <p>Important</p> <ul> <li>Type-hints are REQUIRED for each field in the model.</li> <li>Define models at module scope (ideally in their own module) for clarity and reliable type-hint resolution.</li> <li>The Model automatically creates an auto-incrementing integer primary key for each table called <code>pk</code>, you do not need to define it yourself.</li> <li>The Model automatically creates a <code>created_at</code> and <code>updated_at</code> field which is an integer Unix timestamp IN UTC when the record was created or last updated. You can convert this timestamp to any format and timezone that you need.</li> </ul>"},{"location":"guide/models/#field-types","title":"Field Types","text":"<p>The following field types are currently supported:</p> <p>Basic Types:</p> <ul> <li><code>str</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>bool</code></li> <li><code>date</code></li> <li><code>datetime</code></li> <li><code>bytes</code></li> </ul> <p>Complex Types:</p> <ul> <li><code>list[T]</code> - Lists of any type T</li> <li><code>dict[K, V]</code> - Dictionaries with keys of type K and values of type V</li> <li><code>set[T]</code> - Sets of any type T</li> <li><code>tuple[T, ...]</code> - Tuples of any type T</li> </ul> <p>Complex types are automatically serialized and stored as BLOBs in the database. For more details on using complex types, see the Fields Guide.</p>"},{"location":"guide/models/#foreign-key-fields","title":"Foreign Key Fields","text":"<p>Foreign keys allow you to define relationships between models, enabling referential integrity in your database. See the Foreign Keys Guide for detailed information on defining and using foreign key relationships.</p>"},{"location":"guide/models/#table-configuration","title":"Table Configuration","text":"<p>You can add indexes to your table by specifying the <code>indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        indexes = [\"name\", \"email\"]\n</code></pre> <p>This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p>"},{"location":"guide/models/#adding-unique-indexes","title":"Adding Unique Indexes","text":"<p>You can add unique indexes to your table by specifying the <code>unique_indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        unique_indexes = [\"email\"]\n</code></pre> <p>These will ensure that all values in this field are unique. This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p> <p>Tip</p> <p>You can specify both <code>indexes</code> and <code>unique_indexes</code> in the <code>Meta</code> class if you need to.</p>"},{"location":"guide/models/#unique-fields","title":"Unique Fields","text":"<p>Caution</p> <p>In version 0.9.1 and below, this flag was <code>Unique()</code> with a capital 'U'. This has now been deprecated and the current <code>unique()</code> with a lower case 'u' is the supported command.</p> <p>The old functionality still works but will raise a deprecation warning and will probably be removed in future versions.</p> <p>You can also specify that a field should be all unique values by using the <code>unique()</code> method from the <code>sqliter.model</code> module. This will ensure that all values in this field are unique.</p> <pre><code>from typing import Annotated\nfrom sqliter.model import BaseDBModel, unique\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: Annotated[str, unique()]\n</code></pre> <p>This will raise either a <code>RecordInsertionError</code> or <code>RecordUpdateError</code> if you try to insert or update a record with a duplicate value in the chosen field.</p> <p>Tip</p> <p>Using <code>Annotated</code> is optional, but without it your code wil not pass type-checking with <code>mypy</code>. It will work fine at runtime but is not recommended:</p> <pre><code>email: str = unique()\n</code></pre> <p>This will give the following Mypy error:</p> <pre><code>error: Incompatible types in assignment (expression has type \"unique\", variable has type \"str\")  [assignment]\n</code></pre> <p>If you DONT use a static type checker (<code>mypy</code>, <code>ty</code> or similar) then you can leave off the <code>Annotated</code>.</p>"},{"location":"guide/models/#custom-table-name","title":"Custom Table Name","text":"<p>By default, the table name will be the same as the model name, converted to 'snake_case' and pluralized (e.g., <code>User</code> -&gt; <code>users</code>). Also, any 'Model' suffix will be removed (e.g., <code>UserModel</code> -&gt; <code>users</code>). To override this behavior, you can specify the <code>table_name</code> in the <code>Meta</code> class manually as below:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        table_name = \"people\"\n</code></pre> <p>Note</p> <p>By default, pluralization adds a simple \"s\" suffix (unless the name already ends in \"s\"). For grammatically correct pluralization of irregular words like \"person\" \u2192 \"people\" or \"category\" \u2192 \"categories\", install the <code>extras</code> package as mentioned in the installation. Of course, you can always specify the <code>table_name</code> manually.</p>"},{"location":"guide/models/#model-classmethods","title":"Model Classmethods","text":"<p>There are 2 useful methods you can call on your models. Note that they are Class Methods so should be called on the Model class itself, not an instance of the model:</p>"},{"location":"guide/models/#get_table_name","title":"<code>get_table_name()</code>","text":"<p>This method returns the actual table name for the model either specified or automatically generated. This is useful if you need to do any raw SQL queries.</p> <pre><code>table_name = User.get_table_name()\n</code></pre>"},{"location":"guide/models/#get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>This simply returns the name of the primary key for that table. At the moment, this will always return the string <code>pk</code> but this may change in the future.</p> <pre><code>primary_key = User.get_primary_key()\n</code></pre>"},{"location":"guide/ordering/","title":"Ordering","text":"<p>For now we only support ordering by the single field. You can specify the field to order by and whether to reverse the order:</p> <pre><code>results = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre> <p>This will order the results by the <code>age</code> field in descending order.</p> <p>If you do not specify a field, the default is to order by the primary key field:</p> <pre><code>results = db.select(User).order().fetch_all()\n</code></pre> <p>This will order the results by the primary key field in ascending order.</p> <p>Warning</p> <p>Previously ordering was done using the <code>direction</code> parameter with <code>asc</code> or <code>desc</code>, but this has been deprecated in favor of using the <code>reverse</code> parameter. The <code>direction</code> parameter still works, but will raise a <code>DeprecationWarning</code> and will be removed in a future release.</p>"},{"location":"guide/properties/","title":"SqliterDB Properties","text":""},{"location":"guide/properties/#overview","title":"Overview","text":"<p>The <code>SqliterDB</code> class includes several useful read-only properties that provide insight into the current state of the database. These properties allow users to easily query key database attributes, such as the filename, whether the database is in memory, auto-commit status, and the list of tables.</p>"},{"location":"guide/properties/#properties","title":"Properties","text":"<ol> <li> <p><code>filename</code>    Returns the filename of the database, or <code>None</code> if the database is in-memory.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(db_filename=\"test.db\")\nprint(db.filename)  # Output: 'test.db'\n</code></pre> </li> <li> <p><code>is_memory</code>    Returns <code>True</code> if the database is in-memory, otherwise <code>False</code>.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(memory=True)\nprint(db.is_memory)  # Output: True\n</code></pre> </li> <li> <p><code>is_autocommit</code>    Returns <code>True</code> if the database is in auto-commit mode, otherwise <code>False</code>.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(auto_commit=True)\nprint(db.is_autocommit)  # Output: True\n</code></pre> </li> <li> <p><code>table_names</code>    Returns a list of all user-defined table names in the database. The property temporarily reconnects if the connection is closed.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(memory=True)\ndb.create_table(User)  # Assume 'User' is a predefined model\nprint(db.table_names)  # Output: ['user']\n</code></pre> </li> </ol>"},{"location":"guide/properties/#property-details","title":"Property Details","text":""},{"location":"guide/properties/#filename","title":"<code>filename</code>","text":"<p>This property allows users to retrieve the current database filename. For in-memory databases, this property returns <code>None</code>, as no filename is associated with an in-memory database.</p> <ul> <li>Type: <code>Optional[str]</code></li> <li>Returns: The database filename or <code>None</code> if in memory.</li> </ul>"},{"location":"guide/properties/#is_memory","title":"<code>is_memory</code>","text":"<p>This property indicates whether the database is in memory. It simplifies the check for memory-based databases, returning <code>True</code> for in-memory and <code>False</code> otherwise.</p> <ul> <li>Type: <code>bool</code></li> <li>Returns: <code>True</code> if the database is in memory, otherwise <code>False</code>.</li> </ul>"},{"location":"guide/properties/#is_autocommit","title":"<code>is_autocommit</code>","text":"<p>This property returns whether the database is in auto-commit mode. If <code>auto_commit</code> is enabled, every operation is automatically committed without requiring an explicit <code>commit()</code> call.</p> <ul> <li>Type: <code>bool</code></li> <li>Returns: <code>True</code> if auto-commit mode is enabled, otherwise <code>False</code>.</li> </ul>"},{"location":"guide/properties/#table_names","title":"<code>table_names</code>","text":"<p>This property retrieves a list of user-defined table names from the database. It does not include system tables (<code>sqlite_</code>). If the database connection is closed, this property will temporarily reconnect to query the table names and close the connection afterward.</p> <ul> <li>Type: <code>list[str]</code></li> <li>Returns: A list of user-defined table names in the database.</li> <li>Raises: <code>DatabaseConnectionError</code> if the database connection fails to re-establish.</li> </ul>"},{"location":"guide/properties/#example","title":"Example","text":"<p>Here's a complete example demonstrating the use of the new properties:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\n# Define a simple model\nclass User(BaseDBModel):\n    id: int\n    name: str\n\n# Create an in-memory database\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\n# Access properties\nprint(db.filename)        # Output: None\nprint(db.is_memory)       # Output: True\nprint(db.is_autocommit)   # Output: True (this is the default)\nprint(db.table_names)     # Output: ['user']\n</code></pre>"},{"location":"guide/tables/","title":"Table Operations","text":"<p>All table operations work on a Pydantic Model you have defined based on <code>BaseDBModel</code>. You can have as many tables as you need, but each must have it's own Model defined.</p>"},{"location":"guide/tables/#creating-tables","title":"Creating Tables","text":"<p>To create a table, you simply pass your Model class to the <code>create_table()</code> method:</p> <pre><code>db.create_table(User)\n</code></pre> <p>Important</p> <p>The Table is created regardless of the <code>auto_commit</code> setting.</p> <p>By default, if the table already exists, it will not be created again and no error will be raised. If you want to raise an exception if the table already exists, you can set <code>exists_ok=False</code>:</p> <pre><code>db.create_table(User, exists_ok=False)\n</code></pre> <p>This will raise a <code>TableCreationError</code> if the table already exists.</p> <p>There is a complementary flag <code>force=True</code> which will drop the table if it exists and then recreate it. This may be useful if you are changing the table structure:</p> <pre><code>db.create_table(User, force=True)\n</code></pre> <p>This defaults to <code>False</code>.</p>"},{"location":"guide/tables/#dropping-tables","title":"Dropping Tables","text":"<p>To drop a table completely from the database use the <code>drop_table</code> method</p> <pre><code>db.drop_table(User)\n</code></pre> <p>Caution</p> <p>This is non-reversible and will you will lose all data in that table.</p> <p>The Table is dropped regardless of the <code>auto_commit</code> setting.</p>"},{"location":"guide/transactions/","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs, the transaction will be rolled back\n</code></pre> <p>Using the context manager will automatically commit the transaction at the end (unless an exception occurs), regardless of the <code>auto_commit</code> setting. If an exception occurs, all changes made within the transaction block are rolled back. The <code>close()</code> method will also be called when the context manager exits, so you do not need to call it manually.</p>"},{"location":"guide/foreign-keys/explicit/","title":"Explicit Foreign Keys","text":"<p>This page covers the explicit foreign key approach where you define <code>_id</code> fields directly and manage relationships manually. This is the simpler, lower-overhead approach with full control over foreign key values.</p> <p>For the ORM-style approach with lazy loading and reverse relationships, see ORM Foreign Keys.</p>"},{"location":"guide/foreign-keys/explicit/#defining-foreign-keys","title":"Defining Foreign Keys","text":"<p>To define a foreign key, use the <code>ForeignKey()</code> function when declaring a model field. The foreign key field stores the primary key (<code>pk</code>) of the referenced model:</p> <pre><code>from typing import Annotated\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n</code></pre> <p>Important</p> <p>The referenced table (<code>Author</code>) must be created before the table that references it (<code>Book</code>).</p> <p>Note</p> <p>The default foreign key action is <code>RESTRICT</code> for both <code>on_delete</code> and <code>on_update</code>. This means that by default, SQLiter will prevent deletion or updates of referenced records if other records reference them. This is the safest behavior and matches SQLite's default. You must explicitly specify <code>on_delete=\"CASCADE\"</code> or <code>on_update=\"CASCADE\"</code> if you want cascading behavior.</p>"},{"location":"guide/foreign-keys/explicit/#foreign-key-naming-convention","title":"Foreign Key Naming Convention","text":"<p>By default, the foreign key column in the database will be named <code>{field_name}_id</code>. In the example above, the field <code>author_id</code> creates a column named <code>author_id</code> in the <code>books</code> table.</p> <p>You can customize the column name using the <code>db_column</code> parameter:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        db_column=\"writer_id\",\n        on_delete=\"CASCADE\"\n    )\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#type-checking","title":"Type Checking","text":"<p>The examples in this documentation show the simplest syntax that works at runtime and with most type checkers:</p> <pre><code>author_id: int = ForeignKey(\n    Author,\n    on_delete=\"CASCADE\",\n    on_update=\"CASCADE\"\n)\nauthor_id: int | None = ForeignKey(\n    Author, on_delete=\"SET NULL\", null=True, default=None\n)\n</code></pre> <p>If you use strict type checking with <code>mypy</code>, you can wrap the type and <code>ForeignKey()</code> with <code>Annotated</code> for explicit type metadata:</p> <pre><code>from typing import Annotated\n\nauthor_id: Annotated[\n    int,\n    ForeignKey(Author, on_delete=\"CASCADE\", on_update=\"CASCADE\")\n]\nauthor_id: Annotated[\n    int | None,\n    ForeignKey(Author, on_delete=\"SET NULL\", null=True)\n] = None\n</code></pre> <p>This is optional for foreign keys but required for the <code>unique()</code> constraint (see Models).</p>"},{"location":"guide/foreign-keys/explicit/#foreign-key-actions","title":"Foreign Key Actions","text":"<p>Foreign keys support actions that define what happens when the referenced record is deleted (<code>on_delete</code>) or updated (<code>on_update</code>). The following actions are available:</p>"},{"location":"guide/foreign-keys/explicit/#cascade","title":"CASCADE","text":"<p>When the referenced record is deleted, all records that reference it are also deleted. When the referenced record's primary key is updated, the foreign key values are updated to match. You must explicitly specify <code>on_delete=\"CASCADE\"</code> and <code>on_update=\"CASCADE\"</code> to use this behavior:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\nauthor = db.insert(Author(name=\"Jane Austen\", email=\"jane@example.com\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author_id=author.pk))\n\n# Deleting the author will also delete the book\ndb.delete(Author, author.pk)\n\n# The book is now deleted too\nbooks = db.select(Book).filter(author_id=author.pk).fetch_all()\nassert len(books) == 0\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#set-null","title":"SET NULL","text":"<p>When the referenced record is deleted or updated, the foreign key field is set to <code>NULL</code>. This requires <code>null=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int | None = ForeignKey(\n        Author, on_delete=\"SET NULL\", null=True, default=None\n    )\n</code></pre> <p>Important</p> <p>You must set <code>null=True</code> when using <code>SET NULL</code>. SQLiter will raise a <code>ValueError</code> if you try to use <code>SET NULL</code> without <code>null=True</code>.</p>"},{"location":"guide/foreign-keys/explicit/#restrict","title":"RESTRICT","text":"<p>Prevents deletion or update of the referenced record if other records reference it. This is the default behavior in SQLiter and matches SQLite's default when foreign keys are enabled:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"RESTRICT\")\n\nauthor = db.insert(Author(name=\"Jane Austen\", email=\"jane@example.com\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author_id=author.pk))\n\n# This will raise a ForeignKeyConstraintError\ndb.delete(Author, author.pk)\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#no-action","title":"NO ACTION","text":"<p>Similar to <code>RESTRICT</code> in SQLite. The deletion or update is prevented if other records reference the record:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"NO ACTION\")\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#nullable-foreign-keys","title":"Nullable Foreign Keys","text":"<p>By default, foreign key fields are required (NOT NULL). You can make them optional by setting <code>null=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int | None = ForeignKey(\n        Author, on_delete=\"SET NULL\", null=True, default=None\n    )\n\n# Insert a book without an author\nbook = db.insert(Book(title=\"Anonymous Book\", author_id=None))\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#one-to-one-relationships","title":"One-to-One Relationships","text":"<p>To create a one-to-one relationship, use <code>unique=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, unique=True)\n</code></pre> <p>This ensures that each author can be referenced by only one book.</p>"},{"location":"guide/foreign-keys/explicit/#querying-with-foreign-keys","title":"Querying with Foreign Keys","text":"<p>You can filter records using the foreign key column:</p> <pre><code># Get all books by a specific author\nbooks = db.select(Book).filter(author_id=author.pk).fetch_all()\n\n# Get all books without an author\norphaned_books = db.select(Book).filter(author_id=None).fetch_all()\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#automatic-indexing","title":"Automatic Indexing","text":"<p>SQLiter automatically creates an index on foreign key columns to improve query performance. This is done when you create the table:</p> <pre><code>db.create_table(Book)  # Automatically creates index on author_id\n</code></pre>"},{"location":"guide/foreign-keys/explicit/#foreign-key-errors","title":"Foreign Key Errors","text":"<p>SQLiter provides specific exceptions for foreign key constraint violations:</p> <ul> <li><code>ForeignKeyConstraintError</code>: Raised when a foreign key constraint is violated,   such as trying to delete a record that is referenced by other records with   <code>RESTRICT</code> or <code>NO ACTION</code> action.</li> <li><code>InvalidForeignKeyError</code>: Raised when an invalid foreign key configuration is   detected, such as using <code>SET NULL</code> without <code>null=True</code>.</li> </ul>"},{"location":"guide/foreign-keys/explicit/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing foreign key usage with CASCADE deletion:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\n# Create database and tables\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert an author\nauthor = db.insert(Author(\n    name=\"Jane Austen\",\n    email=\"jane@example.com\"\n))\n\n# Insert books by this author\nbook1 = db.insert(Book(\n    title=\"Pride and Prejudice\",\n    author_id=author.pk\n))\nbook2 = db.insert(Book(\n    title=\"Sense and Sensibility\",\n    author_id=author.pk\n))\n\n# Query books by author\njane_books = db.select(Book).filter(author_id=author.pk).fetch_all()\nprint(f\"Jane has {len(jane_books)} books\")\n\n# Delete the author (CASCADE will delete the books)\ndb.delete(Author, author.pk)\n\n# Verify books are deleted\nremaining_books = db.select(Book).fetch_all()\nassert len(remaining_books) == 0\n</code></pre>"},{"location":"guide/foreign-keys/orm/","title":"ORM Foreign Keys","text":"<p>ORM-style foreign keys provide lazy loading and reverse relationships, similar to Django or SQLAlchemy. This approach allows you to access related objects directly (e.g., <code>book.author.name</code>) without manual queries.</p> <p>For the simpler explicit approach with manual ID management, see Explicit Foreign Keys.</p>"},{"location":"guide/foreign-keys/orm/#defining-orm-foreign-keys","title":"Defining ORM Foreign Keys","text":"<p>Import from <code>sqliter.orm</code> instead of <code>sqliter.model</code>:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n</code></pre> <p>Note</p> <p>When using ORM foreign keys, SQLiter automatically creates an <code>author_id</code> field in the database. You define <code>author</code> (without <code>_id</code>) in your model and access it for lazy loading.</p>"},{"location":"guide/foreign-keys/orm/#database-context","title":"Database Context","text":"<p>ORM features require a database context to execute queries. SQLiter automatically sets <code>db_context</code> on model instances returned from database operations:</p> <pre><code># db_context is set automatically\nbook = db.get(Book, 1)\nprint(book.author.name)  # Works - db_context was set by db.get()\n\n# Manual instances need db_context set explicitly\nbook = Book(title=\"My Book\", author_id=1)\nbook.db_context = db  # Set manually for lazy loading to work\nprint(book.author.name)\n</code></pre>"},{"location":"guide/foreign-keys/orm/#lazy-loading","title":"Lazy Loading","text":"<p>When you access a foreign key field, SQLiter automatically loads the related object from the database:</p> <pre><code># Insert data\nauthor = db.insert(Author(name=\"Jane Austen\", email=\"jane@example.com\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author=author))\n\n# Fetch the book\nbook = db.get(Book, book.pk)\n\n# Lazy loading - queries database on first access\nprint(book.author.name)  # \"Jane Austen\"\nprint(book.author.email)  # \"jane@example.com\"\n</code></pre> <p>The related object is only loaded when you access an attribute. If you never access <code>book.author</code>, no additional query is made.</p>"},{"location":"guide/foreign-keys/orm/#caching-behavior","title":"Caching Behavior","text":"<p>Once loaded, the related object is cached on the instance. Repeated access returns the same object:</p> <pre><code>book = db.get(Book, 1)\n\n# First access loads from database\nauthor1 = book.author\n# Second access returns cached object (no query)\nauthor2 = book.author\n\n# Same object instance\nassert author1 is author2\n</code></pre>"},{"location":"guide/foreign-keys/orm/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/foreign-keys/orm/#the-n1-query-problem","title":"The N+1 Query Problem","text":"<p>When iterating over multiple objects and accessing their foreign key relationships, you can encounter the N+1 query problem. This happens when you make 1 query to fetch N objects, then N additional queries to fetch each related object:</p> <pre><code># Fetch 100 books (1 query)\nbooks = db.select(Book).fetch_all()\n\n# Accessing author for each book triggers a separate query (100 queries!)\nfor book in books:\n    print(f\"{book.title} by {book.author.name}\")  # \u26a0\ufe0f N+1 problem\n</code></pre> <p>In this example, SQLiter makes 101 database queries total: 1 to fetch all books, then 100 more queries (one per book) to fetch each author.</p>"},{"location":"guide/foreign-keys/orm/#eager-loading-with-select_related","title":"Eager Loading with select_related()","text":"<p>Use <code>select_related()</code> to fetch related objects in a single JOIN query instead of lazy loading:</p> <pre><code># Fetch books with authors in ONE query\nbooks = db.select(Book).select_related(\"author\").fetch_all()\n\n# Access authors without triggering additional queries\nfor book in books:\n    print(f\"{book.title} by {book.author.name}\")  # \u2705 No N+1 problem\n</code></pre> <p>This executes a single JOIN query instead of 101 separate queries (1 for books, 100 for authors).</p>"},{"location":"guide/foreign-keys/orm/#single-level-relationships","title":"Single-Level Relationships","text":"<pre><code># Load single relationship\nbook = db.select(Book).select_related(\"author\").fetch_one()\nprint(book.author.name)  # \"Jane Austen\" - already loaded\n</code></pre>"},{"location":"guide/foreign-keys/orm/#nested-relationships","title":"Nested Relationships","text":"<pre><code>class Comment(BaseDBModel):\n    text: str\n    book: ForeignKey[Book] = ForeignKey(Book, on_delete=\"CASCADE\")\n\ndb.create_table(Comment)\n\n# Load nested relationships using double underscore\ncomment = db.select(Comment).select_related(\"book__author\").fetch_one()\nprint(comment.book.author.name)  # \"Jane\" - already loaded\n</code></pre>"},{"location":"guide/foreign-keys/orm/#multiple-relationships","title":"Multiple Relationships","text":"<pre><code>class Publisher(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n    publisher: ForeignKey[Publisher] = ForeignKey(Publisher, on_delete=\"CASCADE\")\n\n# Load multiple relationships at once\nbook = db.select(Book).select_related(\"author\", \"publisher\").fetch_one()\nprint(f\"{book.title} by {book.author.name} from {book.publisher.name}\")\n</code></pre>"},{"location":"guide/foreign-keys/orm/#eager-loading-reverse-relationships-with-prefetch_related","title":"Eager Loading Reverse Relationships with prefetch_related()","text":"<p><code>select_related()</code> solves the N+1 problem for forward FK relationships (e.g., <code>book.author</code>) using JOINs. For reverse relationships (e.g., <code>author.books</code>), use <code>prefetch_related()</code> instead. It executes a second query to fetch all related objects and maps them back to the parent instances:</p> <pre><code># Fetch authors with all their books prefetched (2 queries total)\nauthors = db.select(Author).prefetch_related(\"books\").fetch_all()\n\nfor author in authors:\n    # No additional query - data is already loaded\n    print(f\"{author.name} wrote {author.books.count()} books\")\n    for book in author.books.fetch_all():\n        print(f\"  - {book.title}\")\n</code></pre> <p>Without <code>prefetch_related()</code>, the loop above would execute 1 + N queries (one per author). With it, only 2 queries run regardless of how many authors exist.</p>"},{"location":"guide/foreign-keys/orm/#multiple-prefetch-paths","title":"Multiple Prefetch Paths","text":"<p>You can prefetch several reverse relationships at once:</p> <pre><code>authors = (\n    db.select(Author)\n    .prefetch_related(\"books\", \"reviews\")\n    .fetch_all()\n)\n\nfor author in authors:\n    print(f\"{author.name}: {author.books.count()} books, \"\n          f\"{author.reviews.count()} reviews\")\n</code></pre>"},{"location":"guide/foreign-keys/orm/#combining-with-select_related","title":"Combining with select_related()","text":"<p><code>prefetch_related()</code> and <code>select_related()</code> can coexist on the same query. Use <code>select_related()</code> for forward FKs and <code>prefetch_related()</code> for reverse FKs:</p> <pre><code>authors = (\n    db.select(Author)\n    .select_related(\"publisher\")     # forward FK - JOIN\n    .prefetch_related(\"books\")       # reverse FK - 2nd query\n    .fetch_all()\n)\n</code></pre>"},{"location":"guide/foreign-keys/orm/#chaining-with-filter-order-and-limit","title":"Chaining with filter, order, and limit","text":"<p><code>prefetch_related()</code> works with all standard query methods:</p> <pre><code>authors = (\n    db.select(Author)\n    .filter(name__startswith=\"J\")\n    .prefetch_related(\"books\")\n    .order(\"name\")\n    .limit(10)\n    .fetch_all()\n)\n</code></pre>"},{"location":"guide/foreign-keys/orm/#prefetched-data-api","title":"Prefetched Data API","text":"<p>Accessing a prefetched reverse relationship returns a <code>PrefetchedResult</code> instead of the usual <code>ReverseQuery</code>. It provides the same read interface:</p> <pre><code>author.books.fetch_all()   # list of Book instances\nauthor.books.fetch_one()   # first Book or None\nauthor.books.count()       # number of books\nauthor.books.exists()      # True if any books exist\n</code></pre> <p>If you call <code>filter()</code> on a prefetched relationship, it falls back to a real database query:</p> <pre><code># Falls back to a DB query with a WHERE clause\nrecent = author.books.filter(year__gt=2000).fetch_all()\n</code></pre> <p>Note</p> <p><code>prefetch_related()</code> only works with reverse FK relationships and M2M relationships. For forward FKs (e.g., <code>book.author</code>), use <code>select_related()</code> instead. Passing a forward FK path raises <code>InvalidPrefetchError</code>.</p> <p>Tip</p> <p><code>prefetch_related()</code> also works with many-to-many relationships. See Many-to-Many for details.</p>"},{"location":"guide/foreign-keys/orm/#relationship-filter-traversal","title":"Relationship Filter Traversal","text":"<p>Filter on related object fields using double underscore (<code>__</code>) syntax:</p> <pre><code># Filter by related field\nbooks = db.select(Book).filter(author__name=\"Jane Austen\").fetch_all()\n\n# Supports all comparison operators\nbooks = db.select(Book).filter(author__name__like=\"Jane%\").fetch_all()\nbooks = db.select(Book).filter(author__name__in=[\"Jane\", \"Charles\"]).fetch_all()\n\n# Works with nested relationships\ncomments = db.select(Comment).filter(book__author__name=\"Charles\").fetch_all()\n</code></pre> <p>This automatically adds the necessary JOINs behind the scenes.</p>"},{"location":"guide/foreign-keys/orm/#combining-with-select_related_1","title":"Combining with select_related()","text":"<p>You can combine eager loading with relationship filters:</p> <pre><code># Load related objects AND filter by them\nresults = (\n    db.select(Book)\n    .select_related(\"author\")\n    .filter(author__name__startswith=\"J\")\n    .fetch_all()\n)\n\nfor book in results:\n    print(f\"{book.title} by {book.author.name}\")  # No additional query\n</code></pre> <p>Note</p> <p><code>select_related()</code> only works with ORM foreign keys (<code>sqliter.orm.ForeignKey</code>). For explicit foreign keys, use manual joins or separate queries.</p> <p>Tip</p> <p>Always use <code>select_related()</code> when you know you'll need related data in a loop. Lazy loading is convenient for single objects or conditional access, but eager loading prevents N+1 queries in most scenarios.</p>"},{"location":"guide/foreign-keys/orm/#null-foreign-keys","title":"Null Foreign Keys","text":"<p>When a foreign key is null, accessing it returns <code>None</code> directly:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Optional[Author]] = ForeignKey(\n        Author, on_delete=\"SET NULL\"\n    )\n\n# Insert book without author\nbook = db.insert(Book(title=\"Anonymous\", author=None))\nbook = db.get(Book, book.pk)\n\n# Returns None for null FK\nprint(book.author)  # None\n</code></pre>"},{"location":"guide/foreign-keys/orm/#auto-detecting-nullable-fks-preferred","title":"Auto-Detecting Nullable FKs (Preferred)","text":"<p>The recommended way to declare a nullable FK is via the type annotation. SQLiter detects <code>Optional[T]</code> and <code>T | None</code> (Python 3.10+) and sets <code>null=True</code> automatically:</p> <pre><code>from typing import Optional\n\n# Preferred \u2014 nullability declared in the type annotation:\nauthor: ForeignKey[Optional[Author]] = ForeignKey(Author, on_delete=\"SET NULL\")\nauthor: ForeignKey[Author | None] = ForeignKey(Author, on_delete=\"SET NULL\")  # 3.10+\n\n# Legacy \u2014 explicit null=True (prefer annotation-driven nullability):\nauthor: ForeignKey[Author] = ForeignKey(Author, on_delete=\"SET NULL\", null=True)\n</code></pre> <p>Note</p> <p>If you pass <code>null=True</code> explicitly, it always takes effect regardless of the annotation.</p> <p>For reliable type-hint resolution, define ORM models at module scope. Models defined inside functions may not resolve annotations when using type aliases (e.g., <code>AuthorRef = Optional[Author]</code>), so prefer <code>null=True</code> in those cases.</p>"},{"location":"guide/foreign-keys/orm/#setting-foreign-key-values","title":"Setting Foreign Key Values","text":"<p>You can set foreign key values using a model instance, an integer ID, or <code>None</code>:</p> <pre><code># Using model instance\nbook.author = author\n\n# Using integer ID\nbook.author = 42\n\n# Setting to null (if allowed)\nbook.author = None\n\n# Any object with a `pk` attribute also works (duck-typed)\nbook.author = some_obj_with_pk\n\n# Example: custom object with pk attribute\nclass AuthorReference:\n    def __init__(self, pk: int):\n        self.pk = pk\n\nbook.author = AuthorReference(pk=42)  # Works!\n</code></pre>"},{"location":"guide/foreign-keys/orm/#reverse-relationships","title":"Reverse Relationships","text":"<p>ORM foreign keys automatically create reverse relationships on the related model. This lets you query all related objects from the other side:</p> <pre><code># Get all books by an author\nauthor = db.get(Author, author.pk)\nbooks = author.books.fetch_all()\n\nfor book in books:\n    print(book.title)\n</code></pre>"},{"location":"guide/foreign-keys/orm/#available-methods","title":"Available Methods","text":"<p>Reverse relationships provide these methods:</p> <pre><code># Fetch all related objects\nbooks = author.books.fetch_all()\n\n# Fetch single related object\nbook = author.books.fetch_one()\n\n# Count related objects\ncount = author.books.count()\n\n# Check if any exist\nhas_books = author.books.exists()\n</code></pre>"},{"location":"guide/foreign-keys/orm/#filtering-reverse-relationships","title":"Filtering Reverse Relationships","text":"<p>You can filter reverse relationships before fetching:</p> <pre><code># Filter by field values\npython_books = author.books.filter(title__like=\"Python%\").fetch_all()\n\n# Multiple filters\nrecent_python = author.books.filter(\n    title__like=\"Python%\",\n    year__ge=2020\n).fetch_all()\n\n# With limit and offset\nfirst_five = author.books.limit(5).fetch_all()\nnext_five = author.books.offset(5).limit(5).fetch_all()\n</code></pre>"},{"location":"guide/foreign-keys/orm/#custom-related-name","title":"Custom Related Name","text":"<p>By default, the reverse relationship is named by pluralizing the model name (e.g., <code>Book</code> becomes <code>books</code>). If the <code>inflect</code> library is installed, it provides grammatically correct pluralization (e.g., <code>Person</code> becomes <code>people</code>, <code>Category</code> becomes <code>categories</code>). Otherwise, a simple \"s\" suffix is added.</p> <p>You can customize this with the <code>related_name</code> parameter:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        related_name=\"publications\"\n    )\n\n# Now use the custom name\nauthor.publications.fetch_all()\n</code></pre>"},{"location":"guide/foreign-keys/orm/#cascade-delete-behavior","title":"Cascade Delete Behavior","text":"<p>With <code>on_delete=\"CASCADE\"</code>, deleting a parent record automatically deletes all related child records:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# Insert author with books\nauthor = db.insert(Author(name=\"Jane\", email=\"jane@example.com\"))\ndb.insert(Book(title=\"Book 1\", author=author))\ndb.insert(Book(title=\"Book 2\", author=author))\n\n# Delete author - books are automatically deleted\ndb.delete(Author, author.pk)\n\n# No books remain\nassert db.select(Book).count() == 0\n</code></pre>"},{"location":"guide/foreign-keys/orm/#foreign-key-actions","title":"Foreign Key Actions","text":"<p>ORM foreign keys support the same actions as explicit foreign keys:</p> Action Behavior <code>CASCADE</code> Delete/update related records <code>SET NULL</code> Set foreign key to NULL (requires nullable FK) <code>RESTRICT</code> Prevent deletion/update if referenced (default) <code>NO ACTION</code> Same as RESTRICT in SQLite <pre><code># CASCADE - delete books when author is deleted\nauthor: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# SET NULL - set author to NULL when deleted\nauthor: ForeignKey[Optional[Author]] = ForeignKey(\n    Author, on_delete=\"SET NULL\"\n)\n\n# RESTRICT - prevent deletion if books exist (default)\nauthor: ForeignKey[Author] = ForeignKey(Author, on_delete=\"RESTRICT\")\n</code></pre>"},{"location":"guide/foreign-keys/orm/#common-issues-and-gotchas","title":"Common Issues and Gotchas","text":""},{"location":"guide/foreign-keys/orm/#database-context-not-set","title":"Database Context Not Set","text":"<p>Lazy loading requires <code>db_context</code> to be set on the model instance. SQLiter automatically sets this for objects returned from database operations, but manually created instances need it set explicitly:</p> <pre><code># \u274c Won't work - no db_context\nbook = Book(title=\"Manual Book\", author_id=1)\nprint(book.author.name)  # AttributeError: 'NoneType' has no attribute 'name'\n\n# \u2705 Works - db_context set manually\nbook = Book(title=\"Manual Book\", author_id=1)\nbook.db_context = db\nprint(book.author.name)  # Now works!\n\n# \u2705 Automatic - db operations set db_context\nbook = db.get(Book, 1)\nprint(book.author.name)  # Works automatically\n</code></pre> <p>When <code>db_context</code> is set automatically:</p> <ul> <li><code>db.insert()</code> - Returns instance with <code>db_context</code> set</li> <li><code>db.get()</code> - Returns instance with <code>db_context</code> set</li> <li><code>db.select().fetch_all()</code> - All instances have <code>db_context</code> set</li> <li><code>db.select().fetch_one()</code> - Instance has <code>db_context</code> set</li> </ul> <p>When you need to set it manually:</p> <ul> <li>Creating instances with <code>Model(...)</code> constructor</li> <li>Deserializing objects from JSON or other sources</li> <li>Using objects in contexts where they weren't retrieved from the database</li> </ul>"},{"location":"guide/foreign-keys/orm/#lazyloader-not-hashable","title":"LazyLoader Not Hashable","text":"<p>Foreign key fields return <code>LazyLoader</code> proxy objects, which are not hashable. This means you cannot use them in sets or as dictionary keys:</p> <pre><code>book = db.get(Book, 1)\n\n# \u274c Won't work - LazyLoader is unhashable\nauthors_set = {book.author}  # TypeError: unhashable type: 'LazyLoader'\n\n# \u274c Won't work - Can't use as dict key\nauthor_map = {book.author: book}  # TypeError: unhashable type: 'LazyLoader'\n\n# \u2705 Works - Access the underlying object's pk\nauthors_set = {book.author.pk}\n\n# \u2705 Works - Store the ID instead\nauthor_map = {book.author_id: book}\n\n# \u2705 Works - Build dict from author objects after loading\nauthors = [book.author for book in books]  # Triggers loading\nauthor_map = {author.pk: author for author in authors}\n</code></pre> <p>Why unhashable? <code>LazyLoader</code> uses mutable equality (based on the cached object), which violates Python's hash/equality contract. Setting <code>__hash__ = None</code> prevents subtle bugs where two \"equal\" objects have different hashes.</p>"},{"location":"guide/foreign-keys/orm/#stale-cache-after-manual-updates","title":"Stale Cache After Manual Updates","text":"<p>If you modify the foreign key ID field directly and then access the relationship, the cache is automatically cleared. However, external database changes won't be reflected:</p> <pre><code>book = db.get(Book, 1)\nauthor_name = book.author.name  # Caches author object\n\n# Another process/connection updates the author record\n# book.author still returns cached (stale) data\n\n# \u2705 To get fresh data, re-fetch the book\nbook = db.get(Book, 1)\nauthor_name = book.author.name  # Fetches latest author data\n</code></pre>"},{"location":"guide/foreign-keys/orm/#foreign-keys-in-filters","title":"Foreign Keys in Filters","text":"<p>When filtering by foreign key relationships, you have several options:</p> <pre><code># \u2705 Works - filter by _id field\nbooks = db.select(Book).filter(author_id=author.pk).fetch_all()\n\n# \u2705 Also works - use the ID directly\nbooks = db.select(Book).filter(author_id=42).fetch_all()\n\n# \u2705 NEW - Filter by related model fields (requires ORM FK)\nbooks = db.select(Book).filter(author__name=\"Jane Austen\").fetch_all()\n</code></pre> <p>The relationship filter traversal (e.g., <code>author__name</code>) only works with <code>sqliter.orm.ForeignKey</code> and automatically joins the related tables.</p>"},{"location":"guide/foreign-keys/orm/#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating ORM foreign keys with lazy loading and reverse relationships:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    year: int\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"CASCADE\")\n\n# Create database and tables\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert an author\nauthor = db.insert(Author(\n    name=\"Jane Austen\",\n    email=\"jane@example.com\"\n))\n\n# Insert books - can use model instance directly\nbook1 = db.insert(Book(\n    title=\"Pride and Prejudice\",\n    year=1813,\n    author=author\n))\nbook2 = db.insert(Book(\n    title=\"Sense and Sensibility\",\n    year=1811,\n    author=author\n))\n\n# Lazy loading - access author through book\nbook = db.get(Book, book1.pk)\nprint(f\"'{book.title}' by {book.author.name}\")\n# Output: 'Pride and Prejudice' by Jane Austen\n\n# Reverse relationship - access books through author\nauthor = db.get(Author, author.pk)\nprint(f\"{author.name} wrote {author.books.count()} books:\")\nfor book in author.books.fetch_all():\n    print(f\"  - {book.title} ({book.year})\")\n# Output:\n# Jane Austen wrote 2 books:\n#   - Pride and Prejudice (1813)\n#   - Sense and Sensibility (1811)\n\n# Filter reverse relationship\nearly_books = author.books.filter(year__lt=1812).fetch_all()\nprint(f\"Books before 1812: {len(early_books)}\")\n# Output: Books before 1812: 1\n\n# Cascade delete\ndb.delete(Author, author.pk)\nassert db.select(Book).count() == 0  # All books deleted\n</code></pre>"},{"location":"todo/","title":"TODO","text":"<p>Items marked with  are high priority.</p>"},{"location":"todo/#general-plans-and-ideas","title":"General Plans and Ideas","text":"<ul> <li>add ability to inspect existing SQLite databases and generate Pydantic models   dynamically, including CLI tool for schema dumping.</li> <li>add an 'execute' method to the main class to allow executing arbitrary SQL   queries which can be chained to the 'find_first' etc methods or just used   directly.</li> <li>add a <code>rollback</code> method to the main class to allow manual rollbacks.</li> <li> allow adding foreign keys and relationships to each table (partially   done).</li> <li>Investigate a mypy plugin to type reverse relationship accessors (avoid   casts for dynamically injected attributes).</li> <li>Registry lifetime: global registry can cause cross-talk when models are   defined repeatedly in one process (e.g., tests). Short-term fix: add a clear   or reset helper for tests. Longer-term option: make registry per-DB instance.</li> <li>Consider renaming to <code>ForeignKeyField</code> / <code>ManyToManyField</code> and keeping   <code>ForeignKey</code> / <code>ManyToMany</code> as backwards-compatible aliases.</li> <li>Consider adding full atomicity for M2M add/remove within existing   transactions (use savepoints to avoid partial writes).</li> <li>add a migration system to allow updating the database schema without losing   data.</li> <li>add more tests where 'auto_commit' is set to False to ensure that commit is   not called automatically.</li> <li> perhaps add a <code>JSON</code> field type to allow storing JSON data in a field,   and an <code>Object</code> field type to allow storing arbitrary Python objects? Perhaps   a <code>Binary</code> field type to allow storing arbitrary binary data? (just uses the   existing <code>bytes</code> mapping but more explicit)</li> <li>Consider performance optimizations for field validation:<ul> <li>Benchmark shows ~50% overhead for field assignments with validation</li> <li>Potential solutions:<ul> <li>Add a \"fast mode\" configuration option</li> <li>Create bulk update methods that temporarily disable validation</li> <li>Optimize validation for specific field types</li> </ul> </li> </ul> </li> <li>on update, check if the model has actually changed before sending the update   to the database. This will prevent unnecessary updates and leave the   <code>updated_at</code> correct. However, this will always require a query to the   database to check the current values and so in large batch updates this could   have a considerable performance impact. Probably best to gate this behind a   flag.</li> </ul>"},{"location":"todo/#housekeeping","title":"Housekeeping","text":"<ul> <li>Tidy up the test suite - remove any duplicates, sort them into logical files   (many already are), try to reduce and centralize fixtures.</li> </ul>"},{"location":"todo/#documentation","title":"Documentation","text":"<p>None.</p>"},{"location":"todo/#potential-filter-additions","title":"Potential Filter Additions","text":"<ul> <li>Range filter<ul> <li><code>__range</code>: For selecting values within a specific range</li> </ul> </li> </ul> <ul> <li>Date and time filters<ul> <li><code>__year</code>, <code>__month</code>, <code>__day</code>: For filtering date fields</li> <li><code>__date</code>: For filtering the date part of a datetime field</li> </ul> </li> </ul> <ul> <li>Regular expression filter<ul> <li><code>__regex</code>: For more complex string matching</li> </ul> </li> </ul> <ul> <li>Numeric operations<ul> <li><code>__abs</code>: Absolute value comparison</li> </ul> </li> </ul> <ul> <li>Boolean filters<ul> <li><code>__istrue</code>, <code>__isfalse</code>: Explicit boolean checks</li> </ul> </li> </ul> <ul> <li>List field operations<ul> <li><code>__contains_all</code>: Check if a list field contains all specified values</li> <li><code>__contains_any</code>: Check if a list field contains any of the specified values</li> </ul> </li> </ul> <ul> <li>Negation filter<ul> <li><code>__not</code>: General negation for other filters</li> </ul> </li> </ul> <ul> <li>Distinct filter<ul> <li><code>__distinct</code>: To get distinct values in a field</li> </ul> </li> </ul>"},{"location":"tui-demo/","title":"SQLiter Interactive Demo","text":"<p>The SQLiter Interactive Demo is a terminal-based Textual TUI application that provides a hands-on, interactive way to explore SQLiter's features. Through a collection of runnable code examples, you can learn how to use SQLiter effectively without writing any code yourself.</p>"},{"location":"tui-demo/#features","title":"Features","text":"<ul> <li>Interactive Demo Browser: Navigate through categorized demo examples using an intuitive tree view</li> <li>Live Code Display: View the complete source code for each demo with syntax highlighting</li> <li>One-Click Execution: Run demos directly within the TUI and see real output</li> <li>Organized Categories: Demos are grouped by feature area for easy exploration</li> <li>Vim-Style Navigation: Support for j/k keys for navigation (in addition to arrow keys)</li> </ul>"},{"location":"tui-demo/#installation","title":"Installation","text":"<p>The TUI demo is included with SQLiter when you install it with the optional <code>demo</code> (or <code>full</code>) extra:</p> <p>With uv:</p> <pre><code>uv add sqliter-py[demo]\n</code></pre> <p>Or if you are using pip:</p> <pre><code>pip install sqliter-py[demo]\n</code></pre>"},{"location":"tui-demo/#running-the-demo","title":"Running the Demo","text":"<p>To start the interactive TUI demo, simply run:</p> <pre><code>python -m sqliter.tui\n</code></pre> <p>Or if you have SQLiter installed:</p> <pre><code>sqliter-demo\n</code></pre>"},{"location":"tui-demo/#navigation","title":"Navigation","text":""},{"location":"tui-demo/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Up</code> / <code>Down</code> or <code>j</code> / <code>k</code> Navigate demo list <code>Left</code> / <code>Right</code> or <code>h</code> / <code>l</code> Collapse/expand category <code>Enter</code> Select demo to view code <code>F5</code> Run selected demo <code>F8</code> Clear output panel <code>Tab</code> Move focus between panels <code>?</code> or <code>F1</code> Show help screen <code>q</code> Quit application"},{"location":"tui-demo/#mouse-support","title":"Mouse Support","text":"<ul> <li>Click on categories to expand/collapse them</li> <li>Click on demo names to select and view their code</li> <li>Click the \"Run Demo\" button to execute the selected demo</li> <li>Click the \"Clear Output\" button to clear the output panel</li> </ul>"},{"location":"tui-demo/#demo-categories","title":"Demo Categories","text":"<p>The demos are organized into the following categories (in the order they appear in the TUI):</p>"},{"location":"tui-demo/#connection-setup","title":"Connection &amp; Setup","text":"<p>Learn different ways to connect to SQLite databases, including in-memory and file-based databases.</p>"},{"location":"tui-demo/#models-tables","title":"Models &amp; Tables","text":"<p>Understand how to define Pydantic models for your database tables, including field types and constraints.</p>"},{"location":"tui-demo/#crud-operations","title":"CRUD Operations","text":"<p>Basic Create, Read, Update, and Delete operations for managing your data.</p>"},{"location":"tui-demo/#query-filters","title":"Query Filters","text":"<p>Query your data using various filter operators like equals, greater than, less than, and more.</p>"},{"location":"tui-demo/#query-results","title":"Query Results","text":"<p>Different ways to fetch results: single records, all records, or using pagination.</p>"},{"location":"tui-demo/#ordering-pagination","title":"Ordering &amp; Pagination","text":"<p>Sort your query results and use limit/offset for pagination.</p>"},{"location":"tui-demo/#field-selection","title":"Field Selection","text":"<p>Control which fields are returned in your queries to optimize performance.</p>"},{"location":"tui-demo/#string-filters","title":"String Filters","text":"<p>Special filtering options for string fields, including starts with, ends with, and contains.</p>"},{"location":"tui-demo/#constraints","title":"Constraints","text":"<p>Define database constraints like unique fields and foreign key relationships.</p>"},{"location":"tui-demo/#orm-features","title":"ORM Features","text":"<p>Advanced ORM features including foreign keys, lazy loading, and reverse relationships.</p>"},{"location":"tui-demo/#caching","title":"Caching","text":"<p>Improve performance by caching query results with TTL (Time To Live) support.</p>"},{"location":"tui-demo/#auto-timestamps","title":"Auto Timestamps","text":"<p>Automatically track when records are created and last modified.</p>"},{"location":"tui-demo/#transactions","title":"Transactions","text":"<p>Group multiple operations into atomic transactions for data consistency.</p>"},{"location":"tui-demo/#error-handling","title":"Error Handling","text":"<p>Understand common errors and how to handle them properly.</p>"},{"location":"tui-demo/#tips-for-learning","title":"Tips for Learning","text":"<ol> <li>Start with Connection and Models: Before diving into queries, understand how to connect to databases and define your data models.</li> <li>Read the Code First: Each demo displays the complete source code - read it before running to understand what will happen.</li> <li>Experiment: After running a demo, think about how you might modify it for your use case.</li> <li>Follow the Flow: The categories are ordered from basic to advanced - follow them in sequence for the best learning experience.</li> <li>Check the Output: The output panel shows real results - pay attention to what's returned and how it's formatted.</li> </ol>"},{"location":"tui-demo/#next-steps","title":"Next Steps","text":"<p>After exploring the interactive demo, check out the Guide for detailed documentation on each topic.</p> <p>Tip</p> <p>The interactive demo is also a great way to quickly look up syntax - just find the demo that matches what you want to do, and copy the code pattern!</p>"},{"location":"tui-demo/caching/","title":"Caching Demos","text":"<p>These demos show how to use query result caching for improved performance.</p>"},{"location":"tui-demo/caching/#enable-caching","title":"Enable Caching","text":"<p>Cache query results to avoid repeated database queries.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nimport tempfile\nimport time\nfrom pathlib import Path\n\nclass User(BaseDBModel):\n    name: str\n    email: str\n    age: int\n\n# Use file-based database to show real caching benefits\nwith tempfile.NamedTemporaryFile(suffix=\".db\", delete=False) as f:\n    db_path = f.name\n\ndb = None\ntry:\n    db = SqliterDB(db_path, cache_enabled=True)\n    db.create_table(User)\n\n    # Insert more data for a more realistic demo\n    for i in range(50):\n        db.insert(\n            User(\n                name=f\"User {i}\",\n                email=f\"user{i}@example.com\",\n                age=20 + i,\n            )\n        )\n\n    print(\"Inserted 50 users\")\n    print(\"Caching stores query results to avoid repeated I/O\\n\")\n\n    # Query with filter (more expensive than simple pk lookup)\n    # First query - cache miss\n    start = time.perf_counter()\n    users = db.select(User).filter(age__gte=40).fetch_all()\n    miss_time = (time.perf_counter() - start) * 1000\n    print(f\"First query (cache miss): {miss_time:.3f}ms\")\n    print(f\"Found {len(users)} users age 40+\")\n\n    # Second query with same filter - cache hit\n    start = time.perf_counter()\n    users = db.select(User).filter(age__gte=40).fetch_all()\n    hit_time = (time.perf_counter() - start) * 1000\n    print(f\"Second query (cache hit): {hit_time:.3f}ms\")\n    print(f\"Found {len(users)} users age 40+\")\n\n    # Show speedup\n    if hit_time &gt; 0:\n        speedup = miss_time / hit_time\n        print(f\"\\nCache hit is {speedup:.1f}x faster!\")\n    print(\"(Benefits increase with query complexity and data size)\")\n\nfinally:\n    if db is not None:\n        db.close()\n    # Cleanup\n    Path(db_path).unlink(missing_ok=True)\n</code></pre>"},{"location":"tui-demo/caching/#what-gets-cached","title":"What Gets Cached","text":"<ul> <li>Query results are stored in memory</li> <li>Cache key includes the query parameters</li> <li>Results are returned until TTL expires</li> </ul>"},{"location":"tui-demo/caching/#performance-benefits","title":"Performance Benefits","text":"<ul> <li>Memory databases: 1.5-2x faster for cache hits</li> <li>File databases: 6-7x faster for cache hits</li> <li>Complex queries: Benefits increase with query complexity</li> </ul>"},{"location":"tui-demo/caching/#cache-ttl-time-to-live","title":"Cache TTL (Time To Live)","text":"<p>Set how long cache entries remain valid when creating the database connection.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Article(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True, cache_enabled=True, cache_ttl=60)\ndb.create_table(Article)\n\narticle = db.insert(Article(title=\"News Article\"))\nprint(f\"Created: {article.title}\")\nprint(\"Cache TTL set to 60 seconds\")\nprint(\"Cached entries expire after TTL\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/caching/#ttl-behavior","title":"TTL Behavior","text":"<ul> <li>Results are cached for the specified duration</li> <li>After TTL expires, next query fetches fresh data</li> <li>Cache is updated automatically on the next query</li> </ul>"},{"location":"tui-demo/caching/#choosing-ttl","title":"Choosing TTL","text":"<ul> <li>Short TTL (10-60s): Frequently changing data</li> <li>Medium TTL (1-5min): Moderately dynamic data</li> <li>Long TTL (10min+): Relatively static data</li> </ul>"},{"location":"tui-demo/caching/#disable-caching","title":"Disable Caching","text":"<p>Create database without caching for fresh data.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True, cache_enabled=False)\ndb.create_table(Product)\n\nproduct = db.insert(Product(name=\"Widget\", price=19.99))\n\n# Perform queries\nfor _ in range(5):\n    db.get(Product, product.pk)\n\nstats = db.get_cache_stats()\nprint(\"Cache statistics:\")\nprint(f\"  - Total queries: {stats['total']}\")\nprint(f\"  - Cache hits: {stats['hits']}\")\nprint(f\"  - Cache misses: {stats['misses']}\")\nprint(f\"  - Hit rate: {stats['hit_rate']}%\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/caching/#when-to-disable","title":"When to Disable","text":"<ul> <li>Just updated data: Need to see latest changes</li> <li>Critical queries: Must have fresh data</li> <li>Testing: Want to verify actual database state</li> </ul>"},{"location":"tui-demo/caching/#cache-bypass","title":"Cache Bypass","text":"<p>Bypass cache for specific queries.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True, cache_enabled=True)\ndb.create_table(Item)\n\n# Insert item to query\ndb.insert(Item(name=\"Item 1\"))\n\n# First query - uses cache\ndb.select(Item).filter(name__eq=\"Item 1\").fetch_one()\nprint(\"First query: cached\")\n\n# Bypass cache for fresh data - skips cache, hits DB\ndb.select(Item).filter(name__eq=\"Item 1\").bypass_cache().fetch_one()\nprint(\"Second query: bypassed cache for fresh data\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/caching/#use-cases","title":"Use Cases","text":"<ul> <li>Force refresh: Get latest data without disabling cache entirely</li> <li>Selective fresh data: Most queries use cache, some need fresh data</li> <li>Admin operations: See current state while cache is active</li> </ul>"},{"location":"tui-demo/caching/#get-cache-controls","title":"Get Cache Controls","text":"<p>Cache <code>get()</code> lookups, bypass per call, and override TTL.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True, cache_enabled=True, cache_ttl=60)\ndb.create_table(Product)\n\nproduct = db.insert(Product(name=\"Widget\", price=19.99))\n\ndb.get(Product, product.pk)\nstats = db.get_cache_stats()\nprint(\"After first get (miss):\", stats)\n\ndb.get(Product, product.pk)\nstats = db.get_cache_stats()\nprint(\"After second get (hit):\", stats)\n\ndb.get(Product, product.pk, bypass_cache=True)\nstats = db.get_cache_stats()\nprint(\"After bypass_cache=True:\", stats)\n\ndb.get(Product, product.pk, cache_ttl=5)\nprint(\"Per-call TTL override set to 5s for this lookup\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/caching/#notes","title":"Notes","text":"<ul> <li><code>bypass_cache=True</code> skips both reading and writing the cache.</li> <li><code>cache_ttl</code> overrides the global TTL for that single lookup.</li> </ul>"},{"location":"tui-demo/caching/#cache-invalidation","title":"Cache Invalidation","text":"<p>Cache automatically expires based on TTL. For manual invalidation, use the <code>clear_cache()</code> method.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Document(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True, cache_enabled=True)\ndb.create_table(Document)\n\ndoc = db.insert(Document(title=\"Doc 1\"))\ndb.get(Document, doc.pk)\nprint(\"Query executed and cached\")\n\ndb.clear_cache()\nprint(\"Cache cleared\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/caching/#when-cache-invalidates","title":"When Cache Invalidates","text":"<ul> <li>Automatic expiry: After TTL seconds</li> <li>Using bypass_cache(): Per-query fresh data</li> <li>Manual clearing: Call <code>clear_cache()</code> to free memory or force refresh</li> <li>Write operations: Insert/update/delete automatically invalidate affected tables</li> </ul>"},{"location":"tui-demo/caching/#caching-strategies","title":"Caching Strategies","text":""},{"location":"tui-demo/caching/#always-on-recommended","title":"Always On (Recommended)","text":"<pre><code># Enable cache at database creation\ndb = SqliterDB(db_filename=\"mydb.db\", cache_enabled=True, cache_ttl=60)\n</code></pre>"},{"location":"tui-demo/caching/#selective-caching","title":"Selective Caching","text":"<pre><code># For read-heavy workloads\ndb_cached = SqliterDB(db_filename=\"mydb.db\", cache_enabled=True, cache_ttl=300)\nreports = db_cached.select(Sales).fetch_all()\n\n# For write-heavy workloads\ndb_fresh = SqliterDB(db_filename=\"mydb.db\", cache_enabled=False)\nfor record in new_records:\n    db_fresh.insert(record)\n</code></pre>"},{"location":"tui-demo/caching/#per-query-bypass","title":"Per-Query Bypass","text":"<pre><code>db = SqliterDB(memory=True, cache_enabled=True, cache_ttl=60)\n\n# Most queries use cache\nsummary = db.select(Stats).fetch_one()\n\n# Critical query needs fresh data\ncurrent_count = db.select(Users).bypass_cache().count()\n</code></pre>"},{"location":"tui-demo/caching/#when-to-use-caching","title":"When to Use Caching","text":""},{"location":"tui-demo/caching/#ideal-for","title":"Ideal For","text":"<ul> <li>Read-heavy applications: Mostly queries, few updates</li> <li>Expensive queries: Complex filters, joins, aggregations</li> <li>Dashboard data: Statistics that don't change often</li> <li>Reference data: Lookup tables, configuration</li> </ul>"},{"location":"tui-demo/caching/#avoid-for","title":"Avoid For","text":"<ul> <li>Write-heavy applications: Frequent updates invalidate cache</li> <li>Real-time data: Always need the latest data</li> <li>Large result sets: Memory concerns with caching</li> <li>Frequently changing data: Cache invalidates too often</li> </ul>"},{"location":"tui-demo/caching/#performance-impact","title":"Performance Impact","text":""},{"location":"tui-demo/caching/#before-caching","title":"Before Caching","text":"<pre><code># Each query hits the database\nfor _ in range(100):\n    users = db.select(User).fetch_all()  # 100 database queries\n</code></pre>"},{"location":"tui-demo/caching/#after-caching","title":"After Caching","text":"<pre><code>db = SqliterDB(memory=True, cache_enabled=True, cache_ttl=60)\nfor _ in range(100):\n    users = db.select(User).fetch_all()  # 1 database query, 99 cache hits\n</code></pre>"},{"location":"tui-demo/caching/#real-world-example","title":"Real-World Example","text":"<ul> <li>Without cache: 100ms \u00d7 100 = 10,000ms (10 seconds)</li> <li>With cache: 100ms + 1ms \u00d7 99 = 199ms (0.2 seconds)</li> <li>Speedup: 50x faster</li> </ul>"},{"location":"tui-demo/caching/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/caching/#do","title":"DO","text":"<ul> <li>Enable caching when creating database connection for read-heavy workloads</li> <li>Set appropriate TTL for your data freshness needs</li> <li>Use bypass_cache() for queries that need fresh data</li> <li>Monitor cache performance with get_cache_stats()</li> </ul>"},{"location":"tui-demo/caching/#dont","title":"DON'T","text":"<ul> <li>Set excessively long TTL for dynamic data</li> <li>Cache sensitive data that should always be fresh</li> <li>Forget that cached data doesn't reflect recent database changes</li> </ul>"},{"location":"tui-demo/caching/#related-documentation","title":"Related Documentation","text":"<ul> <li>Database Connection - Connect and configure database</li> <li>Query Results - Fetch query results</li> <li>Transactions - Group operations atomically</li> </ul>"},{"location":"tui-demo/connection/","title":"Database Connection Demos","text":"<p>These demos show different ways to connect to SQLite databases using SQLiter.</p>"},{"location":"tui-demo/connection/#in-memory-database","title":"In-Memory Database","text":"<p>The fastest option for temporary data or testing. Data is lost when the database connection closes.</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(memory=True)\nprint(f\"Created database: {db}\")\nprint(f\"Is memory: {db.is_memory}\")\nprint(f\"Filename: {db.filename}\")\n\ndb.connect()\nprint(f\"Connected: {db.is_connected}\")\n\ndb.close()\nprint(f\"After close: {db.is_connected}\")\n</code></pre>"},{"location":"tui-demo/connection/#when-to-use","title":"When to Use","text":"<ul> <li>Testing: Perfect for unit tests where you need a fresh database each time</li> <li>Caching: Temporary cache data that doesn't need to persist</li> <li>Prototyping: Quickly test data models without creating files</li> </ul>"},{"location":"tui-demo/connection/#performance","title":"Performance","text":"<p>In-memory databases are typically 2-3x faster than file-based databases since there's no disk I/O.</p>"},{"location":"tui-demo/connection/#file-based-database","title":"File-Based Database","text":"<p>For persistent data storage that survives application restarts.</p> <pre><code>from sqliter import SqliterDB\nimport tempfile\nfrom pathlib import Path\n\nwith tempfile.NamedTemporaryFile(suffix=\".db\", delete=False) as f:\n    db_path = f.name\n\ntry:\n    db = SqliterDB(db_path)\n    print(\"Created file database\")\n    print(f\"Filename: {db.filename}\")\n    print(f\"Is memory: {db.is_memory}\")\n\n    db.connect()\n    print(f\"Connected to: {db_path}\")\n    db.close()\nfinally:\n    Path(db_path).unlink(missing_ok=True)\n    print(\"Cleaned up database file\")\n</code></pre>"},{"location":"tui-demo/connection/#when-to-use_1","title":"When to Use","text":"<ul> <li>Production Applications: Any data that needs to persist</li> <li>Data Analysis: Working with existing SQLite databases</li> <li>Web Applications: Storing user data, sessions, etc.</li> </ul>"},{"location":"tui-demo/connection/#best-practices","title":"Best Practices","text":"<ul> <li>Use absolute paths for database files to avoid confusion</li> <li>Consider database file location (e.g., user data directory)</li> <li>Handle file permissions appropriately</li> </ul>"},{"location":"tui-demo/connection/#context-manager","title":"Context Manager","text":"<p>Using SQLiter as a context manager provides automatic transaction management with auto-commit on success.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    done: bool = False\n\nprint(\"Using context manager for transactions:\\n\")\n\ndb = SqliterDB(memory=True)\n\nwith db:\n    db.create_table(Task)\n    task = db.insert(Task(title=\"Learn SQLiter\", done=False))\n    print(f\"Inserted: {task.title} (pk={task.pk})\")\n    print(\"Transaction auto-commits on exit\")\n\nprint(f\"\\nAfter context: connected={db.is_connected}\")\n</code></pre>"},{"location":"tui-demo/connection/#benefits","title":"Benefits","text":"<ul> <li>Automatic Commit: Transaction commits when context exits successfully</li> <li>Automatic Rollback: Changes are rolled back if an error occurs</li> <li>Cleaner Code: No need to manually call <code>db.commit()</code></li> </ul>"},{"location":"tui-demo/connection/#when-to-use_2","title":"When to Use","text":"<ul> <li>Grouped Operations: Multiple operations that should succeed or fail together</li> <li>Data Integrity: Operations that must be atomic</li> <li>Error Safety: Ensure changes aren't partially applied</li> </ul>"},{"location":"tui-demo/connection/#debug-mode","title":"Debug Mode","text":"<p>Enable SQL query logging to see exactly what SQL SQLiter is executing.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nprint(\"Debug mode enables SQL query logging.\")\nprint(\"When debug=True, all SQL queries are logged.\\n\")\n\ndb = SqliterDB(memory=True, debug=True)\ndb.create_table(BaseDBModel)\n\nprint(\"SQL queries would be logged to console:\")\nprint('  CREATE TABLE IF NOT EXISTS \"users\" (...)')\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/connection/#what-youll-see","title":"What You'll See","text":"<ul> <li><code>CREATE TABLE</code> statements when creating tables</li> <li><code>INSERT</code> statements when adding records</li> <li><code>SELECT</code> statements when querying data</li> <li>Parameter values being bound</li> </ul>"},{"location":"tui-demo/connection/#when-to-use_3","title":"When to Use","text":"<ul> <li>Learning: Understand how SQLiter translates Python to SQL</li> <li>Debugging: Troubleshoot query issues</li> <li>Optimization: Identify inefficient queries</li> <li>Development: See what's happening behind the scenes</li> </ul> <p>Warning</p> <p>Debug mode outputs SQL queries to stderr. Don't enable in production unless needed for troubleshooting.</p>"},{"location":"tui-demo/connection/#summary-table","title":"Summary Table","text":"Method Pros Cons Best For In-Memory Fast, no cleanup needed Data lost on close Tests, caching, prototyping File-Based Persistent data Slower, file management Production, real data Context Manager Auto cleanup, exception safe Slightly more verbose Scripts, batch jobs Debug Mode See SQL queries Verbose output Learning, debugging"},{"location":"tui-demo/connection/#related-documentation","title":"Related Documentation","text":"<ul> <li>Models - Define your data structure</li> <li>CRUD Operations - Work with your data</li> <li>Transactions - Group operations atomically</li> </ul>"},{"location":"tui-demo/constraints/","title":"Constraint Demos","text":"<p>These demos show how to define database constraints.</p>"},{"location":"tui-demo/constraints/#unique-fields","title":"Unique Fields","text":"<p>Ensure values in a field are unique across all records.</p> <pre><code>from typing import Annotated\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom sqliter.model.unique import unique\n\nclass User(BaseDBModel):\n    email: Annotated[str, unique()]\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nuser1 = db.insert(User(email=\"alice@example.com\", name=\"Alice\"))\nprint(f\"Created: {user1.name} ({user1.email})\")\n\nuser2 = db.insert(User(email=\"bob@example.com\", name=\"Bob\"))\nprint(f\"Created: {user2.name} ({user2.email})\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/constraints/#using-annotated","title":"Using Annotated","text":"<p>We use <code>Annotated[str, unique()]</code> instead of <code>email: str = unique()</code> because:</p> <ul> <li>Type Safety: Passes <code>mypy</code> type checking without errors</li> <li>Best Practice: Recommended by Pydantic for metadata on fields</li> <li>Clarity: Makes it clear that <code>unique()</code> is metadata, not a default value</li> </ul> <p>You can use <code>email: str = unique()</code> if you don't use type checkers, but it will fail mypy.</p>"},{"location":"tui-demo/constraints/#what-it-does","title":"What It Does","text":"<ul> <li>Creates a <code>UNIQUE</code> constraint in the database</li> <li>Database prevents duplicate values</li> <li>Query fails with error if you try to insert a duplicate</li> </ul>"},{"location":"tui-demo/constraints/#when-to-use","title":"When to Use","text":"<ul> <li>Usernames: No two users can have the same username</li> <li>Emails: Prevent duplicate email registrations</li> <li>Slugs: Unique URL identifiers</li> <li>Codes: Unique coupon/promo codes</li> </ul>"},{"location":"tui-demo/constraints/#primary-key","title":"Primary Key","text":"<p>Every model automatically gets a primary key field.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    \"\"\"Product with auto-generated primary key.\"\"\"\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\nproduct = db.insert(Product(name=\"Widget\", price=10.0))\nprint(f\"Primary key: {product.pk}\")  # Auto-generated\n</code></pre>"},{"location":"tui-demo/constraints/#automatic-behavior","title":"Automatic Behavior","text":"<ul> <li>Field named <code>pk</code> is automatically added</li> <li>Auto-increments with each insert</li> <li>Guaranteed unique for each record</li> <li>Used by <code>get()</code> and foreign keys</li> </ul>"},{"location":"tui-demo/constraints/#dont-define-your-own","title":"Don't Define Your Own","text":"<pre><code># \u274c WRONG: Don't do this\nclass User(BaseDBModel):\n    id: int  # Conflicts with auto-generated pk\n\n# \u2705 CORRECT: Let SQLiter handle it\nclass User(BaseDBModel):\n    name: str\n</code></pre>"},{"location":"tui-demo/constraints/#not-null-constraints","title":"Not Null Constraints","text":"<p>Fields without defaults are implicitly NOT NULL.</p> <pre><code>from sqliter.model import BaseDBModel\nfrom typing import Optional\n\nclass Task(BaseDBModel):\n    \"\"\"Task with required and optional fields.\"\"\"\n    title: str  # Required (NOT NULL)\n    description: Optional[str] = None  # Optional (can be NULL)\n</code></pre>"},{"location":"tui-demo/constraints/#field-behavior","title":"Field Behavior","text":"<ul> <li>Required fields: Must be provided when inserting</li> <li>Optional fields: Can be omitted, default to <code>None</code> or specified default</li> </ul>"},{"location":"tui-demo/constraints/#insert-behavior","title":"Insert Behavior","text":"<pre><code># \u2705 Works: title is provided\ndb.insert(Task(title=\"Buy groceries\"))\n\n# \u274c Fails: title is required\ndb.insert(Task(description=\"Some task\"))\n</code></pre>"},{"location":"tui-demo/constraints/#default-values","title":"Default Values","text":"<p>Set default values for optional fields.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass Settings(BaseDBModel):\n    \"\"\"Settings with default values.\"\"\"\n    theme: str = \"dark\"\n    notifications_enabled: bool = True\n    items_per_page: int = 20\n</code></pre>"},{"location":"tui-demo/constraints/#when-inserting","title":"When Inserting","text":"<pre><code># All defaults used\nsettings1 = db.insert(Settings())\n\n# Override some defaults\nsettings2 = db.insert(Settings(theme=\"light\"))\n\n# Override all defaults\nsettings3 = db.insert(Settings(\n    theme=\"light\",\n    notifications_enabled=False,\n    items_per_page=50\n))\n</code></pre>"},{"location":"tui-demo/constraints/#check-constraints","title":"Check Constraints","text":"<p>Validate field values using Pydantic validators.</p> <pre><code>from sqliter.model import BaseDBModel\nfrom pydantic import field_validator\n\nclass Product(BaseDBModel):\n    \"\"\"Product with price validation.\"\"\"\n    name: str\n    price: float\n\n    @field_validator(\"price\")\n    @classmethod\n    def price_must_be_positive(cls, value: float) -&gt; float:\n        if value &lt;= 0:\n            raise ValueError(\"Price must be positive\")\n        return value\n</code></pre>"},{"location":"tui-demo/constraints/#how-it-works","title":"How It Works","text":"<ul> <li>Pydantic validates before database insert</li> <li>Prevents invalid data from being stored</li> <li>Returns helpful error messages</li> </ul>"},{"location":"tui-demo/constraints/#constraint-summary","title":"Constraint Summary","text":"Constraint How to Define Purpose Primary Key Automatic (<code>pk</code> field) Unique identifier for each record Unique <code>Annotated[str, unique()]</code> Field values must be unique Not Null No default value Field must have a value Default Value <code>field: type = value</code> Default value if not provided Check Pydantic validator Custom validation logic"},{"location":"tui-demo/constraints/#error-handling","title":"Error Handling","text":"<p>When constraints are violated:</p> <pre><code>from typing import Annotated\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom sqliter.model.unique import unique\nfrom sqliter.exceptions import RecordInsertionError\n\nclass User(BaseDBModel):\n    username: Annotated[str, unique()]\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\n# Insert first user\ndb.insert(User(username=\"alice\"))\n\n# Try to insert duplicate\ntry:\n    db.insert(User(username=\"alice\"))\nexcept RecordInsertionError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"tui-demo/constraints/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/constraints/#do","title":"DO","text":"<ul> <li>Use <code>unique()</code> for fields that must be unique</li> <li>Provide sensible defaults for optional fields</li> <li>Use Pydantic validators for complex constraints</li> <li>Handle <code>RecordInsertionError</code> for constraint violations</li> </ul>"},{"location":"tui-demo/constraints/#dont","title":"DON'T","text":"<ul> <li>Define your own primary key field</li> <li>Forget that fields without defaults are required</li> <li>Use check constraints for simple validation (use Pydantic)</li> </ul>"},{"location":"tui-demo/constraints/#related-documentation","title":"Related Documentation","text":"<ul> <li>Models - Define your data models</li> <li>Error Handling - Handle constraint violations</li> <li>CRUD Operations - Insert and update records</li> </ul>"},{"location":"tui-demo/crud/","title":"CRUD Operations Demos","text":"<p>These demos demonstrate the basic Create, Read, Update, and Delete operations in SQLiter.</p>"},{"location":"tui-demo/crud/#insert-records","title":"Insert Records","text":"<p>Add new records to the database.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    email: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nuser1 = db.insert(User(name=\"Alice\", email=\"alice@example.com\"))\nprint(f\"Inserted: {user1.name} (pk={user1.pk})\")\n\nuser2 = db.insert(User(name=\"Bob\", email=\"bob@example.com\"))\nprint(f\"Inserted: {user2.name} (pk={user2.pk})\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/crud/#return-value","title":"Return Value","text":"<p><code>db.insert()</code> returns the inserted model instance with the <code>pk</code> field populated.</p>"},{"location":"tui-demo/crud/#performance","title":"Performance","text":"<p>For bulk inserts, consider using transactions (see Transactions) for better performance.</p>"},{"location":"tui-demo/crud/#get-by-primary-key","title":"Get by Primary Key","text":"<p>Retrieve a single record by its primary key.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    done: bool = False\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ntask: Task = db.insert(Task(title=\"Buy groceries\"))\nprint(f\"Created: {task.title} (pk={task.pk})\")\n\nretrieved = db.get(Task, task.pk)\nif retrieved is not None:\n    task_retrieved = retrieved\n    print(f\"Retrieved: {task_retrieved.title}\")\n    print(f\"Same object: {task_retrieved.pk == task.pk}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/crud/#when-record-doesnt-exist","title":"When Record Doesn't Exist","text":"<p>Returns <code>None</code> if no record is found with that primary key.</p>"},{"location":"tui-demo/crud/#update-records","title":"Update Records","text":"<p>Modify existing records.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n    quantity: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Item)\n\nitem = db.insert(Item(name=\"Apples\", quantity=5))\nprint(f\"Created: {item.name} x{item.quantity}\")\n\nitem.quantity = 10\ndb.update(item)\nprint(f\"Updated: {item.name} x{item.quantity}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/crud/#update-process","title":"Update Process","text":"<ol> <li>Retrieve the record (or keep reference from insert)</li> <li>Modify the fields</li> <li>Call <code>db.update()</code> with the modified object</li> </ol>"},{"location":"tui-demo/crud/#auto-timestamps","title":"Auto-Timestamps","text":"<p>If your model has <code>updated_at</code>, it's automatically updated when you call <code>db.update()</code>.</p>"},{"location":"tui-demo/crud/#delete-records","title":"Delete Records","text":"<p>Remove records from the database.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Note(BaseDBModel):\n    content: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Note)\n\nnote = db.insert(Note(content=\"Temporary note\"))\nprint(f\"Created note (pk={note.pk})\")\n\ndb.delete(Note, note.pk)\nprint(f\"Deleted note with pk={note.pk}\")\n\nall_notes = db.select(Note).fetch_all()\nprint(f\"Remaining notes: {len(all_notes)}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/crud/#foreign-key-constraints","title":"Foreign Key Constraints","text":"<p>If other records reference this record (via foreign keys), the delete will fail unless you handle the dependencies first.</p>"},{"location":"tui-demo/crud/#bulk-insert","title":"Bulk Insert","text":"<p>Insert multiple records in a single transaction.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\nproducts = [\n    Product(name=\"Widget\", price=9.99),\n    Product(name=\"Gadget\", price=24.99),\n    Product(name=\"Gizmo\", price=14.99),\n]\nresults = db.bulk_insert(products)\n\nprint(f\"Inserted {len(results)} products:\")\nfor product in results:\n    print(f\"  pk={product.pk}: {product.name} (${product.price})\")\n\ntotal = db.select(Product).count()\nprint(f\"\\nTotal products in database: {total}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/crud/#what-happens","title":"What Happens","text":"<ul> <li><code>db.bulk_insert()</code> inserts all records in a single transaction</li> <li>Each returned instance has its <code>pk</code> field populated</li> <li>If any insert fails, all inserts in the batch are rolled back</li> <li>Auto-timestamps (<code>created_at</code>, <code>updated_at</code>) are set on each record</li> </ul>"},{"location":"tui-demo/crud/#when-to-use-bulk-insert","title":"When to Use Bulk Insert","text":"<ul> <li>Use when inserting multiple records of the same model type</li> <li>Use for seeding data or importing batches</li> <li>Don't use for mixed model types (raises <code>ValueError</code>)</li> </ul>"},{"location":"tui-demo/crud/#operation-summary","title":"Operation Summary","text":"Operation Method Returns Create <code>db.insert(Model(...))</code> The model with <code>pk</code> set Create (batch) <code>db.bulk_insert([...])</code> List of models with <code>pk</code> set Read <code>db.get(Model, pk)</code> The model or <code>None</code> Update <code>db.update(model)</code> Nothing (modifies in-place) Delete <code>db.delete(Model, pk)</code> Nothing"},{"location":"tui-demo/crud/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/crud/#do","title":"DO","text":"<ul> <li>Keep the returned model from <code>insert()</code> for later use</li> <li>Use <code>get()</code> when you know the primary key</li> <li>Validate data before inserting (Pydantic does this automatically)</li> <li>Use transactions for multiple related operations</li> </ul>"},{"location":"tui-demo/crud/#dont","title":"DON'T","text":"<ul> <li>Forget to call <code>db.update()</code> after modifying a model</li> <li>Assume <code>get()</code> always returns a record (check for <code>None</code>)</li> <li>Delete records without checking for foreign key dependencies</li> </ul>"},{"location":"tui-demo/crud/#related-documentation","title":"Related Documentation","text":"<ul> <li>Models - Define your data models</li> <li>Query Results - Fetch records in different ways</li> <li>Transactions - Group operations atomically</li> <li>Filtering - Query records with conditions</li> </ul>"},{"location":"tui-demo/errors/","title":"Error Handling Demos","text":"<p>These demos show how to handle errors that occur when working with SQLiter.</p>"},{"location":"tui-demo/errors/#duplicate-record-error","title":"Duplicate Record Error","text":"<p>Handle unique constraint violations.</p> <pre><code>from typing import Annotated\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom sqliter.model.unique import unique\nfrom sqliter.exceptions import RecordInsertionError\n\nclass User(BaseDBModel):\n    email: Annotated[str, unique()]\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(email=\"alice@example.com\", name=\"Alice\"))\nprint(\"Created user with email alice@example.com\")\n\ntry:\n    # Try to insert duplicate email\n    db.insert(User(email=\"alice@example.com\", name=\"Alice 2\"))\nexcept RecordInsertionError as e:\n    print(f\"\\nCaught error: {type(e).__name__}\")\n    print(f\"Message: {e}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/errors/#prevention","title":"Prevention","text":"<p>Check if record exists before inserting:</p> <pre><code>existing = db.select(User).filter(email__eq=\"alice@example.com\").fetch_one()\nif not existing:\n    db.insert(User(name=\"Alice\", email=\"alice@example.com\"))\n</code></pre>"},{"location":"tui-demo/errors/#record-not-found","title":"Record Not Found","text":"<p>Handle missing records gracefully.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom sqliter.exceptions import RecordNotFoundError\n\nclass User(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nuser = db.insert(User(name=\"Alice\"))\nprint(f\"Created user with pk={user.pk}\")\n\ntry:\n    # Try to delete non-existent record (raises RecordNotFoundError)\n    db.delete(User, 9999)\nexcept RecordNotFoundError as e:\n    print(f\"\\nCaught error: {type(e).__name__}\")\n    print(f\"Message: {e}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/errors/#alternative-using-queries","title":"Alternative Using Queries","text":"<p>Use <code>fetch_one()</code> which returns <code>None</code> instead of raising:</p> <pre><code>user = db.select(User).filter(name__eq=\"Alice\").fetch_one()\nif user is None:\n    print(\"User not found\")\nelse:\n    print(f\"Found: {user.name}\")\n</code></pre>"},{"location":"tui-demo/errors/#validation-errors","title":"Validation Errors","text":"<p>Pydantic validates data before it reaches the database, ensuring type safety and data integrity.</p> <pre><code>from pydantic import ValidationError\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n    quantity: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\nproduct = db.insert(Product(name=\"Widget\", price=19.99, quantity=100))\nprint(f\"Created product: {product.name}, price: ${product.price}\")\n\n# Try to create product with invalid data (wrong types)\nprint(\"\\nAttempting to create product with invalid data...\")\n\ntry:\n    # Wrong types: price should be float, quantity should be int\n    # ValidationError is raised by Pydantic during model instantiation\n    Product(name=\"Invalid Widget\", price=\"free\", quantity=\"lots\")\nexcept ValidationError as e:\n    print(f\"\\nCaught error: {type(e).__name__}\")\n    print(f\"Message: {e}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/errors/#benefits","title":"Benefits","text":"<ul> <li>Data never reaches the database in invalid form - Validation happens before insert</li> <li>Clear error messages - Pydantic tells you exactly what's wrong</li> <li>Type safety - Catch type mismatches at model instantiation, not at database insert</li> <li>Automatic - No manual validation code needed, Pydantic handles it</li> </ul>"},{"location":"tui-demo/errors/#generic-error-handling","title":"Generic Error Handling","text":"<p>Catch all SQLiter errors with the base <code>SqliterError</code> class when you don't need to distinguish between specific error types.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom sqliter.exceptions import SqliterError\n\nclass Task(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ntask = db.insert(Task(title=\"My Task\"))\nprint(f\"Created task: {task.title}\")\n\n# Try to update a deleted record\ntry:\n    task.title = \"Updated\"\n    db.delete(Task, task.pk)\n    db.update(task)  # This will fail\nexcept SqliterError as e:\n    print(f\"\\nCaught SqliterError: {type(e).__name__}\")\n    print(f\"Message: {e}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/errors/#when-to-use-generic-error-handling","title":"When to Use Generic Error Handling","text":"<ul> <li>Simplified error handling: When you don't need to take different actions based on error type</li> <li>Logging or reporting: When you just need to log that an error occurred</li> <li>Top-level error handlers: When you want to catch any SQLiter error at the application boundary</li> </ul>"},{"location":"tui-demo/errors/#specific-vs-generic","title":"Specific vs Generic","text":"<pre><code># Specific - handle different error types differently\ntry:\n    db.insert(user)\nexcept RecordInsertionError:\n    print(\"Duplicate user\")\nexcept ValidationError as e:\n    print(f\"Invalid data: {e}\")\n\n# Generic - catch all SQLiter errors\ntry:\n    db.insert(user)\nexcept SqliterError as e:\n    print(f\"Database error: {e}\")\n</code></pre>"},{"location":"tui-demo/errors/#database-connection-errors","title":"Database Connection Errors","text":"<p>Handle connection failures.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n\ntry:\n    # Try to connect to non-existent directory\n    db = SqliterDB(database=\"/invalid/path/db.sqlite\")\n    db.create_table(User)\nexcept (OSError, IOError) as e:\n    print(f\"Connection failed: {e}\")\n</code></pre>"},{"location":"tui-demo/errors/#common-causes","title":"Common Causes","text":"<ul> <li>Invalid directory (doesn't exist)</li> <li>Permission denied (can't write to directory)</li> <li>Database file corrupted</li> </ul>"},{"location":"tui-demo/errors/#table-creation","title":"Table Creation","text":"<p>Always create tables before using them.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True)\n\n# Always create tables first\ndb.create_table(User)\n\n# Now inserts will work\ndb.insert(User(name=\"Alice\"))\n</code></pre>"},{"location":"tui-demo/errors/#prevention_1","title":"Prevention","text":"<p>Always call <code>create_table()</code> before inserting:</p> <pre><code>db.create_table(User)  # Safe if called multiple times\ndb.insert(User(name=\"Alice\"))\n</code></pre>"},{"location":"tui-demo/errors/#foreign-key-constraint-errors","title":"Foreign Key Constraint Errors","text":"<p>Handle foreign key violations.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\nfrom sqliter.exceptions import ForeignKeyConstraintError\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, on_delete=\"RESTRICT\")\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"Jane\"))\ndb.insert(Book(title=\"Book 1\", author=author))\nprint(\"Created author and linked book\")\n\n# Attempt to insert book with non-existent author\nprint(\"\\nAttempting to insert book with non-existent author...\")\n\ntry:\n    # Create book with invalid author_id (doesn't exist in database)\n    invalid_book = Book(title=\"Orphan Book\", author_id=9999)\n    db.insert(invalid_book)\nexcept ForeignKeyConstraintError as e:\n    print(f\"\\nCaught error: {type(e).__name__}\")\n    print(f\"Message: {e}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/errors/#prevention_2","title":"Prevention","text":"<p>Ensure parent record exists:</p> <pre><code>author = db.insert(Author(name=\"Jane Austen\"))\ndb.insert(Book(title=\"Pride and Prejudice\", author=author))\n</code></pre>"},{"location":"tui-demo/errors/#transaction-errors","title":"Transaction Errors","text":"<p>Handle errors during transactions.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Account(BaseDBModel):\n    balance: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Account)\n\naccount = db.insert(Account(balance=100.0))\n\ntry:\n    with db:\n        account.balance -= 200.0  # Would go negative\n        db.update(account)\n        raise ValueError(\"Invalid operation\")\nexcept ValueError as e:\n    print(f\"Transaction failed: {e}\")\n    print(\"Changes rolled back automatically\")\n\n# Verify balance unchanged (rollback restored original value)\nreloaded = db.get(Account, account.pk)\nif reloaded is not None:\n    print(f\"Balance: {reloaded.balance}\")  # Still 100.0\n</code></pre>"},{"location":"tui-demo/errors/#error-handling-best-practices","title":"Error Handling Best Practices","text":""},{"location":"tui-demo/errors/#specific-exceptions","title":"Specific Exceptions","text":"<p>Catch specific exceptions for different error types:</p> <pre><code>from pydantic import ValidationError\nfrom sqliter.exceptions import (\n    RecordInsertionError,\n    RecordNotFoundError,\n    ForeignKeyConstraintError,\n    SqliterError,\n)\n\ntry:\n    db.insert(user)\nexcept RecordInsertionError:\n    print(\"Duplicate record or constraint violation\")\nexcept ValidationError as e:\n    print(f\"Invalid data: {e}\")\nexcept SqliterError as e:\n    print(f\"Database error: {e}\")\n</code></pre>"},{"location":"tui-demo/errors/#user-friendly-messages","title":"User-Friendly Messages","text":"<p>Translate technical errors for users:</p> <pre><code>from typing import Annotated\n\nfrom sqliter.model import BaseDBModel\nfrom sqliter.model.unique import unique\nfrom sqliter.exceptions import RecordInsertionError\n\nclass User(BaseDBModel):\n    username: Annotated[str, unique()]\n\ntry:\n    db.insert(User(username=\"alice\"))\nexcept RecordInsertionError:\n    print(\"Username already taken, please choose another\")\n</code></pre>"},{"location":"tui-demo/errors/#logging","title":"Logging","text":"<p>Log errors for debugging:</p> <pre><code>import logging\n\nfrom sqliter.model import BaseDBModel\nfrom sqliter.exceptions import RecordInsertionError\n\nlogger = logging.getLogger(__name__)\n\nclass User(BaseDBModel):\n    username: str\n\ntry:\n    db.insert(User(username=\"alice\"))\nexcept RecordInsertionError as e:\n    logger.error(f\"Failed to create user: {e}\")\n    raise  # Re-raise for user-facing error\n</code></pre>"},{"location":"tui-demo/errors/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception\n\u251c\u2500\u2500 SqliterError\n\u2502   \u251c\u2500\u2500 RecordNotFoundError\n\u2502   \u251c\u2500\u2500 RecordInsertionError\n\u2502   \u251c\u2500\u2500 RecordUpdateError\n\u2502   \u251c\u2500\u2500 RecordDeletionError\n\u2502   \u2514\u2500\u2500 ForeignKeyConstraintError\n\u2514\u2500\u2500 ValidationError (from Pydantic)\n</code></pre>"},{"location":"tui-demo/errors/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/errors/#do","title":"DO","text":"<ul> <li>Catch specific exceptions for different error types</li> <li>Provide user-friendly error messages</li> <li>Log errors for debugging</li> <li>Validate data before database operations</li> <li>Use transactions for multi-step operations</li> </ul>"},{"location":"tui-demo/errors/#dont","title":"DON'T","text":"<ul> <li>Catch all exceptions with bare <code>except:</code></li> <li>Ignore errors silently</li> <li>Expose raw database errors to users</li> <li>Forget that validation errors prevent database writes</li> </ul>"},{"location":"tui-demo/errors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Constraints - Define database constraints</li> <li>Transactions - Handle errors in transactions</li> <li>CRUD Operations - Common operations and their errors</li> </ul>"},{"location":"tui-demo/field-selection/","title":"Field Selection Demos","text":"<p>These demos show how to control which fields are returned in your queries.</p>"},{"location":"tui-demo/field-selection/#select-specific-fields","title":"Select Specific Fields","text":"<p>Fetch only the columns you need to reduce data transfer.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    email: str\n    age: int\n    city: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(name=\"Alice\", email=\"alice@example.com\", age=30, city=\"NYC\"))\ndb.insert(User(name=\"Bob\", email=\"bob@example.com\", age=25, city=\"LA\"))\n\n# Select only name and email\nusers = db.select(User).fields([\"name\", \"email\"]).fetch_all()\nprint(\"Selected only name and email fields:\")\nfor user in users:\n    print(f\"  - {user.name}, {user.email}\")\n\n# Note: age and city are None since they weren't selected\nprint(\"(age and city not selected, set to None)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/field-selection/#benefits","title":"Benefits","text":"<ul> <li>Performance: Less data transferred from database</li> <li>Memory: Lower memory usage for large result sets</li> <li>Clarity: Explicit about what data you need</li> </ul>"},{"location":"tui-demo/field-selection/#when-to-use","title":"When to Use","text":"<ul> <li>API responses: Only send needed fields to clients</li> <li>Large records: Records with many fields, but you only need a few</li> <li>Sensitive data: Exclude fields like passwords</li> </ul>"},{"location":"tui-demo/field-selection/#exclude-fields","title":"Exclude Fields","text":"<p>Specify fields to exclude from results.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n    description: str\n    stock: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\ndb.insert(\n    Product(\n        name=\"Laptop\",\n        price=999.99,\n        description=\"Fast laptop\",\n        stock=10,\n    )\n)\n\n# Exclude description and stock\nproduct = db.select(Product).exclude([\"description\", \"stock\"]).fetch_one()\nif product is not None:\n    print(f\"Product: {product.name}\")\n    print(f\"Price: ${product.price}\")\n    print(\"(description and stock excluded)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/field-selection/#use-cases","title":"Use Cases","text":"<ul> <li>Hidden fields: Exclude internal metadata</li> <li>Large fields: Exclude large text/binary fields not needed for display</li> <li>Sensitive data: Exclude passwords, tokens, etc.</li> </ul>"},{"location":"tui-demo/field-selection/#select-single-field","title":"Select Single Field","text":"<p>Fetch only one field from a query.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    status: str\n    priority: int\n    assigned_to: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ndb.insert(\n    Task(title=\"Fix bug\", status=\"todo\", priority=1, assigned_to=\"Alice\")\n)\ndb.insert(\n    Task(title=\"Add feature\", status=\"done\", priority=2, assigned_to=\"Bob\")\n)\n\n# Select only the title field\ntasks = db.select(Task).only(\"title\").fetch_all()\nprint(\"Selected only title field:\")\nfor task in tasks:\n    print(f\"  - {task.title}\")\n\nprint(\"(status, priority, assigned_to not selected)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/field-selection/#when-to-use_1","title":"When to Use","text":"<ul> <li>Lists/ dropdowns: Only need display values</li> <li>Aggregation: Extract specific column values</li> <li>Simple queries: You only need one piece of information</li> </ul>"},{"location":"tui-demo/field-selection/#field-selection-vs-filtering","title":"Field Selection vs. Filtering","text":"<p>Important distinction:</p> <pre><code># Field selection: Controls which COLUMNS are returned\ndb.select(User).fields([\"name\", \"email\"]).fetch_all()\n\n# Filtering: Controls which ROWS are returned\ndb.select(User).filter(age__gte=18).fetch_all()\n</code></pre>"},{"location":"tui-demo/field-selection/#performance-impact","title":"Performance Impact","text":""},{"location":"tui-demo/field-selection/#before-optimization","title":"Before Optimization","text":"<pre><code># Fetches all fields (potentially large records)\nusers = db.select(User).fetch_all()  # All fields included\n</code></pre>"},{"location":"tui-demo/field-selection/#after-optimization","title":"After Optimization","text":"<pre><code># Fetches only needed fields\nusers = db.select(User).fields([\"name\", \"email\"]).fetch_all()\n</code></pre>"},{"location":"tui-demo/field-selection/#performance-gains","title":"Performance Gains","text":"<ul> <li>Less memory: Smaller objects in memory</li> <li>Faster queries: Database optimization can apply</li> <li>Cleaner code: Intent is explicit</li> </ul>"},{"location":"tui-demo/field-selection/#limitations","title":"Limitations","text":""},{"location":"tui-demo/field-selection/#partial-objects","title":"Partial Objects","text":"<p>Fields that aren't selected will be <code>None</code>:</p> <pre><code>user = db.select(User).fields([\"name\"]).fetch_one()\nprint(user.name)    # Has value\nprint(user.email)   # None (not selected)\nprint(user.age)     # None (not selected)\n</code></pre>"},{"location":"tui-demo/field-selection/#updates","title":"Updates","text":"<p>Be careful when updating partially fetched objects:</p> <pre><code># Fetch only name\nuser = db.select(User).fields([\"name\"]).fetch_one()\nuser.name = \"New Name\"\n# user.email is None - don't call db.update() or you'll lose the email!\n</code></pre> <p>Warning</p> <p>Don't update partially fetched objects unless you're certain about the impact. Either fetch all fields first, or only update the fields you selected.</p>"},{"location":"tui-demo/field-selection/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/field-selection/#do","title":"DO","text":"<ul> <li>Select only the fields you need for display/processing</li> <li>Use field selection for API responses</li> <li>Consider memory usage for large datasets</li> </ul>"},{"location":"tui-demo/field-selection/#dont","title":"DON'T","text":"<ul> <li>Update partially fetched objects without understanding the impact</li> <li>Use field selection if you need to update the record later</li> <li>Forget that unselected fields will be <code>None</code></li> </ul>"},{"location":"tui-demo/field-selection/#related-documentation","title":"Related Documentation","text":"<ul> <li>Query Results - Fetch results in different ways</li> <li>Filtering - Filter which rows are returned</li> <li>CRUD Operations - Update and delete records</li> </ul>"},{"location":"tui-demo/filters/","title":"Filtering Demos","text":"<p>These demos show how to filter query results using various comparison operators.</p>"},{"location":"tui-demo/filters/#equal-to","title":"Equal To","text":"<p>Find records where a field exactly matches a value.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(name=\"Alice\", age=30))\ndb.insert(User(name=\"Bob\", age=25))\ndb.insert(User(name=\"Alice\", age=35))\n\nresults = db.select(User).filter(name__eq=\"Alice\").fetch_all()\nprint(f\"Found {len(results)} users named 'Alice':\")\nfor user in results:\n    print(f\"  - {user.name}, age {user.age}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#alternative-syntax","title":"Alternative Syntax","text":"<p><code>category=\"gadgets\"</code> works the same as <code>category__eq=\"gadgets\"</code>.</p>"},{"location":"tui-demo/filters/#not-equal-to","title":"Not Equal To","text":"<p>Find records where a field doesn't match a value.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n    status: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Item)\n\ndb.insert(Item(name=\"Item 1\", status=\"active\"))\ndb.insert(Item(name=\"Item 2\", status=\"archived\"))\ndb.insert(Item(name=\"Item 3\", status=\"active\"))\n\nresults = db.select(Item).filter(status__ne=\"archived\").fetch_all()\nprint(f\"Non-archived items: {len(results)}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#greater-than-less-than","title":"Greater Than / Less Than","text":"<p>Filter numeric fields using comparison operators.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\ndb.insert(Product(name=\"Item A\", price=10.0))\ndb.insert(Product(name=\"Item B\", price=20.0))\ndb.insert(Product(name=\"Item C\", price=30.0))\n\n# Greater than\nexpensive = db.select(Product).filter(price__gt=15.0).fetch_all()\nprint(f\"Products &gt; $15: {len(expensive)}\")\n\n# Less than or equal\ncheap = db.select(Product).filter(price__lte=20.0).fetch_all()\nprint(f\"Products &lt;= $20: {len(cheap)}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#available-operators","title":"Available Operators","text":"Operator Description <code>__gt</code> Greater than <code>__lt</code> Less than <code>__gte</code> Greater than or equal <code>__lte</code> Less than or equal"},{"location":"tui-demo/filters/#in-list","title":"In List","text":"<p>Find records where a field matches any value in a list.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    status: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ndb.insert(Task(title=\"Task 1\", status=\"todo\"))\ndb.insert(Task(title=\"Task 2\", status=\"done\"))\ndb.insert(Task(title=\"Task 3\", status=\"in_progress\"))\ndb.insert(Task(title=\"Task 4\", status=\"done\"))\n\nresults = (\n    db.select(Task).filter(status__in=[\"todo\", \"in_progress\"]).fetch_all()\n)\nprint(f\"Active tasks: {len(results)}\")\nfor task in results:\n    print(f\"  - {task.title}: {task.status}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#when-to-use","title":"When to Use","text":"<ul> <li>Filtering by multiple possible values</li> <li>Checking membership in a set</li> <li>Simplifying multiple <code>OR</code> conditions</li> </ul>"},{"location":"tui-demo/filters/#null-checks","title":"Null Checks","text":"<p>Find records where a field is null (None) or not null.</p> <pre><code>from typing import Optional\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    assigned_to: Optional[str] = None\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ndb.insert(Task(title=\"Task 1\", assigned_to=\"Alice\"))\ndb.insert(Task(title=\"Task 2\", assigned_to=None))  # Unassigned\ndb.insert(Task(title=\"Task 3\", assigned_to=\"Bob\"))\ndb.insert(Task(title=\"Task 4\", assigned_to=None))  # Unassigned\n\n# Find unassigned tasks\nunassigned = db.select(Task).filter(assigned_to__isnull=True).fetch_all()\nprint(f\"Unassigned tasks: {len(unassigned)}\")\nfor task in unassigned:\n    print(f\"  - {task.title}\")\n\n# Find assigned tasks\nassigned = db.select(Task).filter(assigned_to__notnull=True).fetch_all()\nprint(f\"Assigned tasks: {len(assigned)}\")\nfor task in assigned:\n    print(f\"  - {task.title}: {task.assigned_to}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#null-vs-empty-string","title":"Null vs Empty String","text":"<ul> <li><code>None</code> (null): Field was never set</li> <li><code>\"\"</code> (empty string): Field was explicitly set to empty</li> <li>Use <code>__isnull</code> to check for <code>None</code></li> </ul>"},{"location":"tui-demo/filters/#chaining-filters","title":"Chaining Filters","text":"<p>Combine multiple filter conditions.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    city: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(name=\"Alice\", age=30, city=\"NYC\"))\ndb.insert(User(name=\"Bob\", age=25, city=\"LA\"))\ndb.insert(User(name=\"Charlie\", age=30, city=\"NYC\"))\n\nresults = (\n    db.select(User).filter(age__gte=30).filter(city__eq=\"NYC\").fetch_all()\n)\nprint(f\"Users in NYC aged 30+: {len(results)}\")\nfor user in results:\n    print(f\"  - {user.name}, {user.age}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/filters/#how-it-works","title":"How It Works","text":"<p>All filter conditions are combined with AND logic - only records matching ALL conditions are returned.</p>"},{"location":"tui-demo/filters/#alternative-one-line-syntax","title":"Alternative One-Line Syntax","text":"<pre><code>affordable = db.select(Product).filter(\n    price__lt=20.0,\n    stock__gte=50\n).fetch_all()\n</code></pre>"},{"location":"tui-demo/filters/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/filters/#do","title":"DO","text":"<ul> <li>Use specific filter operators (<code>__eq</code>, <code>__gt</code>, etc.) for clarity</li> <li>Chain filters when you have multiple conditions</li> <li>Use <code>__in</code> for checking multiple values instead of multiple <code>OR</code> conditions</li> </ul>"},{"location":"tui-demo/filters/#dont","title":"DON'T","text":"<ul> <li>Filter on non-indexed fields in large datasets (performance issue)</li> <li>Forget that text comparisons are case-sensitive</li> <li>Mix up <code>__gt</code> (greater than) with <code>__lt</code> (less than)</li> </ul>"},{"location":"tui-demo/filters/#related-documentation","title":"Related Documentation","text":"<ul> <li>String Filters - Special string matching operators</li> <li>Query Results - Fetch filtered results</li> <li>Ordering - Sort filtered results</li> </ul>"},{"location":"tui-demo/models/","title":"Model Definition Demos","text":"<p>These demos show how to define data models using Pydantic with SQLiter.</p>"},{"location":"tui-demo/models/#basic-model","title":"Basic Model","text":"<p>The simplest model definition with a primary key and string field.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nuser = db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\nprint(f\"Created user: {user.name}\")\nprint(f\"Primary key: {user.pk}\")\nprint(f\"Age: {user.age}\")\nprint(f\"Email: {user.email}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/models/#what-happens-automatically","title":"What Happens Automatically","text":"<ul> <li>Primary Key: <code>pk</code> field is automatically added as the primary key</li> <li>Table Name: Table name is automatically pluralized (<code>users</code> in this case)</li> <li>Type Conversion: Pydantic validates and converts types automatically</li> </ul>"},{"location":"tui-demo/models/#model-with-defaults","title":"Model with Defaults","text":"<p>Set default values for fields that are optional.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    completed: bool = False\n    priority: int = 1\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ntask = db.insert(Task(title=\"New task\"))\nprint(f\"Task: {task.title}\")\nprint(f\"Completed: {task.completed} (default)\")\nprint(f\"Priority: {task.priority} (default)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/models/#field-behavior","title":"Field Behavior","text":"<ul> <li>Fields with defaults are optional when inserting</li> <li>If not provided, the default value is used</li> <li>You can override defaults by explicitly passing values</li> </ul>"},{"location":"tui-demo/models/#auto-timestamps","title":"Auto Timestamps","text":"<p>Automatically track when records are created and last modified.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass Article(BaseDBModel):\n    \"\"\"Article with automatic timestamps.\"\"\"\n    title: str\n    content: str\n</code></pre>"},{"location":"tui-demo/models/#auto-generated-fields","title":"Auto-Generated Fields","text":"<ul> <li><code>created_at</code>: Unix timestamp set when the record is inserted</li> <li><code>updated_at</code>: Unix timestamp updated automatically when the record is modified</li> </ul> <p>Note: For practical examples of using timestamp fields in real scenarios, see the Auto Timestamps documentation.</p>"},{"location":"tui-demo/models/#field-types","title":"Field Types","text":"<p>SQLiter supports all Pydantic field types:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom datetime import datetime, timezone\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n    in_stock: bool\n    quantity: int\n    created_at: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\nproduct = db.insert(\n    Product(\n        name=\"Widget\",\n        price=19.99,\n        in_stock=True,\n        quantity=100,\n        created_at=int(datetime.now(timezone.utc).timestamp()),\n    ),\n)\nprint(f\"Product: {product.name}\")\nprint(f\"Price: ${product.price}\")\nprint(f\"In stock: {product.in_stock}\")\nprint(f\"Quantity: {product.quantity}\")\nprint(f\"Created: {product.created_at}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/models/#model-relationships","title":"Model Relationships","text":"<p>Define relationships between models using foreign keys.</p> <pre><code>from sqliter.model import BaseDBModel\nfrom sqliter.orm.foreign_key import ForeignKey\n\nclass Author(BaseDBModel):\n    \"\"\"An author of books.\"\"\"\n    name: str\n\nclass Book(BaseDBModel):\n    \"\"\"A book with a foreign key to Author.\"\"\"\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n</code></pre>"},{"location":"tui-demo/models/#complex-data-types","title":"Complex Data Types","text":"<p>Store lists, dicts, and other complex types in your models.</p> <pre><code>from typing import Union\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Document(BaseDBModel):\n    title: str\n    tags: list[str]\n    metadata: dict[str, Union[str, int]]\n\ndb = SqliterDB(memory=True)\ndb.create_table(Document)\n\ndoc = db.insert(\n    Document(\n        title=\"Guide\",\n        tags=[\"python\", \"database\", \"tutorial\"],\n        metadata={\"views\": 1000, \"rating\": 4},\n    ),\n)\nprint(f\"Document: {doc.title}\")\nprint(f\"Tags: {doc.tags}\")\nprint(f\"Metadata: {doc.metadata}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/models/#related-documentation","title":"Related Documentation","text":"<ul> <li>Database Connection - Connect to a database</li> <li>CRUD Operations - Create and manipulate records</li> <li>ORM Features - Work with model relationships</li> </ul>"},{"location":"tui-demo/ordering/","title":"Ordering Demos","text":"<p>These demos show how to sort query results.</p>"},{"location":"tui-demo/ordering/#order-by-single-field","title":"Order By Single Field","text":"<p>Sort results by a single field.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(name=\"Charlie\", age=35))\ndb.insert(User(name=\"Alice\", age=25))\ndb.insert(User(name=\"Bob\", age=30))\n\nresults = db.select(User).order(\"age\").fetch_all()\nprint(\"Users ordered by age (ascending):\")\nfor user in results:\n    print(f\"  - {user.name}: {user.age}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/ordering/#default-order","title":"Default Order","text":"<p>By default, <code>order()</code> sorts in ascending order (lowest to highest).</p>"},{"location":"tui-demo/ordering/#descending-order","title":"Descending Order","text":"<p>Sort results in reverse order.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    price: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\ndb.insert(Product(name=\"Item A\", price=10.0))\ndb.insert(Product(name=\"Item B\", price=30.0))\ndb.insert(Product(name=\"Item C\", price=20.0))\n\nresults = db.select(Product).order(\"price\", reverse=True).fetch_all()\nprint(\"Products ordered by price (descending):\")\nfor product in results:\n    print(f\"  - {product.name}: ${product.price}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/ordering/#descending-syntax","title":"Descending Syntax","text":"<p>Use <code>reverse=True</code> for descending order:</p> <ul> <li><code>order(\"price\")</code> \u2192 Ascending (low to high)</li> <li><code>order(\"price\", reverse=True)</code> \u2192 Descending (high to low)</li> <li><code>order(\"pk\")</code> \u2192 Oldest first</li> <li><code>order(\"pk\", reverse=True)</code> \u2192 Newest first</li> </ul>"},{"location":"tui-demo/ordering/#limit-results","title":"Limit Results","text":"<p>Limit the number of results returned for pagination.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Article(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Article)\n\nfor i in range(1, 11):\n    db.insert(Article(title=f\"Article {i}\"))\n\nresults = db.select(Article).limit(3).fetch_all()\nprint(\"Top 3 articles:\")\nfor article in results:\n    print(f\"  - {article.title}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/ordering/#use-cases","title":"Use Cases","text":"<ul> <li>Pagination: Display first page of results</li> <li>Previews: Show sample data</li> <li>Performance: Avoid loading too many records</li> </ul>"},{"location":"tui-demo/ordering/#offset-results-pagination","title":"Offset Results (Pagination)","text":"<p>Skip a specified number of results for pagination.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Item)\n\nfor i in range(1, 11):\n    db.insert(Item(name=f\"Item {i}\"))\n\nresults = db.select(Item).limit(5).offset(5).fetch_all()\nprint(\"Items 6-10:\")\nfor item in results:\n    print(f\"  - {item.name}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/ordering/#how-pagination-works","title":"How Pagination Works","text":"<ul> <li><code>offset(5)</code> skips the first 5 records</li> <li><code>limit(5)</code> takes the next 5 records</li> <li>Together they implement page 2 of a paginated result set</li> </ul>"},{"location":"tui-demo/ordering/#common-pattern","title":"Common Pattern","text":"<pre><code>page = 2\npage_size = 10\noffset_value = (page - 1) * page_size\n\nresults = db.select(User).limit(page_size).offset(offset_value).fetch_all()\n</code></pre>"},{"location":"tui-demo/ordering/#ordering-field-types","title":"Ordering Field Types","text":"<p>Different field types have different sort behaviors:</p>"},{"location":"tui-demo/ordering/#numbers","title":"Numbers","text":"<p>Sorted numerically: <code>1, 2, 10, 100</code></p>"},{"location":"tui-demo/ordering/#strings","title":"Strings","text":"<p>Sorted alphabetically: <code>\"Apple\", \"Banana\", \"Cherry\"</code></p>"},{"location":"tui-demo/ordering/#datestimestamps","title":"Dates/Timestamps","text":"<p>Sorted chronologically (oldest to newest for <code>created_at</code>)</p>"},{"location":"tui-demo/ordering/#booleans","title":"Booleans","text":"<p><code>False</code> (0) comes before <code>True</code> (1)</p>"},{"location":"tui-demo/ordering/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tui-demo/ordering/#indexes","title":"Indexes","text":"<p>Ordering by indexed fields is much faster:</p> <pre><code>from sqliter.model.unique import unique\n\nclass User(BaseDBModel):\n    username: str = unique()  # Indexed\n    age: int  # Not indexed\n\n# Fast: Uses index\ndb.select(User).order(\"username\").fetch_all()\n\n# Slower: Requires full table scan\ndb.select(User).order(\"age\").fetch_all()\n</code></pre>"},{"location":"tui-demo/ordering/#large-result-sets","title":"Large Result Sets","text":"<p>Ordering requires the database to process all matching records before returning results.</p>"},{"location":"tui-demo/ordering/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/ordering/#do","title":"DO","text":"<ul> <li>Order by indexed fields for better performance</li> <li>Use descending order (<code>reverse=True</code>) for \"newest first\" queries</li> <li>Combine with <code>limit()</code> for pagination on large datasets</li> </ul>"},{"location":"tui-demo/ordering/#dont","title":"DON'T","text":"<ul> <li>Order by fields you don't need to sort by</li> <li>Forget that string sorting is case-sensitive</li> <li>Order large result sets without pagination</li> </ul>"},{"location":"tui-demo/ordering/#related-documentation","title":"Related Documentation","text":"<ul> <li>Query Results - Fetch and paginate results</li> <li>Filtering - Filter records before ordering</li> <li>Field Selection - Control which fields are returned</li> </ul>"},{"location":"tui-demo/orm/","title":"ORM Features Demos","text":"<p>These demos show advanced ORM features including foreign keys and relationships.</p>"},{"location":"tui-demo/orm/#foreign-key-basics","title":"Foreign Key Basics","text":"<p>Link records from different tables using foreign keys.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"J.K. Rowling\"))\nbook1 = db.insert(Book(title=\"Harry Potter 1\", author=author))\nbook2 = db.insert(Book(title=\"Harry Potter 2\", author=author))\n\nprint(f\"Author: {author.name}\")\nprint(f\"Author ID: {author.pk}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-happens","title":"What Happens","text":"<ul> <li><code>author</code> field stores the primary key of the Author</li> <li>Database creates a foreign key constraint</li> <li>Referential integrity is enforced</li> </ul>"},{"location":"tui-demo/orm/#nullable-foreign-keys","title":"Nullable Foreign Keys","text":"<p>Declare nullable FKs using <code>Optional[T]</code> or <code>T | None</code> in the type annotation. SQLiter auto-detects nullability from the annotation.</p> <pre><code>from typing import Optional\n\nfrom sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Optional[Author]] = ForeignKey(\n        Author, on_delete=\"SET NULL\", null=True\n    )\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"Jane Austen\"))\nbook_with = db.insert(Book(title=\"Pride and Prejudice\", author=author))\nbook_without = db.insert(Book(title=\"Anonymous Work\", author=None))\n\nbook1 = db.get(Book, book_with.pk)\nbook2 = db.get(Book, book_without.pk)\n\nif book1 is not None:\n    author_name = book1.author.name if book1.author else \"None\"\n    print(f\"'{book1.title}' author: {author_name}\")\nif book2 is not None:\n    print(f\"'{book2.title}' author: {book2.author}\")\n\nprint(\"\\nOptional[Author] auto-sets null=True on the FK column\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-happens_1","title":"What Happens","text":"<ul> <li><code>ForeignKey[Optional[Author]]</code> tells SQLiter the FK column is nullable</li> <li>Books can be inserted with <code>author=None</code></li> <li>Accessing a null FK returns <code>None</code> instead of a model instance</li> <li>The explicit <code>null=True</code> parameter still works, but the annotation approach   is preferred</li> <li>This demo uses <code>ForeignKey[Optional[Author]]</code>, but annotation-based   nullability is most reliable when ORM models are defined at module scope   (especially with type aliases). Use <code>null=True</code> explicitly for local models   when you need guaranteed behavior.</li> </ul>"},{"location":"tui-demo/orm/#inserting-with-foreign-keys","title":"Inserting with Foreign Keys","text":"<p>Create records linked to other records.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"Jane Austen\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author=author))\n\nprint(\"Created book:\")\nprint(f\"  title: {book.title}\")\nprint(f\"  author: {book.author.name}\")\nprint(\"\\nForeign key stores the primary key internally, but access returns the object\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#storage-vs-access","title":"Storage vs Access","text":"<ul> <li>Storage: The <code>author</code> field stores only the primary key (integer)</li> <li>Access: When you access <code>book.author</code>, lazy loading fetches the full Author object</li> <li>This dual behavior lets you store efficiently but access conveniently</li> </ul>"},{"location":"tui-demo/orm/#lazy-loading","title":"Lazy Loading","text":"<p>Access related objects on-demand.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"J.K. Rowling\"))\nbook1 = db.insert(Book(title=\"Harry Potter 1\", author=author))\nbook2 = db.insert(Book(title=\"Harry Potter 2\", author=author))\n\nprint(f\"Author: {author.name}\")\nprint(f\"Author ID: {author.pk}\")\n\n# Access related author through foreign key - triggers lazy load\nprint(\"\\nAccessing book.author triggers lazy load:\")\nprint(f\"  '{book1.title}' was written by {book1.author.name}\")\n\nprint(f\"\\n'{book2.title}' was written by {book2.author.name}\")\nprint(\"Related objects loaded on-demand from database\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#how-lazy-loading-works","title":"How Lazy Loading Works","text":"<ol> <li>Book object is fetched with just <code>author.pk</code> stored</li> <li>When you access <code>book.author.name</code>, SQLiter queries the Author table</li> <li>Full Author object is loaded and cached</li> </ol>"},{"location":"tui-demo/orm/#performance-consideration","title":"Performance Consideration","text":"<ul> <li>Pro: Only loads related data when needed</li> <li>Con: N+1 query problem if iterating many records</li> </ul> <pre><code># Potential N+1 problem\nbooks = db.select(Book).fetch_all()\nfor book in books:  # N queries here (one per book)\n    print(book.author.name)\n</code></pre>"},{"location":"tui-demo/orm/#eager-loading-with-select_related","title":"Eager Loading with select_related()","text":"<p>Solve the N+1 problem by fetching related objects in a single JOIN query.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert test data\nauthor1 = db.insert(Author(name=\"Jane Austen\"))\nauthor2 = db.insert(Author(name=\"Charles Dickens\"))\n\ndb.insert(Book(title=\"Pride and Prejudice\", author=author1))\ndb.insert(Book(title=\"Emma\", author=author1))\ndb.insert(Book(title=\"Oliver Twist\", author=author2))\n\n# Eager load - single JOIN query\nprint(\"Fetching books with eager loading:\")\nbooks = db.select(Book).select_related(\"author\").fetch_all()\n\nfor book in books:\n    print(f\"  '{book.title}' by {book.author.name}\")\n\nprint(\"\\nAll authors loaded in single query (no N+1 problem)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-happens_2","title":"What Happens","text":"<ol> <li><code>select_related(\"author\")</code> tells SQLiter to include Author data in the initial query</li> <li>A JOIN fetches both Book and Author data in a single database call</li> <li>All related objects are preloaded and cached, avoiding the N+1 problem</li> </ol>"},{"location":"tui-demo/orm/#when-to-use-eager-loading","title":"When to Use Eager Loading","text":"<ul> <li>Use when you know you'll access related objects</li> <li>Use when iterating over multiple records with relationships</li> <li>Don't use if you only need the parent records</li> </ul>"},{"location":"tui-demo/orm/#performance-comparison","title":"Performance Comparison","text":"<pre><code># Without select_related - N+1 queries (1 for books + N for authors)\nbooks = db.select(Book).fetch_all()  # 1 query\nfor book in books:\n    print(book.author.name)  # N queries (one per book)\n\n# With select_related - 1 query total\nbooks = db.select(Book).select_related(\"author\").fetch_all()  # 1 query with JOIN\nfor book in books:\n    print(book.author.name)  # No additional queries\n</code></pre>"},{"location":"tui-demo/orm/#nested-relationship-loading","title":"Nested Relationship Loading","text":"<p>Load multiple levels of relationships using double underscore syntax.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\nclass Comment(BaseDBModel):\n    text: str\n    book: ForeignKey[Book] = ForeignKey(Book)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\ndb.create_table(Comment)\n\n# Insert nested test data\nauthor = db.insert(Author(name=\"Jane Austen\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author=author))\ndb.insert(Comment(text=\"Amazing book!\", book=book))\n\n# Load nested relationship - single query joins Comment -&gt; Book -&gt; Author\nprint(\"Loading nested relationships:\")\ncomment = db.select(Comment).select_related(\"book__author\").fetch_one()\n\nif comment is not None:\n    print(f\"Comment: {comment.text}\")\n    print(f\"Book: {comment.book.title}\")\n    # Access author through book's foreign key relationship\n    # Both book and author were loaded in a single JOIN query\n    print(f\"Author: {comment.book.author.name}\")\n\nprint(\"\\nNested relationships loaded in single query\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#how-nested-loading-works","title":"How Nested Loading Works","text":"<ol> <li>Use double underscores (<code>__</code>) to traverse relationship paths</li> <li><code>select_related(\"book__author\")</code> loads: Comment \u2192 Book \u2192 Author</li> <li>Creates a chain of JOINs in a single query</li> <li>All related objects are accessible without additional database hits</li> </ol>"},{"location":"tui-demo/orm/#relationship-paths","title":"Relationship Paths","text":"<pre><code># Single level\nselect_related(\"author\")  # Loads immediate parent\n\n# Two levels\nselect_related(\"book__author\")  # Loads grandparent\n\n# Multiple paths (comma-separated)\nselect_related(\"author\", \"publisher\")  # Loads multiple relationships\n\n# Deep nesting (3+ levels)\nselect_related(\"comment__book__author__country\")\n</code></pre>"},{"location":"tui-demo/orm/#many-to-many-basics","title":"Many-to-Many Basics","text":"<p>Relate records through a junction table and use reverse accessors.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ManyToMany\n\nclass Tag(BaseDBModel):\n    name: str\n\nclass Article(BaseDBModel):\n    title: str\n    tags: ManyToMany[Tag] = ManyToMany(Tag, related_name=\"articles\")\n\ndb = SqliterDB(memory=True)\ndb.create_table(Tag)\ndb.create_table(Article)\n\narticle = db.insert(Article(title=\"ORM Guide\"))\npython = db.insert(Tag(name=\"python\"))\norm = db.insert(Tag(name=\"orm\"))\n\narticle.tags.add(python, orm)\nfor tag in article.tags.fetch_all():\n    print(tag.name)\n\nfor entry in python.articles.fetch_all():\n    print(entry.title)\n\ndb.close()\n</code></pre> <p>Type checkers and reverse accessors</p> <p>Reverse accessors are injected dynamically at runtime, so tools like mypy cannot infer their type automatically. If you want strict typing, use <code>cast()</code> at the call site:</p> <pre><code>from typing import Any, cast\n\nentries = cast(\"Any\", python.articles).fetch_all()\n</code></pre>"},{"location":"tui-demo/orm/#symmetrical-self-referential-m2m","title":"Symmetrical Self-Referential M2M","text":"<p>Use <code>symmetrical=True</code> for self-referential relationships.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ManyToMany\n\nclass User(BaseDBModel):\n    name: str\n    friends: ManyToMany[User] = ManyToMany(\"User\", symmetrical=True)\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nalice = db.insert(User(name=\"Alice\"))\nbob = db.insert(User(name=\"Bob\"))\n\nalice.friends.add(bob)\n\nprint([u.name for u in alice.friends.fetch_all()])\nprint([u.name for u in bob.friends.fetch_all()])\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#relationship-filter-traversal","title":"Relationship Filter Traversal","text":"<p>Filter records by fields on related models using double underscore syntax.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert test data\nauthor1 = db.insert(Author(name=\"Jane Austen\"))\nauthor2 = db.insert(Author(name=\"Charles Dickens\"))\n\ndb.insert(Book(title=\"Pride and Prejudice\", author=author1))\ndb.insert(Book(title=\"Emma\", author=author1))\ndb.insert(Book(title=\"Oliver Twist\", author=author2))\ndb.insert(Book(title=\"Great Expectations\", author=author2))\n\n# Filter by related field\nprint(\"Filtering by author name:\")\nbooks = db.select(Book).filter(author__name=\"Jane Austen\").fetch_all()\n\nfor book in books:\n    print(f\"  {book.title}\")\n\nprint(f\"\\nFound {len(books)} book(s) by Jane Austen\")\nprint(\"(Automatic JOIN added behind the scenes)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#how-filter-traversal-works","title":"How Filter Traversal Works","text":"<ol> <li>Use <code>__</code> to access fields on related models: <code>author__name</code></li> <li>SQLiter automatically creates JOINs to traverse relationships</li> <li>Filter is applied in SQL, not in Python</li> <li>Works with most filter operators (note: <code>__isnull</code>/<code>__notnull</code>    are not applied via relationship traversal)</li> </ol>"},{"location":"tui-demo/orm/#filter-operators-on-relationships","title":"Filter Operators on Relationships","text":"<pre><code># Exact match\n.filter(author__name=\"Jane Austen\")\n\n# Comparison operators\n.filter(author__age__gte=30)\n\n# String operators\n.filter(author__name__startswith=\"Jane\")\n.filter(author__name__contains=\"en\")\n\n# Multiple conditions\n.filter(author__name=\"Jane Austen\", year__gt=1800)\n</code></pre>"},{"location":"tui-demo/orm/#combining-select_related-with-filters","title":"Combining select_related with Filters","text":"<p>Use eager loading and relationship filters together for optimal performance.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    year: int\n    author: ForeignKey[Author] = ForeignKey(Author)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert test data\nauthor1 = db.insert(Author(name=\"Jane Austen\"))\nauthor2 = db.insert(Author(name=\"Charles Dickens\"))\n\ndb.insert(Book(title=\"Pride and Prejudice\", year=1813, author=author1))\ndb.insert(Book(title=\"Emma\", year=1815, author=author1))\ndb.insert(Book(title=\"Oliver Twist\", year=1838, author=author2))\n\n# Combine filter + eager load\nprint(\"Filter and eager load in single query:\")\nbooks = (\n    db.select(Book)\n    .select_related(\"author\")\n    .filter(author__name__startswith=\"Jane\")\n    .fetch_all()\n)\n\nfor book in books:\n    print(f\"  {book.title} ({book.year}) by {book.author.name}\")\n\nprint(f\"\\n{len(books)} result(s) with authors preloaded\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#why-combine-them","title":"Why Combine Them?","text":"<ul> <li>Filter: Reduces result set at the database level</li> <li>select_related: Preloads relationships for filtered results</li> <li>Together: Optimal performance - minimal data transfer, no N+1 queries</li> </ul>"},{"location":"tui-demo/orm/#query-builder-chaining","title":"Query Builder Chaining","text":"<pre><code># Build complex queries step by step\nquery = (\n    db.select(Book)\n    .select_related(\"author\")  # Eager load\n    .filter(author__name=\"Jane Austen\")  # Filter by related field\n    .filter(year__gte=1800)  # Additional filter\n    .order(\"year\")  # Sort results\n)\n\nresults = query.fetch_all()\n</code></pre>"},{"location":"tui-demo/orm/#best-practices","title":"Best Practices","text":"<pre><code># Both examples produce identical SQL - QueryBuilder composes\n# the query regardless of method chaining order\nbooks = (\n    db.select(Book)\n    .filter(author__name=\"Jane Austen\")\n    .select_related(\"author\")\n    .fetch_all()\n)\n\n# Equivalent to the above - same SQL, same performance\nbooks = (\n    db.select(Book)\n    .select_related(\"author\")\n    .filter(author__name=\"Jane Austen\")\n    .fetch_all()\n)\n</code></pre>"},{"location":"tui-demo/orm/#performance-tips","title":"Performance Tips","text":"<ol> <li>Apply filters to limit rows returned - reduces data transfer</li> <li>Select only needed relationships - avoid unused data</li> <li>Combine with ordering - sort at database level</li> <li>Use pagination - limit results with <code>.limit()</code> and <code>.offset()</code></li> </ol> <pre><code># Optimal query pattern\nresults = (\n    db.select(Model)\n    .filter(relationship__field=\"value\")\n    .select_related(\"relationship\")\n    .order(\"field\")  # Sort in database\n    .limit(10)\n    .fetch_all()\n)\n</code></pre>"},{"location":"tui-demo/orm/#reverse-relationships","title":"Reverse Relationships","text":"<p>Access all books by an author using queries.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, related_name=\"books\")\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\nauthor = db.insert(Author(name=\"Jane Austen\"))\ndb.insert(Book(title=\"Pride and Prejudice\", author=author))\ndb.insert(Book(title=\"Emma\", author=author))\ndb.insert(Book(title=\"Sense and Sensibility\", author=author))\n\nprint(f\"Author: {author.name}\")\n\n# Access reverse relationship - get all books by this author\n# Note: 'books' attribute added dynamically by ForeignKey descriptor\nprint(\"\\nAccessing author.books (reverse relationship):\")\nreverse_attr = \"books\"  # Dynamic attribute added by FK descriptor\nbooks_query = getattr(author, reverse_attr)\nbooks = books_query.fetch_all()\nfor book in books:\n    print(f\"  - {book.title}\")\n\nprint(f\"\\nTotal books: {len(books)}\")\nprint(\"Reverse relationships auto-generated from FKs\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#setting-up-reverse-relationships","title":"Setting Up Reverse Relationships","text":"<p>Use the <code>related_name</code> parameter when defining the ForeignKey:</p> <pre><code>class Book(BaseDBModel):\n    author: ForeignKey[Author] = ForeignKey(Author, related_name=\"books\")\n</code></pre> <p>The reverse relationship is dynamically added and accessed as a query builder.</p>"},{"location":"tui-demo/orm/#navigating-with-foreign-keys","title":"Navigating with Foreign Keys","text":"<p>Navigate from child records to parent records using foreign keys.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Team(BaseDBModel):\n    name: str\n\nclass Player(BaseDBModel):\n    name: str\n    team: ForeignKey[Team] = ForeignKey(Team)\n\ndb = SqliterDB(memory=True)\ndb.create_table(Team)\ndb.create_table(Player)\n\nteam = db.insert(Team(name=\"Lakers\"))\nplayer1 = db.insert(Player(name=\"LeBron\", team=team))\nplayer2 = db.insert(Player(name=\"Davis\", team=team))\n\nprint(f\"Team: {team.name}\")\n\n# Navigate from player to team via FK\nprint(f\"\\n{player1.name} plays for: {player1.team.name}\")\nprint(f\"{player2.name} plays for: {player2.team.name}\")\nprint(\"Foreign keys enable relationship navigation\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-this-shows","title":"What This Shows","text":"<ul> <li>Child objects (Player) can access parent objects (Team) via FK</li> <li>Lazy loading fetches the Team when you access <code>player.team</code></li> <li>No need to manually query the parent table</li> </ul>"},{"location":"tui-demo/orm/#note-on-constraints","title":"Note on Constraints","text":"<p>By default, SQLite doesn't enforce foreign key constraints for backwards compatibility. However, SQLiter automatically enables foreign key enforcement on every database connection, so you don't need to manually set <code>PRAGMA foreign_keys = ON</code>.</p>"},{"location":"tui-demo/orm/#prefetch-reverse-fk-relationships","title":"Prefetch Reverse FK Relationships","text":"<p>Eager load reverse FK relationships with <code>prefetch_related()</code>.</p> <pre><code>from typing import Any, cast\n\nfrom sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n\nclass Book(BaseDBModel):\n    title: str\n    author: ForeignKey[Author] = ForeignKey(Author, related_name=\"books\")\n\ndb = SqliterDB(memory=True)\ndb.create_table(Author)\ndb.create_table(Book)\n\na1 = db.insert(Author(name=\"Jane Austen\"))\na2 = db.insert(Author(name=\"Charles Dickens\"))\ndb.insert(Book(title=\"Pride and Prejudice\", author=a1))\ndb.insert(Book(title=\"Emma\", author=a1))\ndb.insert(Book(title=\"Oliver Twist\", author=a2))\n\n# 2 queries total: one for authors, one for all their books\nauthors = db.select(Author).prefetch_related(\"books\").fetch_all()\n\nfor author in authors:\n    books = cast(\"Any\", author).books.fetch_all()\n    titles = \", \".join(b.title for b in books)\n    print(f\"{author.name}: {titles}\")\n\nprint(\"\\nAll data loaded in 2 queries (no N+1 problem)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-happens_3","title":"What Happens","text":"<ol> <li><code>prefetch_related(\"books\")</code> tells SQLiter to preload the reverse FK</li> <li>The main query fetches all Authors</li> <li>A second query fetches all Books whose <code>author</code> FK matches any of    the returned Author PKs</li> <li>Results are grouped and cached on each Author instance</li> </ol>"},{"location":"tui-demo/orm/#select_related-vs-prefetch_related","title":"<code>select_related</code> vs <code>prefetch_related</code>","text":"Method Direction Strategy Best For <code>select_related()</code> Forward FK (<code>book.author</code>) JOIN Parent lookups <code>prefetch_related()</code> Reverse FK (<code>author.books</code>) 2nd query Child collections"},{"location":"tui-demo/orm/#prefetch-m2m-relationships","title":"Prefetch M2M Relationships","text":"<p>Eager load many-to-many relationships with <code>prefetch_related()</code>.</p> <pre><code>from typing import Any, cast\n\nfrom sqliter import SqliterDB\nfrom sqliter.orm import BaseDBModel, ManyToMany\n\nclass Tag(BaseDBModel):\n    name: str\n\nclass Article(BaseDBModel):\n    title: str\n    tags: ManyToMany[Tag] = ManyToMany(Tag, related_name=\"articles\")\n\ndb = SqliterDB(memory=True)\ndb.create_table(Tag)\ndb.create_table(Article)\n\npython = db.insert(Tag(name=\"python\"))\nsqlite = db.insert(Tag(name=\"sqlite\"))\norm_tag = db.insert(Tag(name=\"orm\"))\n\na1 = db.insert(Article(title=\"SQLiter Guide\"))\na2 = db.insert(Article(title=\"Python Tips\"))\n\na1.tags.add(python, sqlite, orm_tag)\na2.tags.add(python)\n\n# Prefetch tags for all articles (forward M2M)\narticles = db.select(Article).prefetch_related(\"tags\").fetch_all()\n\nprint(\"Articles with prefetched tags:\")\nfor article in articles:\n    tags = article.tags.fetch_all()\n    tag_names = \", \".join(t.name for t in tags)\n    print(f\"  {article.title}: [{tag_names}]\")\n\n# Reverse: prefetch articles for tags\ntags = db.select(Tag).prefetch_related(\"articles\").fetch_all()\n\nprint(\"\\nTags with prefetched articles:\")\nfor tag in tags:\n    entries = cast(\"Any\", tag).articles.fetch_all()\n    entry_titles = \", \".join(e.title for e in entries)\n    count = cast(\"Any\", tag).articles.count()\n    print(f\"  {tag.name}: {count} article(s) [{entry_titles}]\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/orm/#what-happens_4","title":"What Happens","text":"<ol> <li>Forward M2M (<code>article.tags</code>): queries the junction table + Tag    table in a single extra query, caching tags on each Article</li> <li>Reverse M2M (<code>tag.articles</code>): same approach from the other side,    querying junction table + Article table</li> <li>Cached data is served from memory \u2014 <code>fetch_all()</code>, <code>count()</code>, and    <code>exists()</code> do not hit the database again</li> <li>Write operations (<code>add</code>, <code>remove</code>, <code>clear</code>, <code>set</code>) still go through    the database and update the cache</li> </ol>"},{"location":"tui-demo/orm/#combining-with-other-methods","title":"Combining with Other Methods","text":"<pre><code># prefetch_related chains with filter, order, limit, and select_related\nresults = (\n    db.select(Article)\n    .filter(title__contains=\"Guide\")\n    .prefetch_related(\"tags\")\n    .order(\"title\")\n    .fetch_all()\n)\n</code></pre>"},{"location":"tui-demo/orm/#orm-best-practices","title":"ORM Best Practices","text":""},{"location":"tui-demo/orm/#do","title":"DO","text":"<ul> <li>Use foreign keys to link related data</li> <li>Use <code>select_related()</code> for forward FK eager loading (parent lookups)</li> <li>Use <code>prefetch_related()</code> for reverse FK and M2M eager loading</li> <li>Filter by relationship fields using double underscore syntax</li> <li>Combine eager loading with filters for optimal performance</li> <li>Consider query count when iterating over related objects</li> </ul>"},{"location":"tui-demo/orm/#dont","title":"DON'T","text":"<ul> <li>Forget that ForeignKey stores the pk, not the object</li> <li>Create circular foreign key relationships</li> <li>Delete parent records without handling children</li> <li>Use lazy loading in loops (causes N+1 queries)</li> <li>Eager load relationships you won't access</li> <li>Use <code>select_related()</code> for reverse relationships (use   <code>prefetch_related()</code> instead)</li> </ul>"},{"location":"tui-demo/orm/#performance-checklist","title":"Performance Checklist","text":"<ul> <li>[ ] Will I access a parent object? Use <code>select_related()</code></li> <li>[ ] Will I access child collections or M2M? Use <code>prefetch_related()</code></li> <li>[ ] Am I filtering by related fields? Use <code>__</code> syntax</li> <li>[ ] Am I iterating over results? Preload relationships</li> <li>[ ] Can I filter before eager loading? Order operations for efficiency</li> </ul>"},{"location":"tui-demo/orm/#related-documentation","title":"Related Documentation","text":"<ul> <li>Models - Define your data models</li> <li>CRUD Operations - Create and manipulate records</li> <li>Query Results - Fetch related records</li> <li>Filters - Advanced filtering techniques</li> <li>Foreign Keys Guide - Complete ORM reference</li> </ul>"},{"location":"tui-demo/results/","title":"Query Results Demos","text":"<p>These demos show different ways to fetch query results.</p>"},{"location":"tui-demo/results/#fetch-one","title":"Fetch One","text":"<p>Get a single record from a query.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Task(BaseDBModel):\n    title: str\n    priority: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ndb.insert(Task(title=\"High priority\", priority=1))\ndb.insert(Task(title=\"Medium priority\", priority=2))\ndb.insert(Task(title=\"Low priority\", priority=3))\n\ntask = db.select(Task).filter(priority__eq=1).fetch_one()\nif task is not None:\n    print(f\"Single result: {task.title}\")\n\n# Also test no results case\nno_task = db.select(Task).filter(priority__eq=999).fetch_one()\nif no_task is None:\n    print(\"No task found with priority 999\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/results/#when-no-results","title":"When No Results","text":"<p>Returns <code>None</code> if no records match the query.</p>"},{"location":"tui-demo/results/#use-cases","title":"Use Cases","text":"<ul> <li>Find specific user: When you expect only one result</li> <li>Get first match: When you only need the first record</li> <li>Existence checks: Quick check if any records match</li> </ul>"},{"location":"tui-demo/results/#fetch-all","title":"Fetch All","text":"<p>Get all matching records.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nfor i in range(5):\n    db.insert(User(name=f\"User {i}\", age=20 + i))\n\nresults = db.select(User).fetch_all()\nprint(f\"Total users: {len(results)}\")\nfor user in results:\n    print(f\"  - {user.name}, age {user.age}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/results/#return-type","title":"Return Type","text":"<p>Returns a list of model instances. Empty list if no results.</p>"},{"location":"tui-demo/results/#memory-consideration","title":"Memory Consideration","text":"<p>Be careful with large result sets - all records are loaded into memory.</p>"},{"location":"tui-demo/results/#fetch-first-limit-results","title":"Fetch First / Limit Results","text":"<p>Get only the first N records (pagination).</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Item)\n\nfor name in [\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"]:\n    db.insert(Item(name=name))\n\nfirst = db.select(Item).fetch_first()\nif first is not None:\n    print(f\"First: {first.name}\")\n\nlast = db.select(Item).fetch_last()\nif last is not None:\n    print(f\"Last: {last.name}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/results/#use-cases_1","title":"Use Cases","text":"<ul> <li>Pagination: Show first page of results</li> <li>Previews: Display sample data</li> <li>Limit load: Prevent loading too many records</li> </ul>"},{"location":"tui-demo/results/#count-results","title":"Count Results","text":"<p>Count matching records without fetching them.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n    category: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\ndb.insert(Product(name=\"Laptop\", category=\"electronics\"))\ndb.insert(Product(name=\"Phone\", category=\"electronics\"))\ndb.insert(Product(name=\"Desk\", category=\"furniture\"))\n\ntotal = db.select(Product).count()\nprint(f\"Total products: {total}\")\n\nelectronics = db.select(Product).filter(category__eq=\"electronics\").count()\nprint(f\"Electronics: {electronics}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/results/#benefits","title":"Benefits","text":"<ul> <li>Fast: Database counts without transferring data</li> <li>Memory efficient: No records loaded into memory</li> <li>Statistics: Quick counts for dashboards</li> </ul>"},{"location":"tui-demo/results/#exists-check","title":"Exists Check","text":"<p>Check if any records match without fetching them.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    username: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(username=\"alice\"))\ndb.insert(User(username=\"bob\"))\n\nexists = db.select(User).filter(username__eq=\"alice\").exists()\nprint(f\"User 'alice' exists: {exists}\")\n\nnot_exists = db.select(User).filter(username__eq=\"charlie\").exists()\nprint(f\"User 'charlie' exists: {not_exists}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/results/#use-cases_2","title":"Use Cases","text":"<ul> <li>Validation: Check if username/email already exists</li> <li>Conditional logic: Branch based on existence</li> <li>Fast checks: Quicker than fetching the actual record</li> </ul>"},{"location":"tui-demo/results/#comparison-table","title":"Comparison Table","text":"Method Returns Use When <code>fetch_one()</code> Single record or <code>None</code> You need exactly one record <code>fetch_all()</code> List of records (all) You need all matching records <code>limit(n).fetch_all()</code> List of records (max n) Pagination, limiting results <code>count()</code> Integer count Statistics, validation <code>exists()</code> Boolean Quick existence check"},{"location":"tui-demo/results/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tui-demo/results/#large-datasets","title":"Large Datasets","text":"<pre><code># \u274c BAD: Loads all records into memory\nall_users = db.select(User).fetch_all()\n\n# \u2705 GOOD: Process in batches using limit and offset\noffset = 0\nbatch_size = 100\nwhile True:\n    batch = db.select(User).limit(batch_size).offset(offset).fetch_all()\n    if not batch:\n        break\n    for user in batch:\n        process(user)\n    offset += batch_size\n</code></pre>"},{"location":"tui-demo/results/#counting","title":"Counting","text":"<pre><code># \u274c BAD: Counts in Python (slow)\ncount = len(db.select(User).fetch_all())\n\n# \u2705 GOOD: Count in database (fast)\ncount = db.select(User).count()\n</code></pre>"},{"location":"tui-demo/results/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/results/#do","title":"DO","text":"<ul> <li>Use <code>fetch_one()</code> when you expect a single result</li> <li>Use <code>count()</code> for statistics instead of counting in Python</li> <li>Use <code>limit()</code> with <code>offset()</code> for pagination</li> <li>Check for <code>None</code> when using <code>fetch_one()</code></li> </ul>"},{"location":"tui-demo/results/#dont","title":"DON'T","text":"<ul> <li>Use <code>fetch_all()</code> on potentially huge datasets</li> <li>Count results with <code>len()</code> - use <code>count()</code> instead</li> <li>Forget that <code>fetch_one()</code> returns <code>None</code> if no results</li> </ul>"},{"location":"tui-demo/results/#related-documentation","title":"Related Documentation","text":"<ul> <li>Filtering - Filter which records are returned</li> <li>Ordering - Sort results before fetching</li> <li>Field Selection - Control which fields are returned</li> </ul>"},{"location":"tui-demo/string-filters/","title":"String Filter Demos","text":"<p>These demos show special filtering operators for string fields.</p>"},{"location":"tui-demo/string-filters/#starts-with","title":"Starts With","text":"<p>Find strings that begin with a specific prefix.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    username: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(username=\"alice_wonder\"))\ndb.insert(User(username=\"alice_smith\"))\ndb.insert(User(username=\"bob_builder\"))\n\n# Find usernames starting with \"alice\"\nresults = db.select(User).filter(username__startswith=\"alice\").fetch_all()\nprint(f\"Users starting with 'alice': {len(results)}\")\nfor user in results:\n    print(f\"  - {user.username}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/string-filters/#use-cases","title":"Use Cases","text":"<ul> <li>Prefix matching: Find items with a specific code prefix</li> <li>Name filtering: Find users whose names start with certain letters</li> <li>Category browsing: Filter products by category prefix</li> </ul>"},{"location":"tui-demo/string-filters/#ends-with","title":"Ends With","text":"<p>Find strings that end with a specific suffix.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass File(BaseDBModel):\n    filename: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(File)\n\ndb.insert(File(filename=\"document.txt\"))\ndb.insert(File(filename=\"image.png\"))\ndb.insert(File(filename=\"notes.txt\"))\ndb.insert(File(filename=\"data.csv\"))\n\n# Find files ending with \".txt\"\nresults = db.select(File).filter(filename__endswith=\".txt\").fetch_all()\nprint(f\"Text files: {len(results)}\")\nfor file in results:\n    print(f\"  - {file.filename}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/string-filters/#use-cases_1","title":"Use Cases","text":"<ul> <li>File extensions: Filter by file type</li> <li>Domain matching: Find emails from a specific domain</li> <li>Suffix filtering: Items ending in specific codes</li> </ul>"},{"location":"tui-demo/string-filters/#contains","title":"Contains","text":"<p>Find strings that contain a specific substring.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Product(BaseDBModel):\n    name: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Product)\n\ndb.insert(Product(name=\"Apple iPhone\"))\ndb.insert(Product(name=\"Samsung Galaxy\"))\ndb.insert(Product(name=\"Apple iPad\"))\ndb.insert(Product(name=\"Google Pixel\"))\n\n# Find products containing \"Apple\"\nresults = db.select(Product).filter(name__contains=\"Apple\").fetch_all()\nprint(f\"Products containing 'Apple': {len(results)}\")\nfor product in results:\n    print(f\"  - {product.name}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/string-filters/#use-cases_2","title":"Use Cases","text":"<ul> <li>Search functionality: Full-text search in descriptions</li> <li>Keyword matching: Find items with specific keywords</li> <li>Pattern matching: Flexible string matching</li> </ul>"},{"location":"tui-demo/string-filters/#case-insensitive-matching","title":"Case-Insensitive Matching","text":"<p>Perform string filtering that ignores case.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    email: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\ndb.insert(User(email=\"ALICE@example.com\"))\ndb.insert(User(email=\"bob@EXAMPLE.com\"))\ndb.insert(User(email=\"charlie@test.com\"))\n\n# Find emails ending with \"@example.com\" (case-insensitive)\nresults = (\n    db.select(User).filter(email__iendswith=\"@example.com\").fetch_all()\n)\nprint(f\"Emails ending with '@example.com': {len(results)}\\n\")\nfor user in results:\n    print(f\"  - {user.email}\\n\")\n\n# Find emails starting with \"BOB\" (case-insensitive)\nbob_results = db.select(User).filter(email__istartswith=\"BOB\").fetch_all()\nprint(f\"\\nEmails starting with 'BOB': {len(bob_results)}\\n\")\nfor user in bob_results:\n    print(f\"  - {user.email}\\n\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/string-filters/#case-insensitive-operators","title":"Case-Insensitive Operators","text":"Operator Description <code>__istartswith</code> Starts with (case-insensitive) <code>__iendswith</code> Ends with (case-insensitive) <code>__icontains</code> Contains (case-insensitive)"},{"location":"tui-demo/string-filters/#when-to-use","title":"When to Use","text":"<ul> <li>Email domains: Users might type \"Example.COM\" or \"example.com\"</li> <li>Usernames: Username searches should ignore case</li> <li>General search: More user-friendly search experience</li> </ul>"},{"location":"tui-demo/string-filters/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tui-demo/string-filters/#indexes","title":"Indexes","text":"<p>String filters (especially <code>contains</code> and <code>startswith</code>) can be slow on large datasets without proper indexing.</p>"},{"location":"tui-demo/string-filters/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use <code>startswith</code> instead of <code>contains</code> when possible - can use indexes better</li> <li>Consider case-sensitive filters - they're slightly faster</li> <li>Limit results with <code>fetch_first()</code> or pagination on large datasets</li> </ol>"},{"location":"tui-demo/string-filters/#example-optimized-search","title":"Example: Optimized Search","text":"<pre><code># Instead of this (slower on large datasets):\nresults = db.select(User).filter(email__contains=\"@example.com\").fetch_all()\n\n# Use this when you know the format:\nresults = db.select(User).filter(email__endswith=\"@example.com\").fetch_all()\n</code></pre>"},{"location":"tui-demo/string-filters/#operator-reference","title":"Operator Reference","text":"Operator Case-Sensitive Description Example <code>__startswith</code> Yes Starts with prefix <code>name__startswith=\"Apple\"</code> <code>__endswith</code> Yes Ends with suffix <code>email__endswith=\".com\"</code> <code>__contains</code> Yes Contains substring <code>desc__contains=\"phone\"</code> <code>__istartswith</code> No Starts with (ignore case) <code>name__istartswith=\"apple\"</code> <code>__iendswith</code> No Ends with (ignore case) <code>email__iendswith=\".COM\"</code> <code>__icontains</code> No Contains (ignore case) <code>desc__icontains=\"PHONE\"</code>"},{"location":"tui-demo/string-filters/#related-documentation","title":"Related Documentation","text":"<ul> <li>Filtering - Comparison operators for filtering</li> <li>Query Results - Fetch and paginate results</li> <li>Ordering - Sort query results</li> </ul>"},{"location":"tui-demo/timestamps/","title":"Auto Timestamp Demos","text":"<p>These demos show automatic timestamp tracking for records.</p>"},{"location":"tui-demo/timestamps/#auto-created_at","title":"Auto created_at","text":"<p>Track when records are created.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom datetime import datetime, timezone\nimport time\n\nclass Article(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Article)\n\narticle1 = db.insert(Article(title=\"First Post\"))\ndt1 = datetime.fromtimestamp(article1.created_at, tz=timezone.utc)\nformatted_dt1 = dt1.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Article: {article1.title}\")\nprint(f\"Created: {article1.created_at} ({formatted_dt1} UTC)\")\n\ntime.sleep(1)\n\narticle2 = db.insert(Article(title=\"Second Post\"))\ndt2 = datetime.fromtimestamp(article2.created_at, tz=timezone.utc)\nformatted_dt2 = dt2.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"\\nArticle: {article2.title}\")\nprint(f\"Created: {article2.created_at} ({formatted_dt2} UTC)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#what-it-does","title":"What It Does","text":"<ul> <li><code>created_at</code> field is automatically added to your model</li> <li>Set to current Unix timestamp when record is inserted</li> <li>Never changes after initial insert</li> </ul>"},{"location":"tui-demo/timestamps/#field-type","title":"Field Type","text":"<p><code>created_at</code> is stored as an integer (Unix timestamp in seconds).</p>"},{"location":"tui-demo/timestamps/#auto-updated_at","title":"Auto updated_at","text":"<p>Track when records are last modified.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nfrom datetime import datetime, timezone\nimport time\n\nclass Task(BaseDBModel):\n    title: str\n    done: bool = False\n\ndb = SqliterDB(memory=True)\ndb.create_table(Task)\n\ntask = db.insert(Task(title=\"Original Task\"))\ncreated_dt = datetime.fromtimestamp(task.created_at, tz=timezone.utc)\nupdated_dt = datetime.fromtimestamp(task.updated_at, tz=timezone.utc)\nformatted_created_dt = created_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\nformatted_updated_dt = updated_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Task: {task.title}\")\nprint(f\"Created: {task.created_at} ({formatted_created_dt} UTC)\")\nprint(f\"Updated: {task.updated_at} ({formatted_updated_dt} UTC)\")\n\n# Sleep for 1 second to ensure different timestamps on fast machines\ntime.sleep(1)\n\ntask.title = \"Updated Task\"\ntask.done = True\ndb.update(task)\nupdated_task = task\nupdated_created_dt = datetime.fromtimestamp(\n    updated_task.created_at, tz=timezone.utc\n)\nupdated_updated_dt = datetime.fromtimestamp(\n    updated_task.updated_at, tz=timezone.utc\n)\nformatted_updated_created_dt = updated_created_dt.strftime(\n    \"%Y-%m-%d %H:%M:%S\"\n)\nformatted_updated_updated_dt = updated_updated_dt.strftime(\n    \"%Y-%m-%d %H:%M:%S\"\n)\nprint(\"\\nAfter update:\")\nprint(f\"Title: {updated_task.title}\")\nprint(\n    f\"Created: {updated_task.created_at} \"\n    f\"({formatted_updated_created_dt} UTC)\"\n)\nprint(\n    f\"Updated: {updated_task.updated_at} \"\n    f\"({formatted_updated_updated_dt} UTC)\"\n)\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#how-it-works","title":"How It Works","text":"<ul> <li><code>updated_at</code> starts same as <code>created_at</code></li> <li>Automatically updated when you call <code>db.update()</code></li> <li>Changes on every update operation</li> </ul>"},{"location":"tui-demo/timestamps/#both-timestamps","title":"Both Timestamps","text":"<p>Most models track both creation and modification times.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nimport time\n\nclass Document(BaseDBModel):\n    \"\"\"Document with both timestamps.\"\"\"\n    title: str\n    content: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Document)\n\n# Create document\ndoc = db.insert(Document(title=\"Draft\", content=\"...\"))\nprint(f\"Created: {doc.created_at}\")\nprint(f\"Updated: {doc.updated_at}\")\n\n# Sleep for 1 second to ensure different timestamps on fast machines\ntime.sleep(1)\n\n# Update document\ndoc.content = \"Revised content\"\ndb.update(doc)\n\n# Check timestamps\nprint(f\"Created: {doc.created_at}\")  # Unchanged\nprint(f\"Updated: {doc.updated_at}\")  # Changed\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#converting-timestamps","title":"Converting Timestamps","text":"<p>Convert Unix timestamps to readable dates.</p> <pre><code>from datetime import datetime, timezone\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Article(BaseDBModel):\n    title: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Article)\n\narticle = db.insert(Article(title=\"Test\"))\n\n# Convert to human-readable format\ndt = datetime.fromtimestamp(article.created_at, tz=timezone.utc)\nreadable = dt.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Created: {article.created_at} ({readable} UTC)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#when-to-use-timestamps","title":"When to Use Timestamps","text":""},{"location":"tui-demo/timestamps/#audit-trails","title":"Audit Trails","text":"<p>Track when records were created and modified:</p> <pre><code>class User(BaseDBModel):\n    username: str\n    # created_at and updated_at automatically added\n</code></pre>"},{"location":"tui-demo/timestamps/#synchronization","title":"Synchronization","text":"<p>Determine if data needs to be synced:</p> <pre><code>local_doc = db_local.get_by_pk(Document, doc_id)\nremote_doc = db_remote.get_by_pk(Document, doc_id)\n\nif remote_doc.updated_at &gt; local_doc.updated_at:\n    sync_document(remote_doc)\n</code></pre>"},{"location":"tui-demo/timestamps/#debugging","title":"Debugging","text":"<p>Understand the lifecycle of records:</p> <pre><code>from datetime import datetime, timezone\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    username: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\nuser = db.insert(User(username=\"alice\"))\n\nnow = datetime.now(tz=timezone.utc)\ncreated = datetime.fromtimestamp(user.created_at, tz=timezone.utc)\nupdated = datetime.fromtimestamp(user.updated_at, tz=timezone.utc)\nprint(f\"User created {now - created} ago\")\nprint(f\"Last updated {now - updated} ago\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#soft-delete","title":"Soft Delete","text":"<p>Mark records as deleted instead of removing them:</p> <pre><code>import time\nfrom typing import Optional\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Record(BaseDBModel):\n    data: str\n    deleted_at: Optional[int] = None  # Manual timestamp\n\ndb = SqliterDB(memory=True)\ndb.create_table(Record)\n\ndef soft_delete(record: Record) -&gt; None:\n    record.deleted_at = int(time.time())\n    db.update(record)\n\n# Example usage\nrecord = db.insert(Record(data=\"Important data\"))\nsoft_delete(record)\nprint(f\"Record deleted at: {record.deleted_at}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#timestamp-precision","title":"Timestamp Precision","text":"<p>Unix timestamps are in seconds since the epoch (January 1, 1970).</p>"},{"location":"tui-demo/timestamps/#limitations","title":"Limitations","text":"<ul> <li>Second precision: No milliseconds/microseconds</li> <li>Timezone naive: Stored as UTC, convert for display</li> <li>Year 2038: 32-bit integer limit (not an issue for 64-bit)</li> </ul>"},{"location":"tui-demo/timestamps/#example-values","title":"Example Values","text":"<pre><code>1737739200 -&gt; 2025-01-25 00:00:00 UTC\n1737742800 -&gt; 2025-01-25 01:00:00 UTC\n</code></pre>"},{"location":"tui-demo/timestamps/#comparing-timestamps","title":"Comparing Timestamps","text":"<p>Find records by creation or modification time.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\nimport time\n\nclass LogEntry(BaseDBModel):\n    message: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(LogEntry)\n\n# Insert entries at different times\nentry1 = db.insert(LogEntry(message=\"First\"))\ntime.sleep(1)\nentry2 = db.insert(LogEntry(message=\"Second\"))\n\n# Find entries created after a certain time\ncutoff = entry1.created_at\nrecent = db.select(LogEntry).filter(\n    created_at__gt=cutoff\n).fetch_all()\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/timestamps/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/timestamps/#do","title":"DO","text":"<ul> <li>Use timestamps for audit trails</li> <li>Convert to readable format for display</li> <li>Store as UTC, convert to local time for users</li> <li>Use for synchronization checks</li> </ul>"},{"location":"tui-demo/timestamps/#dont","title":"DON'T","text":"<ul> <li>Assume timestamps are in local time (they're UTC)</li> <li>Forget that precision is only in seconds</li> <li>Manually set timestamps (let SQLiter handle it)</li> <li>Use <code>created_at</code> for ordering by recency without understanding the limits</li> </ul>"},{"location":"tui-demo/timestamps/#related-documentation","title":"Related Documentation","text":"<ul> <li>Models - Define data models with timestamps</li> <li>CRUD Operations - Update records (updates <code>updated_at</code>)</li> <li>Filtering - Filter by timestamp values</li> </ul>"},{"location":"tui-demo/transactions/","title":"Transaction Demos","text":"<p>These demos show how to group operations into atomic transactions.</p>"},{"location":"tui-demo/transactions/#basic-transaction","title":"Basic Transaction","text":"<p>Group multiple operations that succeed or fail together.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Account(BaseDBModel):\n    name: str\n    balance: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Account)\n\nalice: Account = db.insert(Account(name=\"Alice\", balance=100.0))\nbob: Account = db.insert(Account(name=\"Bob\", balance=50.0))\n\nprint(f\"Before: Alice=${alice.balance}, Bob=${bob.balance}\")\n\n# Transfer money using context manager\nwith db:\n    alice.balance = alice.balance - 20.0\n    bob.balance = bob.balance + 20.0\n    db.update(alice)\n    db.update(bob)\n    alice_updated = alice\n    bob_updated = bob\n\nprint(\n    f\"After: Alice=${alice_updated.balance}, Bob=${bob_updated.balance}\"\n)\nprint(\"Transaction auto-committed on success\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/transactions/#what-happens","title":"What Happens","text":"<ul> <li>Both updates succeed or both fail</li> <li>If an error occurs, changes are rolled back</li> <li>Database remains in a consistent state</li> </ul>"},{"location":"tui-demo/transactions/#transaction-rollback","title":"Transaction Rollback","text":"<p>Automatically rollback on errors.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Item(BaseDBModel):\n    name: str\n    quantity: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Item)\n\nitem: Item = db.insert(Item(name=\"Widget\", quantity=10))\nprint(f\"Initial quantity: {item.quantity}\")\n\n# Use context manager for automatic rollback on error\ntry:\n    with db:\n        item.quantity = 5\n        db.update(item)\n        print(\"Inside transaction: updated to 5\")\n        # If error occurs, changes are rolled back\n        error_msg = \"Intentional error for rollback\"\n        raise RuntimeError(error_msg)  # noqa: TRY301\nexcept RuntimeError:\n    print(\"Error occurred - transaction rolled back\")\n    print(\"Original value preserved (quantity=10)\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/transactions/#rollback-behavior","title":"Rollback Behavior","text":"<ul> <li>All changes within the transaction should be undone</li> <li>Database state should be as if nothing happened</li> <li>Exception continues to propagate unless caught</li> </ul>"},{"location":"tui-demo/transactions/#manual-transaction-control","title":"Manual Transaction Control","text":"<p>Explicitly commit using the context manager or connect/commit methods.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Log(BaseDBModel):\n    message: str\n\ndb = SqliterDB(memory=True)\ndb.create_table(Log)\n\n# Manual transaction control\ndb.connect()\nlog1 = db.insert(Log(message=\"First entry\"))\nprint(f\"Inserted: {log1.message}\")\nprint(\"Not committed yet\")\ndb.commit()\nprint(\"Committed\")\n\ndb.insert(Log(message=\"Second entry\"))\ndb.commit()\n\nall_logs = db.select(Log).fetch_all()\nprint(f\"Total logs: {len(all_logs)}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/transactions/#when-to-use","title":"When to Use","text":"<ul> <li>Complex logic: Need conditional commit/rollback</li> <li>Error handling: Different rollback strategies</li> <li>Nested operations: Multiple validation steps</li> </ul>"},{"location":"tui-demo/transactions/#transaction-isolation","title":"Transaction Isolation","text":"<p>Transactions are isolated from other operations.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Counter(BaseDBModel):\n    value: int\n\ndb = SqliterDB(memory=True)\ndb.create_table(Counter)\n\ncounter = db.insert(Counter(value=0))\n\nwith db:\n    # Increment counter\n    counter.value += 1\n    db.update(counter)\n\n    # Value is 1 inside transaction\n    print(f\"Inside: {counter.value}\")\n\n# Value is still 1 after commit\nreloaded = db.get(Counter, counter.pk)\nif reloaded is not None:\n    print(f\"After commit: {reloaded.value}\")\n\ndb.close()\n</code></pre>"},{"location":"tui-demo/transactions/#nested-transactions","title":"Nested Transactions","text":"<p>SQLiter supports nested context manager usage.</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass Order(BaseDBModel):\n    total: float\n\nclass Payment(BaseDBModel):\n    amount: float\n\ndb = SqliterDB(memory=True)\ndb.create_table(Order)\ndb.create_table(Payment)\n\n# Outer transaction\nwith db:\n    order = db.insert(Order(total=100.0))\n\n    # Inner context (part of same transaction)\n    with db:\n        payment = db.insert(Payment(amount=100.0))\n\n    # Both are committed together\n</code></pre> <p>Note</p> <p>SQLite's nested contexts are part of the same transaction - the outermost context exit finalizes everything.</p>"},{"location":"tui-demo/transactions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tui-demo/transactions/#bulk-operations-with-transactions","title":"Bulk Operations with Transactions","text":"<pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n\n# \u274c SLOW: Each insert is its own transaction\nfor i in range(1000):\n    db.insert(User(name=f\"User {i}\"))\n\n# \u2705 FAST: All inserts in one transaction\nwith db:\n    for i in range(1000):\n        db.insert(User(name=f\"User {i}\"))\n</code></pre>"},{"location":"tui-demo/transactions/#performance-impact","title":"Performance Impact","text":"<ul> <li>Without transaction: 1000 separate commits = slow</li> <li>With transaction: 1 commit for all records = 10-100x faster</li> </ul>"},{"location":"tui-demo/transactions/#when-to-use-transactions","title":"When to Use Transactions","text":""},{"location":"tui-demo/transactions/#always-use-for","title":"Always Use For","text":"<ul> <li>Related operations: Multiple tables that must stay in sync</li> <li>Financial data: Money transfers must be atomic</li> <li>Complex updates: Changes that affect multiple records</li> </ul>"},{"location":"tui-demo/transactions/#optional-for","title":"Optional For","text":"<ul> <li>Single operations: One insert/update/delete</li> <li>Independent records: No relationship between operations</li> <li>Non-critical data: Temporary data, logs</li> </ul>"},{"location":"tui-demo/transactions/#never-for","title":"Never For","text":"<ul> <li>Long-running operations: Transactions lock the database</li> <li>Interactive operations: Waiting for user input</li> <li>Large bulk imports: Consider periodic commits</li> </ul>"},{"location":"tui-demo/transactions/#common-patterns","title":"Common Patterns","text":""},{"location":"tui-demo/transactions/#transfer-pattern","title":"Transfer Pattern","text":"<pre><code>def transfer(db: SqliterDB, from_account: Account, to_account: Account, amount: float) -&gt; None:\n    \"\"\"Transfer funds between accounts.\"\"\"\n    with db:\n        from_account.balance -= amount\n        to_account.balance += amount\n        db.update(from_account)\n        db.update(to_account)\n</code></pre>"},{"location":"tui-demo/transactions/#create-or-update-pattern","title":"Create or Update Pattern","text":"<pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    email: str\n\ndef create_or_update(db: SqliterDB, user: User) -&gt; None:\n    \"\"\"Insert or update a user.\"\"\"\n    with db:\n        existing = db.select(User).filter(\n            email__eq=user.email\n        ).fetch_one()\n\n        if existing:\n            existing.name = user.name\n            db.update(existing)\n        else:\n            db.insert(user)\n</code></pre>"},{"location":"tui-demo/transactions/#best-practices","title":"Best Practices","text":""},{"location":"tui-demo/transactions/#do","title":"DO","text":"<ul> <li>Use transactions for multistep operations</li> <li>Keep transactions short (don't hold locks)</li> <li>Use context managers for automatic cleanup</li> <li>Handle exceptions appropriately</li> </ul>"},{"location":"tui-demo/transactions/#dont","title":"DON'T","text":"<ul> <li>Forget that transactions lock the database</li> <li>Put user input inside transactions</li> <li>Use transactions for single operations (unnecessary overhead)</li> <li>Mix manual and automatic transaction control</li> </ul>"},{"location":"tui-demo/transactions/#related-documentation","title":"Related Documentation","text":"<ul> <li>CRUD Operations - Create, update, and delete records</li> <li>Error Handling - Handle transaction errors</li> <li>ORM Features - Work with related data in transactions</li> </ul>"}]}