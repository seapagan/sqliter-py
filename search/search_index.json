{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLiter","text":"<p>SQLiter is a lightweight Object-Relational Mapping (ORM) library for SQLite databases in Python. It provides a simplified interface for interacting with SQLite databases using Pydantic models. The only external run-time dependency is Pydantic itself.</p> <p>It does not aim to be a full-fledged ORM like SQLAlchemy, but rather a simple and easy-to-use library for basic database operations, especially for small projects. It is NOT asynchronous and does not support complex queries (at this time).</p> <p>The ideal use case is more for Python CLI tools that need to store data in a database-like format without needing to learn SQL or use a full ORM.</p> <p>Caution</p> <p>This project is still in the early stages of development and is lacking some planned functionality. Please use with caution - Classes and methods may change until a stable release is made. I'll try to keep this to an absolute minimum and the releases and documentation will be very clear about any breaking changes.</p> <p>Also, structures like <code>list</code>, <code>dict</code>, <code>set</code> etc are not supported at this time as field types, since SQLite does not have a native column type for these. This is the next planned enhancement. These will need to be <code>pickled</code> first then stored as a BLOB in the database . Also support <code>date</code> which can be stored as a Unix timestamp in an integer field.</p> <p>See the TODO for planned features and improvements.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Table creation based on Pydantic models</li> <li>Automatic primary key generation</li> <li>User defined indexes on any field</li> <li>Set any field as UNIQUE</li> <li>CRUD operations (Create, Read, Update, Delete)</li> <li>Chained Query building with filtering, ordering, and pagination</li> <li>Transaction support</li> <li>Custom exceptions for better error handling</li> <li>Full type hinting and type checking</li> <li>Detailed documentation and examples</li> <li>No external dependencies other than Pydantic</li> <li>Full test coverage</li> <li>Can optionally output the raw SQL queries being executed for debugging   purposes.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install SQLiter using whichever method you prefer or is compatible with your project setup.</p> <p>With <code>uv</code> which is rapidly becoming my favorite tool for managing projects and virtual environments (<code>uv</code> is used for developing this project and in the CI):</p> <pre><code>uv add sqliter-py\n</code></pre> <p>With <code>Poetry</code>:</p> <pre><code>poetry add sqliter-py\n</code></pre> <p>Or with <code>pip</code>:</p> <pre><code>pip install sqliter-py\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Currently by default, the only external dependency is Pydantic. However, there are some optional dependencies that can be installed to enable additional features:</p> <ul> <li><code>inflect</code>: For pluralizing table names (if not specified). This just offers a   more-advanced pluralization than the default method used. In most cases you   will not need this.</li> </ul> <p>These can be installed using <code>uv</code>:</p> <pre><code>uv add 'sqliter-py[extras]'\n</code></pre> <p>With <code>Poetry</code>:</p> <pre><code>poetry add 'sqliter-py[extras]'\n</code></pre> <p>Or with <code>pip</code>:</p> <pre><code>pip install 'sqliter-py[extras]'\n</code></pre>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the terms of the MIT license below:</p> <pre><code>The MIT License (MIT)\nCopyright (c) 2024 Grant Ramsay\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Here's a quick example of how to use SQLiter:</p> <pre><code>from typing import Optional\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\n# Define your model\nclass User(BaseDBModel):\n    name: str\n    age: int\n    admin: Optional[bool] = False\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n\n# Create the table\ndb.create_table(User)\n\n# Insert a record\nuser = User(name=\"John Doe\", age=30)\nnew_user = db.insert(user)\n\n# Query records\nresults = db.select(User).filter(name=\"John Doe\").fetch_all()\nfor user in results:\n    print(f\"User: {user.name}, Age: {user.age}, Admin: {user.admin}\")\n\n# Update a record\nnew_user.age = 31\ndb.update(new_user)\n\nresults = db.select(User).filter(name=\"John Doe\").fetch_one()\n\nprint(\"Updated age:\", results.age)\n\n# Delete a record\ndb.delete(User, new_user.pk)\n</code></pre> <p>See the Guide for more detailed information on how to use <code>SQLiter</code>.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This is an auto-generated log of all the changes that have been made to the project since the first release, with the latest changes at the top.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#060-october-12-2024","title":"0.6.0 (October 12, 2024)","text":"<p>New Features</p> <ul> <li>Add ability to mark a field as UNIQUE (#46) by seapagan</li> <li>Implement user-defined indexes (#45) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context-manager ignores the <code>auto_commit</code> setting. (#43) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#050-september-30-2024","title":"0.5.0 (September 30, 2024)","text":"<p>Breaking Change!</p> <p>This release removes the <code>create_pk</code> and <code>primary_key</code> attributes from the Model <code>Meta</code> Class. Now, an auto-incrementing primary key is created by default and the name of the primary key is always <code>pk</code>.</p> <p>Closed Issues</p> <ul> <li>Auto-generated primary key not returned by the Model (#37) by seapagan</li> </ul> <p>Breaking Changes</p> <ul> <li>Always create a <code>pk</code> primary auto-incrementing key (#39) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix <code>null</code> filter when combined with others and add tests (#40) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Refactor web docs layout and improve content (#36) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#040-september-27-2024","title":"0.4.0 (September 27, 2024)","text":"<p>New Features</p> <ul> <li>Add <code>exists_ok</code> and <code>force</code> flags to <code>create_table</code> (#34) by seapagan</li> <li>Add <code>reset=</code> to SqliterDB(), to drop all existing tables (#33) by seapagan</li> <li>Order by primary key if no field specified to <code>order()</code> (#32) by seapagan</li> <li>Add <code>drop_table</code> method (#31) by seapagan</li> <li>Add debug logging option (#29) by seapagan</li> <li>Create relevant database fields depending on the Model types (#27) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add test coverage where missing (#28) by seapagan</li> </ul> <p>Refactoring</p> <ul> <li>Perform some internal refactoring, mostly arranging the tests. (#30) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Add a documentation website and trim down the README (#25) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#030-september-23-2024","title":"0.3.0 (September 23, 2024)","text":"<p>Breaking Changes</p> <ul> <li>Rename 'create_id' to 'create_pk' (#23) by seapagan</li> </ul> <p>New Features</p> <ul> <li>Deprecate 'direction=' for 'reverse=' in <code>order()</code> method. (#24) by seapagan</li> <li>Add improved table name generation (#21) by seapagan</li> <li>Implement an in-memory database option (#15) by seapagan</li> <li>Allow selecting a subset of the database fields instead of all them (#12) by seapagan</li> <li>Improve dev tooling and contributor documentation (#11) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Update dependency ruff to v0.6.7 (#19) by renovate[bot]</li> <li>Update dependency pydantic to v2.9.2 (#18) by renovate[bot]</li> <li>Update dependency idna to v3.10 (#17) by renovate[bot]</li> <li>Update dependency zipp to v3.20.2 (#16) by renovate[bot]</li> <li>Update astral-sh/setup-uv action to v3 (#10) by renovate[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#020-september-14-2024","title":"0.2.0 (September 14, 2024)","text":"<p>New Features</p> <ul> <li>Default to auto_create=True, and add 'commit()' &amp; 'close()' methods (#9) by seapagan</li> <li>Add more advanced filtering options (#7) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context manager commits on exit (#8) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#011-september-12-2024","title":"0.1.1 (September 12, 2024)","text":"<p>Just a documentation fix - README was old version</p> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#010-september-12-2024","title":"0.1.0 (September 12, 2024)","text":"<p>New Features</p> <ul> <li>Remove transaction exception (TransactionError) (#4) by seapagan</li> <li>Improve error handling across the library (#3) by seapagan</li> <li>Add 'limit', 'offset' and 'order' methods (#2) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add a full test suite to the existing code. (#1) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Configure Renovate (#5) by renovate[bot]</li> </ul> <p>This changelog was generated using github-changelog-md by Seapagan</p>"},{"location":"contributing/","title":"Contributing to SQLiter","text":"<p>Thank you for your interest in contributing to SQLiter! We welcome all contributions, big or small.</p> <p>If you are not sure where to start, please take a look at the open issues. If you have an idea for a new feature or would like to report a bug, please open a new issue.</p> <p>We also welcome contributions to the documentation. If you find any errors or would like to suggest improvements, please open a new issue or submit a pull</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>This project requires Python 3.9 or higher.</li> </ul> <ul> <li>We use uv to manage our dependencies. You should have this installed as well. You can install <code>uv</code> by following the instructions on their website.</li> </ul> <p><code>uv</code> can be used to actually install Python, even if you do not have it installed locally (either by system, pyenv or similar).</p> <p>For example, to install Python 3.12 using <code>uv</code>, you can run the following command:</p> <pre><code>uv python install 3.12\n</code></pre> <p>If you already have a Python version installed, uv will use this.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please make sure you have read and understood our Code of Conduct and License.</p> <p>To get started, follow these steps:</p> <ol> <li>Fork the repository and clone it to your local machine.</li> <li>Install the required dependencies (see next section).</li> <li>Create a new branch for your changes: <code>git checkout -b my-new-feature</code>.</li> <li>Make your changes and commit them: <code>git commit -am 'Add some feature'</code>.</li> <li>Push your changes to your fork: <code>git push origin my-new-feature</code>.</li> <li>Create a new pull request.</li> </ol>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Run the following command to create a local virtualenv and install the required dependencies. We need the optional extras installed so the tests pass:</p> <pre><code>uv sync --all-extras\n</code></pre> <p>The <code>.venv</code> folder is already in the <code>.gitignore</code> file so will not be committed to the repository. This is where the virtual environment will be created.</p> <p>You then need to activate the virtual environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>From here you can start working on the project. If you are using an IDE such as VSCode or PyCharm, you can set their Python interpreter setting to use the virtual environment that has just been created.</p>"},{"location":"contributing/#install-git-pre-commit-hooks","title":"Install Git Pre-Commit hooks","text":"<p>Please do this if you are intending to submit a PR. It will check commits locally before they are pushed up to the Repo.</p> <pre><code>$ pre-commit install\npre-commit installed at .git/hooks/pre-commit\n</code></pre> <p>This will ensure that all code meets the required linting standard before being committed.</p>"},{"location":"contributing/#run-pre-commit-manually","title":"Run pre-commit manually","text":"<p>You can run these checks manually on all staged files using the below command :</p> <pre><code>poe pre\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using pytest for testing. Tests will automatically be run when you submit a pull request. You can also run them manually using the following command:</p> <pre><code>pytest\n</code></pre> <p>If you add any new features, please add tests for them. This will help us to ensure that the code is working as expected and will prevent any regressions.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>The changelog is automatically generated using github-changelog-md, so please do not edit it manually.</p> <p>For maintainers, there is a POE task that will run this and update the changelog file.</p> <pre><code>poe changelog\n</code></pre> <p>You would also need to add a GitHub Personal Access Token to a local config file as usual. See the section in that tools Documentation for information.</p> <p>However, you should NOT include a change to the <code>CHANGELOG.md</code> file in any Pull Requests. This will be handled by the maintainers when a new release is made. Your GitHub username will be added to the changelog automatically beside your PR.</p>"},{"location":"contributing/#convenience-tasks","title":"Convenience Tasks","text":"<p>There are a few other convenience tasks that can be run using the <code>poe</code> command. These are defined in the <code>pyproject.toml</code> file.</p> <p>Each of these tasks can have extra options added which will be passed to the underlying tool.</p> <p>Run <code>mypy</code> on the code base in strict mode:</p> <pre><code>poe mypy\n</code></pre> <p>Format the code using <code>ruff format</code>:</p> <pre><code>poe format\n</code></pre> <p>Lint the code using <code>ruff check</code>:</p> <pre><code>poe ruff\n</code></pre>"},{"location":"contributing/#documentation-tasks","title":"Documentation Tasks","text":"<p>These are to help with developing and updating the documentation.</p> <ul> <li><code>poe docs:serve</code> - Serve the MkDocs locally for testing and development</li> <li><code>poe docs:serve:all</code> - Same as above, but opens to all interfaces so you can   view it on other devices on your network</li> <li><code>poe docs:build</code> - Build the MkDocs site into the <code>dist</code> folder</li> <li><code>poe docs:publish</code> - Publish the docs to your GitHub pages. Note that only   those with write-access to this repo can do this.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<p>Here are some guidelines to follow when contributing to SQLiter:</p> <ul> <li>Do not update the version number in the <code>pyproject.toml</code> file. This will be   done by the maintainers when a new release is made.</li> <li>Follow the PEP 8 style guide. The   pre-commit hooks will check for this. We are using   Ruff as both a linter and code formatter.</li> <li>Try to have no linting errors or warnings. The pre-commit hooks will check for   this also.</li> <li>MyPy is installed and we are using   type hints. Please try to add type hints to your code. If you see any areas of   the code that are missing type hints, please feel free to open a PR and add   them \ud83d\ude01!</li> <li>Write clear and concise commit messages.</li> <li>Write tests for your code.</li> <li>Make sure your code passes all tests before submitting a pull request.</li> <li>Document your code using   docstrings.</li> <li>Use GitHub issues   to report bugs or suggest new features.</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>If you have any questions or need help with contributing, please contact me @seapagan on GitHub. You can also use the GitHub Discussions feature.</p> <p>Happy contributing!</p>"},{"location":"guide/connecting/","title":"Connecting to the Database","text":""},{"location":"guide/connecting/#creating-a-connection","title":"Creating a Connection","text":"<p>To connect to a database (and create the file if it does not already exist), you create an instance of the <code>SqliterDB</code> class. This will automatically take care of connecting to or creating the database file.</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(\"your_database.db\")\n</code></pre> <p>The default behavior is to automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>It is then up to you to manually commit changes using the <code>commit()</code> method. This can be useful when you want to perform multiple operations in a single transaction without the overhead of committing after each operation.</p>"},{"location":"guide/connecting/#using-an-in-memory-database","title":"Using an In-Memory Database","text":"<p>If you want to use an in-memory database, you can set <code>memory=True</code> when creating the database connection:</p> <pre><code>db = SqliterDB(memory=True)\n</code></pre> <p>This will create an in-memory database that is not persisted to disk. If you also specify a database name, it will be ignored.</p> <pre><code>db = SqliterDB(\"ignored.db\", memory=True)\n</code></pre> <p>The <code>ignored.db</code> file will not be created, and the database will be in-memory. If you do not specify a database name, and do NOT set <code>memory=True</code>, an exception will be raised.</p> <p>Note</p> <p>You can also use <code>\":memory:\"</code> as the database name (same as normal with Sqlite) to create an in-memory database, this is just a cleaner and more descriptive way to do it.</p> <pre><code>db = SqliterDB(\":memory:\")\n</code></pre>"},{"location":"guide/connecting/#resetting-the-database","title":"Resetting the Database","text":"<p>If you want to reset an existing database when you create the SqliterDB object, you can pass <code>reset=True</code>:</p> <pre><code>db = SqliterDB(\"your_database.db\", reset=True)\n</code></pre> <p>This will effectively drop all user tables from the database. The file itself is not deleted, only the tables are dropped.</p>"},{"location":"guide/data-ops/","title":"Data Operations","text":""},{"location":"guide/data-ops/#inserting-records","title":"Inserting Records","text":"<p>The <code>insert()</code> method is used to add records to the database. You pass an instance of your model class to the method, and SQLiter will insert the record into the correct table:</p> <pre><code>user = User(name=\"Jane Doe\", age=25, email=\"jane@example.com\")\nresult = db.insert(user)\n</code></pre> <p>The <code>result</code> variable will contain a new instance of the model, with the primary key value set to the newly-created primary key in the database. You should use this instance to access the primary key value and other fields:</p> <pre><code>print(f\"New record inserted with primary key: {result.pk}\")\nprint(f\"Name: {result.name}, Age: {result.age}, Email: {result.email}\")\n</code></pre> <p>Important</p> <p>The <code>insert()</code> method will raise a <code>RecordInsertionError</code> if you try to insert a record with a primary key that already exists in the table or if the table does not exist.</p>"},{"location":"guide/data-ops/#querying-records","title":"Querying Records","text":"<p><code>SQLiter</code> provides a simple and intuitive API for querying records from the database, Starting with the <code>select()</code> method and chaining other methods to filter, order, limit, and offset the results:</p> <pre><code># Fetch all users\nall_users = db.select(User).fetch_all()\n\n# Filter users\nyoung_users = db.select(User).filter(age=25).fetch_all()\n\n# Order users\nordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n\n# Limit and offset\npaginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre> <p>Important</p> <p>The <code>select()</code> MUST come first, before any filtering, ordering, or pagination etc. This is the starting point for building your query.</p> <p>See Filtering Results for more advanced filtering options.</p>"},{"location":"guide/data-ops/#updating-records","title":"Updating Records","text":"<p>You can update records in the database by modifying the fields of the model instance and then calling the <code>update()</code> method. You just pass the model instance to the method:</p> <pre><code>user.age = 26\ndb.update(user)\n</code></pre> <p>Important</p> <p>The model you pass must have a primary key value set, otherwise an error will be raised. In other words, you use the instance of a model returned by the <code>insert()</code> method to update the record as it has the primary key value set, not the original instance you passed to <code>insert()</code>.</p> <p>You can also set the primary key value on the model instance manually before calling <code>update()</code> if you have that.</p>"},{"location":"guide/data-ops/#deleting-records","title":"Deleting Records","text":"<p>To delete a record from the database, you need to pass the model class and the primary key value of the record you want to delete:</p> <pre><code>db.delete(User, user.pk)\n</code></pre>"},{"location":"guide/data-ops/#commit-your-changes","title":"Commit your changes","text":"<p>By default, SQLiter will automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>You can then manually commit changes using the <code>commit()</code> method:</p> <pre><code>db.commit()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>commit()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/data-ops/#close-the-connection","title":"Close the Connection","text":"<p>When you're done with the database connection, you should close it to release resources:</p> <pre><code>db.close()\n</code></pre> <p>Note that closing the connection will also commit any pending changes, unless <code>auto_commit</code> is set to <code>False</code>.</p> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/debug/","title":"Debug Logging","text":"<p>You can enable debug logging to see the SQL queries being executed by SQLiter. This can be useful for debugging and understanding the behavior of your application. It is disabled by default, and can be set on the <code>SqliterDB</code> class:</p> <pre><code>db = SqliterDB(\"your_database.db\", debug=True)\n</code></pre> <p>This will print the SQL queries to the console as they are executed. If there is an existing logger in your application then SQLiter will use that logger, otherwise it will create and use a new logger named <code>sqliter</code>.</p>"},{"location":"guide/exceptions/","title":"Exceptions","text":"<p>SQLiter includes several custom exceptions to handle specific errors that may occur during database operations. These exceptions inherit from a common base class, <code>SqliterError</code>, to ensure consistency across error messages and behavior.</p> <ul> <li><code>SqliterError</code>:<ul> <li>The base class for all exceptions in SQLiter. It captures the exception   context and chains any previous exceptions.</li> <li>Message: \"An error occurred in the SQLiter package.\"</li> </ul> </li> </ul> <ul> <li><code>DatabaseConnectionError</code>:<ul> <li>Raised when the SQLite database connection fails.</li> <li>Message: \"Failed to connect to the database: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOffsetError</code>:<ul> <li>Raised when an invalid offset value (0 or negative) is used in queries.</li> <li>Message: \"Invalid offset value: '{}'. Offset must be a positive   integer.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOrderError</code>:<ul> <li>Raised when an invalid order value is used in queries, such as a   non-existent field or an incorrect sorting direction.</li> <li>Message: \"Invalid order value - '{}'\"</li> </ul> </li> </ul> <ul> <li><code>TableCreationError</code>:<ul> <li>Raised when a table cannot be created in the database.</li> <li>Message: \"Failed to create the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordInsertionError</code>:<ul> <li>Raised when an error occurs during record insertion.</li> <li>Message: \"Failed to insert record into table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordUpdateError</code>:<ul> <li>Raised when an error occurs during record update.</li> <li>Message: \"Failed to update record in table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordNotFoundError</code>:<ul> <li>Raised when a record with the specified primary key is not found.</li> <li>Message: \"Failed to find a record for key '{}'\".</li> </ul> </li> </ul> <ul> <li><code>RecordFetchError</code>:<ul> <li>Raised when an error occurs while fetching records from the database.</li> <li>Message: \"Failed to fetch record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordDeletionError</code>:<ul> <li>Raised when an error occurs during record deletion.</li> <li>Message: \"Failed to delete record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidFilterError</code>:<ul> <li>Raised when an invalid filter field is used in a query.</li> <li>Message: \"Failed to apply filter: invalid field '{}'\".</li> </ul> </li> </ul> <ul> <li><code>TableDeletionError</code>:<ul> <li>Raised when a table cannot be deleted from the database.</li> <li>Message: \"Failed to delete the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li>SqlExecutionError<ul> <li>Raised when an error occurs during SQL query execution.</li> <li>Message: \"Failed to execute SQL: '{}'.\"</li> </ul> </li> </ul> <ul> <li>InvalidIndexError<ul> <li>Raised when an invalid index is specified for a model.</li> <li>Message: \"Invalid fields for indexing in model '{}': {}\"</li> </ul> </li> </ul>"},{"location":"guide/fields/","title":"Field Control","text":""},{"location":"guide/fields/#selecting-specific-fields","title":"Selecting Specific Fields","text":"<p>By default, all commands query and return all fields in the table. If you want to select only specific fields, you can pass them using the <code>fields()</code> method:</p> <pre><code>results = db.select(User).fields([\"name\", \"age\"]).fetch_all()\n</code></pre> <p>This will return only the <code>name</code> and <code>age</code> fields for each record.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, fields=[\"name\", \"age\"]).fetch_all()\n</code></pre> <p>Note that using the <code>fields()</code> method will override any fields specified in the 'select()' method.</p>"},{"location":"guide/fields/#excluding-specific-fields","title":"Excluding Specific Fields","text":"<p>If you want to exclude specific fields from the results, you can use the <code>exclude()</code> method:</p> <pre><code>results = db.select(User).exclude([\"email\"]).fetch_all()\n</code></pre> <p>This will return all fields except the <code>email</code> field.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, exclude=[\"email\"]).fetch_all()\n</code></pre>"},{"location":"guide/fields/#returning-exactly-one-explicit-field-only","title":"Returning exactly one explicit field only","text":"<p>If you only want to return a single field from the results, you can use the <code>only()</code> method:</p> <pre><code>result = db.select(User).only(\"name\").fetch_first()\n</code></pre> <p>This will return only the <code>name</code> field for the first record.</p> <p>This is exactly the same as using the <code>fields()</code> method with a single field, but very specific and obvious. There is NO equivalent argument to this in the <code>select()</code> method. An exception WILL be raised if you try to use this method with more than one field.</p>"},{"location":"guide/filtering/","title":"Filtering Results","text":"<p>The <code>filter()</code> method in SQLiter supports various filter options to query records, and can be combined with other methods like <code>order()</code>, <code>limit()</code>, and <code>offset()</code> to build more complex queries:</p> <pre><code>result = db.select(User).filter(age__lte=30).limit(10).fetch_all()\n</code></pre> <p>It is possible to both add multiple filters in the same call, and to chain multiple filter calls together:</p> <pre><code>result = db.select(User).filter(age__gte=20, age__lte=30).fetch_all()\n</code></pre> <pre><code>result = db.select(User).filter(age__gte=20).filter(age__lte=30).fetch_all()\n</code></pre>"},{"location":"guide/filtering/#basic-filters","title":"Basic Filters","text":"<ul> <li><code>__eq</code>: Equal to (default if no operator is specified)<ul> <li>Example: <code>name=\"John\"</code> or <code>name__eq=\"John\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#null-checks","title":"Null Checks","text":"<ul> <li><code>__isnull</code>: Is NULL<ul> <li>Example: <code>email__isnull=True</code></li> </ul> </li> <li><code>__notnull</code>: Is NOT NULL<ul> <li>Example: <code>email__notnull=True</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>__lt</code>: Less than<ul> <li>Example: <code>age__lt=30</code></li> </ul> </li> <li><code>__lte</code>: Less than or equal to<ul> <li>Example: <code>age__lte=30</code></li> </ul> </li> <li><code>__gt</code>: Greater than<ul> <li>Example: <code>age__gt=30</code></li> </ul> </li> <li><code>__gte</code>: Greater than or equal to<ul> <li>Example: <code>age__gte=30</code></li> </ul> </li> <li><code>__ne</code>: Not equal to<ul> <li>Example: <code>status__ne=\"inactive\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#list-operations","title":"List Operations","text":"<ul> <li><code>__in</code>: In a list of values<ul> <li>Example: <code>status__in=[\"active\", \"pending\"]</code></li> </ul> </li> <li><code>__not_in</code>: Not in a list of values<ul> <li>Example: <code>category__not_in=[\"archived\", \"deleted\"]</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#string-operations-case-sensitive","title":"String Operations (Case-Sensitive)","text":"<ul> <li><code>__startswith</code>: Starts with<ul> <li>Example: <code>name__startswith=\"A\"</code></li> </ul> </li> <li><code>__endswith</code>: Ends with<ul> <li>Example: <code>email__endswith=\".com\"</code></li> </ul> </li> <li><code>__contains</code>: Contains<ul> <li>Example: <code>description__contains=\"important\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#string-operations-case-insensitive","title":"String Operations (Case-Insensitive)","text":"<ul> <li><code>__istartswith</code>: Starts with (case-insensitive)<ul> <li>Example: <code>name__istartswith=\"a\"</code></li> </ul> </li> <li><code>__iendswith</code>: Ends with (case-insensitive)<ul> <li>Example: <code>email__iendswith=\".COM\"</code></li> </ul> </li> <li><code>__icontains</code>: Contains (case-insensitive)<ul> <li>Example: <code>description__icontains=\"IMPORTANT\"</code></li> </ul> </li> </ul>"},{"location":"guide/guide/","title":"SQLiter Overview","text":"<p>SQLiter is a lightweight Python library designed to simplify database operations using Pydantic models. It provides a range of functionality including table creation, CRUD operations, querying, filtering, and more. This overview briefly introduces each feature.</p>"},{"location":"guide/guide/#basic-setup","title":"Basic Setup","text":"<p>To get started, import the necessary modules and define a Pydantic model for your table:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n</code></pre>"},{"location":"guide/guide/#table-creation","title":"Table Creation","text":"<p>SQLiter allows you to create tables automatically based on your models:</p> <pre><code>db.create_table(User)\n</code></pre> <p>This creates a table for the <code>User</code> model, with fields based on the attributes of the model.</p>"},{"location":"guide/guide/#inserting-records","title":"Inserting Records","text":"<p>Inserting records is straightforward with SQLiter:</p> <pre><code>user = User(name=\"John Doe\", age=30, email=\"john@example.com\")\nnew_record = db.insert(user)\n</code></pre> <p>If successful, <code>new_record</code> will contain a model the same as was passed to it, but including the newly-created primary key value.</p>"},{"location":"guide/guide/#basic-queries","title":"Basic Queries","text":"<p>You can easily query all records from a table:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre>"},{"location":"guide/guide/#filtering-results","title":"Filtering Results","text":"<p>SQLiter allows filtering of results using various conditions:</p> <pre><code>young_users = db.select(User).filter(age__lt=30).fetch_all()\n</code></pre>"},{"location":"guide/guide/#fetching-records","title":"Fetching Records","text":"<p>SQLiter provides methods to fetch multiple, single, or the last record in a table.</p>"},{"location":"guide/guide/#fetching-all-records","title":"Fetching All Records","text":"<p>The <code>fetch_all()</code> method retrieves all records from the table that match the query or filter:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre> <p>This returns a list of all matching records. If no record matches, an empty list is returned.</p>"},{"location":"guide/guide/#fetching-one-record","title":"Fetching One Record","text":"<p>The <code>fetch_one()</code> method retrieves a single record that matches the query or filter:</p> <pre><code>result = db.select(User).filter(name=\"John Doe\").fetch_one()\n</code></pre> <p>If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#fetching-the-last-record","title":"Fetching the Last Record","text":"<p>The <code>fetch_last()</code> method retrieves the last record in the table, typically based on the <code>rowid</code>:</p> <pre><code>last_user = db.select(User).fetch_last()\n</code></pre> <p>This fetches the most recently inserted record. If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#updating-records","title":"Updating Records","text":"<p>Records can be updated seamlessly. Simply modify the fields of the model instance and pass that to the <code>update()</code> method:</p> <pre><code>user.age = 31\ndb.update(user)\n</code></pre>"},{"location":"guide/guide/#deleting-records","title":"Deleting Records","text":"<p>Deleting records is simple as well. You just need to pass the Model that defines your table and the primary key value of the record you want to delete:</p> <pre><code>db.delete(User, 1)\n</code></pre> <p>Note</p> <p>You can get the primary key value from the record or model instance itself, e.g., <code>new_record.pk</code> and pass that as the second argument to the <code>delete()</code> method:</p> <pre><code>db.delete(User, new_record.pk)\n</code></pre>"},{"location":"guide/guide/#advanced-query-features","title":"Advanced Query Features","text":""},{"location":"guide/guide/#ordering","title":"Ordering","text":"<p>SQLiter supports ordering of results by specific fields:</p> <pre><code>ordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre>"},{"location":"guide/guide/#limiting-and-offsetting","title":"Limiting and Offsetting","text":"<p>Pagination is supported through <code>limit()</code> and <code>offset()</code>:</p> <pre><code>paginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre>"},{"location":"guide/guide/#transactions","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager. This ensures that a group of operations are executed atomically, meaning either all of the operations succeed or none of them are applied.</p> <p>To use transactions, simply wrap the operations within a <code>with</code> block:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs here, both inserts will be rolled back\n</code></pre> <p>If an error occurs within the transaction block, all changes made inside the block will be rolled back automatically.</p> <p>If no errors occur, the transaction will commit and changes will be saved. The <code>close()</code> method will also be called when the context manager exits, so there is no need to call it manually.</p>"},{"location":"guide/guide/#closing-the-database","title":"Closing the Database","text":"<p>Always remember to close the connection when you're done:</p> <pre><code>db.close()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see above), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p> <p>This is a quick look at the core features of SQLiter. For more details on each functionality, see the next section.</p>"},{"location":"guide/models/","title":"Models","text":"<p>Each individual table in your database should be represented by a model. This model should inherit from <code>BaseDBModel</code> and define the fields that should be stored in the table. Under the hood, the model is a Pydantic model, so you can use all the features of Pydantic models, such as default values, type hints, and validation.</p>"},{"location":"guide/models/#defining-models","title":"Defining Models","text":"<p>Models are defined like this:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n</code></pre> <p>You can create as many Models as you need, each representing a different table in your database. The fields in the model will be used to create the columns in the table.</p> <p>Important</p> <ul> <li>Type-hints are REQUIRED for each field in the model.</li> <li>The Model automatically creates an auto-incrementing integer primary key for each table called <code>pk</code>, you do not need to define it yourself.</li> </ul>"},{"location":"guide/models/#adding-indexes","title":"Adding Indexes","text":"<p>You can add indexes to your table by specifying the <code>indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        indexes = [\"name\", \"email\"]\n</code></pre> <p>This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p>"},{"location":"guide/models/#adding-unique-indexes","title":"Adding Unique Indexes","text":"<p>You can add unique indexes to your table by specifying the <code>unique_indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        unique_indexes = [\"email\"]\n</code></pre> <p>These will ensure that all values in this field are unique. This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p> <p>Tip</p> <p>You can specify both <code>indexes</code> and <code>unique_indexes</code> in the <code>Meta</code> class if you need to.</p>"},{"location":"guide/models/#unique-fields","title":"Unique Fields","text":"<p>You can also specify that a field should be all unique values by using the <code>Unique()</code> method from the <code>sqliter.model</code> module. This will ensure that all values in this field are unique.</p> <pre><code>from typing import Annotated\nfrom sqliter.model import BaseDBModel, Unique\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: Annotated[str, Unique()]\n</code></pre> <p>This will raise either a <code>RecordInsertionError</code> or <code>RecordUpdateError</code> if you try to insert or update a record with a duplicate value in the chosen field.</p> <p>Tip</p> <p>Using <code>Annotated</code> is optional, but without it your code wil not pass type-checking with <code>mypy</code>. It will work fine at runtime but is not recommended:</p> <pre><code>email: str = Unique()\n</code></pre> <p>This will give the following Mypy error:</p> <pre><code>error: Incompatible types in assignment (expression has type \"Unique\", variable has type \"str\")  [assignment]\n</code></pre>"},{"location":"guide/models/#custom-table-name","title":"Custom Table Name","text":"<p>By default, the table name will be the same as the model name, converted to 'snake_case' and pluralized (e.g., <code>User</code> -&gt; <code>users</code>). Also, any 'Model' suffix will be removed (e.g., <code>UserModel</code> -&gt; <code>users</code>). To override this behavior, you can specify the <code>table_name</code> in the <code>Meta</code> class manually as below:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        table_name = \"people\"\n</code></pre> <p>Note</p> <p>The pluralization is pretty basic by default, and just consists of adding an 's' if not already there. This will fail on words like 'person' or 'child'. If you need more advanced pluralization, you can install the <code>extras</code> package as mentioned in the installation. Of course, you can always specify the <code>table_name</code> manually in this case!</p>"},{"location":"guide/models/#model-classmethods","title":"Model Classmethods","text":"<p>There are 2 useful methods you can call on your models. Note that they are Class Methods so should be called on the Model class itself, not an instance of the model:</p>"},{"location":"guide/models/#get_table_name","title":"<code>get_table_name()</code>","text":"<p>This method returns the actual table name for the model either specified or automatically generated. This is useful if you need to do any raw SQL queries.</p> <pre><code>table_name = User.get_table_name()\n</code></pre>"},{"location":"guide/models/#get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>This simply returns the name of the primary key for that table. At the moment, this will always return the string <code>pk</code> but this may change in the future.</p> <pre><code>primary_key = User.get_primary_key()\n</code></pre>"},{"location":"guide/ordering/","title":"Ordering","text":"<p>For now we only support ordering by the single field. You can specify the field to order by and whether to reverse the order:</p> <pre><code>results = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre> <p>This will order the results by the <code>age</code> field in descending order.</p> <p>If you do not specify a field, the default is to order by the primary key field:</p> <pre><code>results = db.select(User).order().fetch_all()\n</code></pre> <p>This will order the results by the primary key field in ascending order.</p> <p>Warning</p> <p>Previously ordering was done using the <code>direction</code> parameter with <code>asc</code> or <code>desc</code>, but this has been deprecated in favor of using the <code>reverse</code> parameter. The <code>direction</code> parameter still works, but will raise a <code>DeprecationWarning</code> and will be removed in a future release.</p>"},{"location":"guide/tables/","title":"Table Operations","text":"<p>All table operations work on a Pydantic Model you have defined based on <code>BaseDBModel</code>. You can have as many tables as you need, but each must have it's own Model defined.</p>"},{"location":"guide/tables/#creating-tables","title":"Creating Tables","text":"<p>To create a table, you simply pass your Model class to the <code>create_table()</code> method:</p> <pre><code>db.create_table(User)\n</code></pre> <p>Important</p> <p>The Table is created regardless of the <code>auto_commit</code> setting.</p> <p>By default, if the table already exists, it will not be created again and no error will be raised. If you want to raise an exception if the table already exists, you can set <code>exists_ok=False</code>:</p> <pre><code>db.create_table(User, exists_ok=False)\n</code></pre> <p>This will raise a <code>TableCreationError</code> if the table already exists.</p> <p>There is a complementary flag <code>force=True</code> which will drop the table if it exists and then recreate it. This may be useful if you are changing the table structure:</p> <pre><code>db.create_table(User, force=True)\n</code></pre> <p>This defaults to <code>False</code>.</p>"},{"location":"guide/tables/#dropping-tables","title":"Dropping Tables","text":"<p>To drop a table completely from the database use the <code>drop_table</code> method</p> <pre><code>db.drop_table(User)\n</code></pre> <p>Caution</p> <p>This is non-reversible and will you will lose all data in that table.</p> <p>The Table is dropped regardless of the <code>auto_commit</code> setting.</p>"},{"location":"guide/transactions/","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs, the transaction will be rolled back\n</code></pre> <p>Warning</p> <p>Using the context manager will automatically commit the transaction at the end (unless an exception occurs), regardless of the <code>auto_commit</code> setting.</p> <p>the <code>close()</code> method will also be called when the context manager exits, so you do not need to call it manually.</p>"},{"location":"todo/","title":"TODO","text":""},{"location":"todo/#general-plans-and-ideas","title":"General Plans and Ideas","text":"<ul> <li>add (optional) <code>created_at</code> and <code>updated_at</code> fields to the BaseDBModel class   which will be automatically updated when a record is created or updated.</li> <li>add attributes to the BaseDBModel to read the table-name, file-name, is-memory   etc.</li> <li>add an 'execute' method to the main class to allow executing arbitrary SQL   queries which can be chained to the 'find_first' etc methods or just used   directly.</li> <li>add a <code>delete</code> method to the QueryBuilder class to allow deleting   single/multiple records from the database based on the query. This is in   addition to the <code>delete</code> method in the main class which deletes a single   record based on the primary key.</li> <li>add a <code>rollback</code> method to the main class to allow manual rollbacks.</li> <li>allow adding foreign keys and relationships to each table.</li> <li>add a migration system to allow updating the database schema without losing   data.</li> <li>add more tests where 'auto_commit' is set to False to ensure that commit is   not called automatically.</li> <li>support structures like, <code>list</code>, <code>dict</code>, <code>set</code> etc. in the model. These will   need to be <code>pickled</code> first then stored as a BLOB in the database . Also   support <code>date</code> which can be stored as a Unix timestamp in an integer field.</li> </ul>"},{"location":"todo/#housekeeping","title":"Housekeeping","text":"<ul> <li>Tidy up the test suite - remove any duplicates, sort them into logical files   (many already are), try to reduce and centralize fixtures.</li> </ul>"},{"location":"todo/#documentation","title":"Documentation","text":"<ul> <li>Nothing at the moment.</li> </ul>"},{"location":"todo/#potential-filter-additions","title":"Potential Filter Additions","text":"<ul> <li>Range filter<ul> <li><code>__range</code>: For selecting values within a specific range</li> </ul> </li> </ul> <ul> <li>Date and time filters<ul> <li><code>__year</code>, <code>__month</code>, <code>__day</code>: For filtering date fields</li> <li><code>__date</code>: For filtering the date part of a datetime field</li> </ul> </li> </ul> <ul> <li>Regular expression filter<ul> <li><code>__regex</code>: For more complex string matching</li> </ul> </li> </ul> <ul> <li>Numeric operations<ul> <li><code>__abs</code>: Absolute value comparison</li> </ul> </li> </ul> <ul> <li>Boolean filters<ul> <li><code>__istrue</code>, <code>__isfalse</code>: Explicit boolean checks</li> </ul> </li> </ul> <ul> <li>List field operations<ul> <li><code>__contains_all</code>: Check if a list field contains all specified values</li> <li><code>__contains_any</code>: Check if a list field contains any of the specified values</li> </ul> </li> </ul> <ul> <li>Negation filter<ul> <li><code>__not</code>: General negation for other filters</li> </ul> </li> </ul> <ul> <li>Distinct filter<ul> <li><code>__distinct</code>: To get distinct values in a field</li> </ul> </li> </ul>"}]}