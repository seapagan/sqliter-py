{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLiter","text":"<p>SQLiter is a lightweight Object-Relational Mapping (ORM) library for SQLite databases in Python. It provides a simplified interface for interacting with SQLite databases using Pydantic models. The only external run-time dependency is Pydantic itself.</p> <p>It does not aim to be a full-fledged ORM like SQLAlchemy, but rather a simple and easy-to-use library for basic database operations, especially for small projects. It is NOT asynchronous and does not support complex queries (at this time).</p> <p>The ideal use case is more for Python CLI tools that need to store data in a database-like format without needing to learn SQL or use a full ORM.</p> <p>Caution</p> <p>This project is still in the early stages of development and is lacking some planned functionality. Please use with caution - Classes and methods may change until a stable release is made. I'll try to keep this to an absolute minimum and the releases and documentation will be very clear about any breaking changes.</p> <p>See the TODO for planned features and improvements.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Table creation based on Pydantic models</li> <li>Supports <code>date</code> and <code>datetime</code> fields.</li> <li>Support for complex data types (<code>list</code>, <code>dict</code>, <code>set</code>, <code>tuple</code>) stored as   BLOBs</li> <li>Foreign key relationships with referential integrity and CASCADE actions</li> <li>Automatic primary key generation</li> <li>User defined indexes on any field</li> <li>Set any field as UNIQUE</li> <li>CRUD operations (Create, Read, Update, Delete)</li> <li>Chained Query building with filtering, ordering, and pagination</li> <li>Transaction support</li> <li>Optional query result caching with LRU eviction, TTL, and memory limits</li> <li>Custom exceptions for better error handling</li> <li>Full type hinting and type checking</li> <li>Detailed documentation and examples</li> <li>No external dependencies other than Pydantic</li> <li>Full test coverage</li> <li>Can optionally output the raw SQL queries being executed for debugging   purposes.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install SQLiter using whichever method you prefer or is compatible with your project setup.</p> <p>With <code>uv</code> which is rapidly becoming my favorite tool for managing projects and virtual environments (<code>uv</code> is used for developing this project and in the CI):</p> <pre><code>uv add sqliter-py\n</code></pre> <p>With <code>Poetry</code>:</p> <pre><code>poetry add sqliter-py\n</code></pre> <p>Or with <code>pip</code>:</p> <pre><code>pip install sqliter-py\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Currently by default, the only external dependency is Pydantic. However, there are some optional dependencies that can be installed to enable additional features:</p> <ul> <li><code>inflect</code>: For pluralizing table names (if not specified). This just offers a   more-advanced pluralization than the default method used. In most cases you   will not need this.</li> </ul> <p>These can be installed using <code>uv</code>:</p> <pre><code>uv add 'sqliter-py[extras]'\n</code></pre> <p>With <code>Poetry</code>:</p> <pre><code>poetry add 'sqliter-py[extras]'\n</code></pre> <p>Or with <code>pip</code>:</p> <pre><code>pip install 'sqliter-py[extras]'\n</code></pre>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the terms of the MIT license below:</p> <pre><code>The MIT License (MIT)\nCopyright (c) 2024-2025 Grant Ramsay\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Here's a quick example of how to use SQLiter:</p> <pre><code>from typing import Optional\n\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\n# Define your model\nclass User(BaseDBModel):\n    name: str\n    age: int\n    admin: Optional[bool] = False\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n\n# Create the table\ndb.create_table(User)\n\n# Insert a record\nuser = User(name=\"John Doe\", age=30)\nnew_user = db.insert(user)\n\n# Query records\nresults = db.select(User).filter(name=\"John Doe\").fetch_all()\nfor user in results:\n    print(f\"User: {user.name}, Age: {user.age}, Admin: {user.admin}\")\n\n# Update a record\nnew_user.age = 31\ndb.update(new_user)\n\nresults = db.select(User).filter(name=\"John Doe\").fetch_one()\n\nprint(\"Updated age:\", results.age)\n\n# Delete a record by primary key\ndb.delete(User, new_user.pk)\n\n# Delete all records returned from a query:\ndelete_count = db.select(User).filter(age__gt=30).delete()\n</code></pre> <p>See the Guide for more detailed information on how to use <code>SQLiter</code>.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This is an auto-generated log of all the changes that have been made to the project since the first release, with the latest changes at the top.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0120-january-17-2026","title":"0.12.0 (January 17, 2026)","text":"<p>New Features</p> <ul> <li>Add foreign key support (Phase 1) (#99) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0110-january-11-2026","title":"0.11.0 (January 11, 2026)","text":"<p>New Features</p> <ul> <li>Add optional query result caching with LRU eviction (#96) by seapagan</li> <li>Migrate from pre-commit to prek (#94) by seapagan</li> </ul> <p>Security</p> <ul> <li>Fix security vulnerabilities in dependencies (#95) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#0100-december-15-2025","title":"0.10.0 (December 15, 2025)","text":"<p>Bug Fixes</p> <ul> <li>Ensure python 3.14 compatability (#87) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#091-december-09-2025","title":"0.9.1 (December 09, 2025)","text":"<p>Dependency Updates</p> <ul> <li>Bump requests from 2.32.3 to 2.32.4 (#85) by dependabot[bot]</li> <li>Bump urllib3 from 2.4.0 to 2.6.0 (#83) by dependabot[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#090-december-09-2025","title":"0.9.0 (December 09, 2025)","text":"<p>[!CAUTION]</p> <p>This library is currently NOT compatible with Python 3.14. I am working on fixing this.</p> <p>New Features</p> <ul> <li>Mark as typed library and update deps (#81) by seapagan</li> <li>Update ruff and fix linting issues; improve logging in demo (#70) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Bump urllib3 from 2.4.0 to 2.6.0 (#80) by dependabot[bot]</li> <li>Chore(deps): update actions/checkout action to v6 (#79) by renovate[bot]</li> <li>Chore(deps): update astral-sh/setup-uv action to v7 (#78) by renovate[bot]</li> <li>Bump requests from 2.32.3 to 2.32.4 (#75) by dependabot[bot]</li> <li>Chore(deps): update astral-sh/setup-uv action to v6 (#72) by renovate[bot]</li> <li>Bump jinja2 from 3.1.5 to 3.1.6 (#68) by dependabot[bot]</li> <li>Bump cryptography from 44.0.0 to 44.0.1 (#66) by dependabot[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#080-january-28-2025","title":"0.8.0 (January 28, 2025)","text":"<p>New Features</p> <ul> <li>Implement list, dict, tuple and set as valid field types (#63) by seapagan</li> <li>Add delete() method to QueryBuilder with comprehensive test coverage (#61) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Update astral-sh/setup-uv action to v5 (#59) by renovate[bot]</li> <li>Update astral-sh/setup-uv action to v4 (#57) by renovate[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#070-october-31-2024","title":"0.7.0 (October 31, 2024)","text":"<p>New Features</p> <ul> <li>Support the <code>date</code> and <code>datetime</code> types (#52) by seapagan</li> <li>Add <code>created_at</code> and <code>updated_at</code> timestamps to the BaseDBModel (#49) by seapagan</li> <li>Add some useful properties to the SqliterDB class instance (#48) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix missing commits from the previous PR (#49) (#50) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#060-october-12-2024","title":"0.6.0 (October 12, 2024)","text":"<p>New Features</p> <ul> <li>Add ability to mark a field as UNIQUE (#46) by seapagan</li> <li>Implement user-defined indexes (#45) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context-manager ignores the <code>auto_commit</code> setting. (#43) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#050-september-30-2024","title":"0.5.0 (September 30, 2024)","text":"<p>Breaking Change!</p> <p>This release removes the <code>create_pk</code> and <code>primary_key</code> attributes from the Model <code>Meta</code> Class. Now, an auto-incrementing primary key is created by default and the name of the primary key is always <code>pk</code>.</p> <p>Closed Issues</p> <ul> <li>Auto-generated primary key not returned by the Model (#37) by seapagan</li> </ul> <p>Breaking Changes</p> <ul> <li>Always create a <code>pk</code> primary auto-incrementing key (#39) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Fix <code>null</code> filter when combined with others and add tests (#40) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Refactor web docs layout and improve content (#36) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#040-september-27-2024","title":"0.4.0 (September 27, 2024)","text":"<p>New Features</p> <ul> <li>Add <code>exists_ok</code> and <code>force</code> flags to <code>create_table</code> (#34) by seapagan</li> <li>Add <code>reset=</code> to SqliterDB(), to drop all existing tables (#33) by seapagan</li> <li>Order by primary key if no field specified to <code>order()</code> (#32) by seapagan</li> <li>Add <code>drop_table</code> method (#31) by seapagan</li> <li>Add debug logging option (#29) by seapagan</li> <li>Create relevant database fields depending on the Model types (#27) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add test coverage where missing (#28) by seapagan</li> </ul> <p>Refactoring</p> <ul> <li>Perform some internal refactoring, mostly arranging the tests. (#30) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Add a documentation website and trim down the README (#25) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#030-september-23-2024","title":"0.3.0 (September 23, 2024)","text":"<p>Breaking Changes</p> <ul> <li>Rename 'create_id' to 'create_pk' (#23) by seapagan</li> </ul> <p>New Features</p> <ul> <li>Deprecate 'direction=' for 'reverse=' in <code>order()</code> method. (#24) by seapagan</li> <li>Add improved table name generation (#21) by seapagan</li> <li>Implement an in-memory database option (#15) by seapagan</li> <li>Allow selecting a subset of the database fields instead of all them (#12) by seapagan</li> <li>Improve dev tooling and contributor documentation (#11) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Update dependency ruff to v0.6.7 (#19) by renovate[bot]</li> <li>Update dependency pydantic to v2.9.2 (#18) by renovate[bot]</li> <li>Update dependency idna to v3.10 (#17) by renovate[bot]</li> <li>Update dependency zipp to v3.20.2 (#16) by renovate[bot]</li> <li>Update astral-sh/setup-uv action to v3 (#10) by renovate[bot]</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#020-september-14-2024","title":"0.2.0 (September 14, 2024)","text":"<p>New Features</p> <ul> <li>Default to auto_create=True, and add 'commit()' &amp; 'close()' methods (#9) by seapagan</li> <li>Add more advanced filtering options (#7) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensure context manager commits on exit (#8) by seapagan</li> </ul> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#011-september-12-2024","title":"0.1.1 (September 12, 2024)","text":"<p>Just a documentation fix - README was old version</p> <p><code>Full Changelog</code> | <code>Diff</code> | <code>Patch</code></p>"},{"location":"changelog/#010-september-12-2024","title":"0.1.0 (September 12, 2024)","text":"<p>New Features</p> <ul> <li>Remove transaction exception (TransactionError) (#4) by seapagan</li> <li>Improve error handling across the library (#3) by seapagan</li> <li>Add 'limit', 'offset' and 'order' methods (#2) by seapagan</li> </ul> <p>Testing</p> <ul> <li>Add a full test suite to the existing code. (#1) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Configure Renovate (#5) by renovate[bot]</li> </ul> <p>This changelog was generated using github-changelog-md by Seapagan</p>"},{"location":"contributing/","title":"Contributing to SQLiter","text":"<p>Thank you for your interest in contributing to SQLiter! We welcome all contributions, big or small.</p> <p>If you are not sure where to start, please take a look at the open issues. If you have an idea for a new feature or would like to report a bug, please open a new issue.</p> <p>We also welcome contributions to the documentation. If you find any errors or would like to suggest improvements, please open a new issue or submit a pull</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>This project requires Python 3.9 or higher.</li> </ul> <ul> <li>We use uv to manage our dependencies. You should have this installed as well. You can install <code>uv</code> by following the instructions on their website.</li> </ul> <p><code>uv</code> can be used to actually install Python, even if you do not have it installed locally (either by system, pyenv or similar).</p> <p>For example, to install Python 3.12 using <code>uv</code>, you can run the following command:</p> <pre><code>uv python install 3.12\n</code></pre> <p>If you already have a Python version installed, uv will use this.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please make sure you have read and understood our Code of Conduct and License.</p> <p>To get started, follow these steps:</p> <ol> <li>Fork the repository and clone it to your local machine.</li> <li>Install the required dependencies (see next section).</li> <li>Create a new branch for your changes: <code>git checkout -b my-new-feature</code>.</li> <li>Make your changes and commit them: <code>git commit -am 'Add some feature'</code>.</li> <li>Push your changes to your fork: <code>git push origin my-new-feature</code>.</li> <li>Create a new pull request.</li> </ol>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Run the following command to create a local virtualenv and install the required dependencies. We need the optional extras installed so the tests pass:</p> <pre><code>uv sync --all-extras\n</code></pre> <p>The <code>.venv</code> folder is already in the <code>.gitignore</code> file so will not be committed to the repository. This is where the virtual environment will be created.</p> <p>You then need to activate the virtual environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>From here you can start working on the project. If you are using an IDE such as VSCode or PyCharm, you can set their Python interpreter setting to use the virtual environment that has just been created.</p>"},{"location":"contributing/#install-git-pre-commit-hooks","title":"Install Git Pre-Commit hooks","text":"<p>Please do this if you are intending to submit a PR. It will check commits locally before they are pushed up to the Repo.</p> <pre><code>$ prek install\nprek installed at .git/hooks/pre-commit\n</code></pre> <p>This will ensure that all code meets the required linting standard before being committed.</p>"},{"location":"contributing/#run-checks-manually","title":"Run checks manually","text":"<p>You can run these checks manually on all staged files using the below command :</p> <pre><code>poe pre\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using pytest for testing. Tests will automatically be run when you submit a pull request. You can also run them manually using the following command:</p> <pre><code>pytest\n</code></pre> <p>If you add any new features, please add tests for them. This will help us to ensure that the code is working as expected and will prevent any regressions.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>The changelog is automatically generated using github-changelog-md, so please do not edit it manually.</p> <p>For maintainers, there is a POE task that will run this and update the changelog file.</p> <pre><code>poe changelog\n</code></pre> <p>You would also need to add a GitHub Personal Access Token to a local config file as usual. See the section in that tools Documentation for information.</p> <p>However, you should NOT include a change to the <code>CHANGELOG.md</code> file in any Pull Requests. This will be handled by the maintainers when a new release is made. Your GitHub username will be added to the changelog automatically beside your PR.</p>"},{"location":"contributing/#convenience-tasks","title":"Convenience Tasks","text":"<p>There are a few other convenience tasks that can be run using the <code>poe</code> command. These are defined in the <code>pyproject.toml</code> file.</p> <p>Each of these tasks can have extra options added which will be passed to the underlying tool.</p> <p>Run <code>mypy</code> on the code base in strict mode:</p> <pre><code>poe mypy\n</code></pre> <p>Format the code using <code>ruff format</code>:</p> <pre><code>poe format\n</code></pre> <p>Lint the code using <code>ruff check</code>:</p> <pre><code>poe ruff\n</code></pre>"},{"location":"contributing/#documentation-tasks","title":"Documentation Tasks","text":"<p>These are to help with developing and updating the documentation.</p> <ul> <li><code>poe docs:serve</code> - Serve the MkDocs locally for testing and development</li> <li><code>poe docs:serve:all</code> - Same as above, but opens to all interfaces so you can   view it on other devices on your network</li> <li><code>poe docs:build</code> - Build the MkDocs site into the <code>dist</code> folder</li> <li><code>poe docs:publish</code> - Publish the docs to your GitHub pages. Note that only   those with write-access to this repo can do this.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<p>Here are some guidelines to follow when contributing to SQLiter:</p> <ul> <li>Do not update the version number in the <code>pyproject.toml</code> file. This will be   done by the maintainers when a new release is made.</li> <li>Follow the PEP 8 style guide. The   prek hooks will check for this. We are using   Ruff as both a linter and code formatter.</li> <li>Try to have no linting errors or warnings. The prek hooks will check for   this also.</li> <li>MyPy is installed and we are using   type hints. Please try to add type hints to your code. If you see any areas of   the code that are missing type hints, please feel free to open a PR and add   them \ud83d\ude01!</li> <li>Write clear and concise commit messages.</li> <li>Write tests for your code.</li> <li>Make sure your code passes all tests before submitting a pull request.</li> <li>Document your code using   docstrings.</li> <li>Use GitHub issues   to report bugs or suggest new features.</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>If you have any questions or need help with contributing, please contact me @seapagan on GitHub. You can also use the GitHub Discussions feature.</p> <p>Happy contributing!</p>"},{"location":"guide/caching/","title":"Query Result Caching","text":"<p>SQLiter provides optional query result caching to improve performance by reducing database queries for frequently accessed data. The cache uses an LRU (Least Recently Used) eviction strategy and automatically invalidates when data is modified.</p>"},{"location":"guide/caching/#enabling-caching","title":"Enabling Caching","text":"<p>Caching is opt-in and disabled by default. To enable caching, set <code>cache_enabled=True</code> when creating the database connection:</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(\"my_database.db\", cache_enabled=True)\n</code></pre>"},{"location":"guide/caching/#cache-configuration","title":"Cache Configuration","text":""},{"location":"guide/caching/#basic-configuration","title":"Basic Configuration","text":"<pre><code>db = SqliterDB(\n    \"my_database.db\",\n    cache_enabled=True,      # Enable caching (required)\n    cache_max_size=1000,     # Max cached queries per table (default: 1000)\n    cache_ttl=60,            # Time-to-live in seconds (default: None)\n    cache_max_memory_mb=100, # Memory limit per table in MB (default: None)\n)\n</code></pre>"},{"location":"guide/caching/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>cache_enabled</code> (<code>bool</code>, default: <code>False</code>): Enable or disable caching.</li> <li><code>cache_max_size</code> (<code>int</code>, default: <code>1000</code>): Maximum number of cached query   results per table. When exceeded, the least recently used entries are evicted.</li> <li><code>cache_ttl</code> (<code>int | None</code>, default: <code>None</code>): Default time-to-live for cached   results, in seconds. After this time, entries expire and are removed on next   access.</li> <li><code>cache_max_memory_mb</code> (<code>int | None</code>, default: <code>None</code>): Optional memory   limit per table, in megabytes. When exceeded, the least recently used entries   are evicted until under the limit.</li> </ul>"},{"location":"guide/caching/#how-caching-works","title":"How Caching Works","text":""},{"location":"guide/caching/#cache-key-generation","title":"Cache Key Generation","text":"<p>Each query generates a unique cache key based on:</p> <ul> <li>Table name</li> <li>Selected fields</li> <li>Filter conditions</li> <li>Order by clauses</li> <li>Limit and offset values</li> <li>Fetch mode (single vs list)</li> </ul> <p>This means different queries produce different cache entries:</p> <pre><code># These are cached separately\ndb.select(User).filter(name=\"Alice\").fetch_all()\ndb.select(User).filter(name=\"Bob\").fetch_all()\n\n# These are also cached separately (different fields)\ndb.select(User).only(\"name\").fetch_all()\ndb.select(User).fetch_all()\n</code></pre>"},{"location":"guide/caching/#cache-invalidation","title":"Cache Invalidation","text":"<p>The cache automatically invalidates when data is modified. Any write operation (insert, update, delete) on a table clears all cached queries for that table:</p> <pre><code># Query and cache the result\nusers = db.select(User).fetch_all()  # Cached\n\n# Insert new data - INVALIDATES cache for User table\ndb.insert(User(name=\"Charlie\", age=25))\n\n# This query hits the database again (cache was invalidated)\nusers = db.select(User).fetch_all()\n</code></pre>"},{"location":"guide/caching/#per-instance-scope","title":"Per-Instance Scope","text":"<p>The cache is tied to the database connection instance and is automatically cleared when:</p> <ul> <li>The connection is closed: <code>db.close()</code></li> <li>Exiting a context manager: <code>with SqliterDB(...) as db:</code></li> <li>The connection is deleted</li> </ul> <pre><code>with SqliterDB(\"mydb.db\", cache_enabled=True) as db:\n    db.select(User).fetch_all()  # Cached\n    # Cache is cleared when exiting context\n# Cache is empty here\n</code></pre>"},{"location":"guide/caching/#limitations","title":"Limitations","text":""},{"location":"guide/caching/#cache-key-type-compatibility","title":"Cache Key Type Compatibility","text":"<p>Cache keys are generated by sorting filter conditions to ensure consistency. This requires that filter values be comparable with each other.</p> <p>\u274c This will fail:</p> <pre><code># First query succeeds\ndb.select(User).filter(name=\"Alice\", age=30).fetch_all()\n\n# Second query fails at fetch time when generating cache key\ndb.select(User).filter(name=42, age=30).fetch_all()  # ValueError!\n</code></pre> <p>The second query fails when <code>fetch_all()</code> is called because Python cannot sort mixed types (strings vs numbers) when generating the cache key. The <code>filter()</code> call itself succeeds - the error occurs during cache key generation.</p> <p>\u2713 Correct usage:</p> <pre><code># Use consistent types for each field\ndb.select(User).filter(name=\"Alice\", age=30).fetch_all()\ndb.select(User).filter(name=\"Bob\", age=40).fetch_all()  # Works fine\n</code></pre> <p>This limitation only affects queries with incompatible value types for the same field. Normal filtering patterns (strings, numbers, dates used consistently) work without issues.</p>"},{"location":"guide/caching/#cache-statistics","title":"Cache Statistics","text":"<p>Track cache performance with the <code>get_cache_stats()</code> method:</p> <pre><code>stats = db.get_cache_stats()\nprint(stats)\n# Output: {\"hits\": 150, \"misses\": 50, \"total\": 200, \"hit_rate\": 75.0}\n</code></pre> <ul> <li><code>hits</code>: Number of times a cached result was returned</li> <li><code>misses</code>: Number of times the database was queried (cache miss)</li> <li><code>total</code>: Total cache lookups (hits + misses)</li> <li><code>hit_rate</code>: Percentage of cache hits (0-100)</li> </ul>"},{"location":"guide/caching/#query-level-controls","title":"Query-Level Controls","text":""},{"location":"guide/caching/#bypassing-the-cache","title":"Bypassing the Cache","text":"<p>Force a specific query to skip the cache and always fetch fresh data from the database:</p> <pre><code># Force fresh data, bypassing cache\nuser = db.select(User).filter(name=\"Alice\").bypass_cache().fetch_one()\n</code></pre> <p>Use cases:</p> <ul> <li>Fetching real-time data that may have changed externally</li> <li>Debugging queries to verify database content</li> <li>Admin operations that require absolute freshness</li> </ul>"},{"location":"guide/caching/#per-query-ttl","title":"Per-Query TTL","text":"<p>Override the global <code>cache_ttl</code> setting for a specific query:</p> <pre><code># Cache this result for 5 minutes (300 seconds)\nusers = db.select(User).cache_ttl(300).fetch_all()\n</code></pre> <p>Use cases:</p> <ul> <li>Shorter TTL for frequently changing data</li> <li>Longer TTL for rarely changing reference data</li> <li>Different TTL requirements for different query types</li> </ul>"},{"location":"guide/caching/#empty-result-caching","title":"Empty Result Caching","text":"<p>Both <code>None</code> and empty list <code>[]</code> results are cached:</p> <pre><code># Query that returns no result (fetch_one)\nresult = db.select(User).filter(name=\"NonExistent\").fetch_one()\n# Returns: None (cached)\n\n# Query that returns no results (fetch_all)\nresults = db.select(User).filter(age__gt=200).fetch_all()\n# Returns: [] (cached)\n</code></pre>"},{"location":"guide/caching/#memory-limiting","title":"Memory Limiting","text":"<p>Use <code>cache_max_memory_mb</code> to prevent the cache from consuming too much memory:</p> <pre><code># Limit cache to 10MB per table\ndb = SqliterDB(\"mydb.db\", cache_enabled=True, cache_max_memory_mb=10)\n</code></pre> <p>When the memory limit is exceeded:</p> <ol> <li>The cache evicts the least recently used entries</li> <li>Continues evicting until there's room for the new entry</li> <li>Memory usage is tracked per table</li> </ol>"},{"location":"guide/caching/#best-practices","title":"Best Practices","text":""},{"location":"guide/caching/#when-to-enable-caching","title":"When to Enable Caching","text":"<p>Caching is beneficial when:</p> <ul> <li>You have read-heavy workloads</li> <li>The same queries are executed repeatedly</li> <li>Data doesn't change frequently</li> <li>Query execution time is significant</li> </ul>"},{"location":"guide/caching/#when-to-bypass-cache","title":"When to Bypass Cache","text":"<p>Use <code>bypass_cache()</code> when:</p> <ul> <li>You need guaranteed fresh data</li> <li>Debugging data consistency issues</li> <li>Performing administrative operations</li> </ul>"},{"location":"guide/caching/#ttl-guidelines","title":"TTL Guidelines","text":"<ul> <li>Short TTL (1-60 seconds): Frequently changing data, user sessions</li> <li>Medium TTL (1-10 minutes): Moderately changing data, dashboards</li> <li>Long TTL (10+ minutes): Rarely changing data, configuration/reference data</li> <li>No TTL: Cache until invalidated by writes</li> </ul>"},{"location":"guide/caching/#memory-limits","title":"Memory Limits","text":"<p>Set <code>cache_max_memory_mb</code> when:</p> <ul> <li>Running in memory-constrained environments</li> <li>Caching large result sets</li> <li>Preventing cache from growing unbounded</li> </ul>"},{"location":"guide/caching/#trade-offs","title":"Trade-offs","text":""},{"location":"guide/caching/#advantages","title":"Advantages","text":"<ul> <li>Reduced database load: Fewer queries hit the database</li> <li>Faster response times: Cached results return instantly</li> <li>Lower CPU usage: Avoid query parsing and execution overhead</li> <li>Better scalability: Handle more read requests with same resources</li> </ul>"},{"location":"guide/caching/#disadvantages","title":"Disadvantages","text":"<ul> <li>Memory consumption: Cached data occupies RAM</li> <li>Stale data risk: Cache may serve outdated data until invalidated</li> <li>Complexity: Additional configuration and monitoring</li> <li>Memory overhead: Each cached entry uses memory for objects and metadata</li> </ul>"},{"location":"guide/caching/#recommendations","title":"Recommendations","text":"<ul> <li>Start with caching disabled, enable only when needed</li> <li>Monitor cache statistics to measure effectiveness</li> <li>Use memory limits to prevent unbounded growth</li> <li>Set appropriate TTLs based on data change frequency</li> <li>Profile before and after to measure performance gains</li> </ul>"},{"location":"guide/connecting/","title":"Connecting to the Database","text":""},{"location":"guide/connecting/#creating-a-connection","title":"Creating a Connection","text":"<p>To connect to a database (and create the file if it does not already exist), you create an instance of the <code>SqliterDB</code> class. This will automatically take care of connecting to or creating the database file.</p> <pre><code>from sqliter import SqliterDB\n\ndb = SqliterDB(\"your_database.db\")\n</code></pre> <p>The default behavior is to automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>It is then up to you to manually commit changes using the <code>commit()</code> method. This can be useful when you want to perform multiple operations in a single transaction without the overhead of committing after each operation.</p>"},{"location":"guide/connecting/#using-an-in-memory-database","title":"Using an In-Memory Database","text":"<p>If you want to use an in-memory database, you can set <code>memory=True</code> when creating the database connection:</p> <pre><code>db = SqliterDB(memory=True)\n</code></pre> <p>This will create an in-memory database that is not persisted to disk. If you also specify a database name, it will be ignored.</p> <pre><code>db = SqliterDB(\"ignored.db\", memory=True)\n</code></pre> <p>The <code>ignored.db</code> file will not be created, and the database will be in-memory. If you do not specify a database name, and do NOT set <code>memory=True</code>, an exception will be raised.</p> <p>Note</p> <p>You can also use <code>\":memory:\"</code> as the database name (same as normal with Sqlite) to create an in-memory database, this is just a cleaner and more descriptive way to do it.</p> <pre><code>db = SqliterDB(\":memory:\")\n</code></pre>"},{"location":"guide/connecting/#resetting-the-database","title":"Resetting the Database","text":"<p>If you want to reset an existing database when you create the SqliterDB object, you can pass <code>reset=True</code>:</p> <pre><code>db = SqliterDB(\"your_database.db\", reset=True)\n</code></pre> <p>This will effectively drop all user tables from the database. The file itself is not deleted, only the tables are dropped.</p>"},{"location":"guide/connecting/#caching-options","title":"Caching Options","text":"<p>SQLiter provides optional query result caching to improve performance by reducing database queries. See the Caching page for detailed information.</p> <pre><code>db = SqliterDB(\n    \"your_database.db\",\n    cache_enabled=True,        # Enable caching (default: False)\n    cache_max_size=1000,       # Max cached queries per table\n    cache_ttl=60,              # Time-to-live in seconds (None = no expiry)\n    cache_max_memory_mb=100,   # Memory limit per table in MB\n)\n</code></pre>"},{"location":"guide/connecting/#database-properties","title":"Database Properties","text":"<p>The <code>SqliterDB</code> class provides several properties to access information about the database instance once it has been created. See the Properties page (next) for more details.</p>"},{"location":"guide/data-operations/","title":"Data Operations","text":""},{"location":"guide/data-operations/#inserting-records","title":"Inserting Records","text":"<p>The <code>insert()</code> method is used to add records to the database. You pass an instance of your model class to the method, and SQLiter will insert the record into the correct table:</p> <pre><code>user = User(name=\"Jane Doe\", age=25, email=\"jane@example.com\")\nresult = db.insert(user)\n</code></pre> <p>The <code>result</code> variable will contain a new instance of the model, with the primary key value set to the newly-created primary key in the database. You should use this instance to access the primary key value and other fields:</p> <pre><code>print(f\"New record inserted with primary key: {result.pk}\")\nprint(f\"Name: {result.name}, Age: {result.age}, Email: {result.email}\")\n</code></pre>"},{"location":"guide/data-operations/#overriding-the-timestamps","title":"Overriding the Timestamps","text":"<p>By default, SQLiter will automatically set the <code>created_at</code> and <code>updated_at</code> fields to the current Unix timestamp in UTC when a record is inserted. If you want to override this behavior, you can set the <code>created_at</code> and <code>updated_at</code> fields manually before calling <code>insert()</code>:</p> <pre><code>import time\n\nuser.created_at = int(time.time())\nuser.updated_at = int(time.time())\n</code></pre> <p>However, by default this is disabled. Any model passed to <code>insert()</code> will have the <code>created_at</code> and <code>updated_at</code> fields set automatically and ignore any values passed in these 2 fields.</p> <p>If you want to enable this feature, you can set the <code>timestamp_override</code> flag to <code>True</code> when inserting the record:</p> <pre><code>result = db.insert(user, timestamp_override=True)\n</code></pre> <p>Important</p> <p>The <code>insert()</code> method will raise a <code>RecordInsertionError</code> if you try to insert a record with a primary key that already exists in the table or if the table does not exist.</p>"},{"location":"guide/data-operations/#querying-records","title":"Querying Records","text":"<p><code>SQLiter</code> provides a simple and intuitive API for querying records from the database, Starting with the <code>select()</code> method and chaining other methods to filter, order, limit, and offset the results:</p> <pre><code># Fetch all users\nall_users = db.select(User).fetch_all()\n\n# Filter users\nyoung_users = db.select(User).filter(age=25).fetch_all()\n\n# Order users\nordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n\n# Limit and offset\npaginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre> <p>Important</p> <p>The <code>select()</code> MUST come first, before any filtering, ordering, or pagination etc. This is the starting point for building your query.</p> <p>See Filtering Results for more advanced filtering options.</p>"},{"location":"guide/data-operations/#updating-records","title":"Updating Records","text":"<p>You can update records in the database by modifying the fields of the model instance and then calling the <code>update()</code> method. You just pass the model instance to the method:</p> <pre><code>user.age = 26\ndb.update(user)\n</code></pre> <p>Important</p> <p>The model you pass must have a primary key value set, otherwise an error will be raised. In other words, you use the instance of a model returned by the <code>insert()</code> method to update the record as it has the primary key value set, not the original instance you passed to <code>insert()</code>.</p> <p>You can also set the primary key value on the model instance manually before calling <code>update()</code> if you have that.</p> <p>On suffescul update, the <code>updated_at</code> field will be set to the current Unix timestamp in UTC by default.</p> <p>Warning</p> <p>Unlike with the <code>insert()</code> method, you CANNOT override the <code>updated_at</code> field when calling <code>update()</code>. It will always be set to the current Unix timestamp in UTC. This is to ensure that the <code>updated_at</code> field is always accurate.</p>"},{"location":"guide/data-operations/#deleting-records","title":"Deleting Records","text":"<p>SQLiter provides two ways to delete records:</p>"},{"location":"guide/data-operations/#single-record-deletion","title":"Single Record Deletion","text":"<p>To delete a single record from the database by its primary key, use the <code>delete()</code> method directly on the database instance:</p> <pre><code>db.delete(User, user.pk)\n</code></pre> <p>Important</p> <p>The single record deletion method will raise:</p> <ul> <li><code>RecordNotFoundError</code> if the record with the specified primary key is not found</li> <li><code>RecordDeletionError</code> if there's an error during the deletion process</li> </ul>"},{"location":"guide/data-operations/#query-based-deletion","title":"Query-Based Deletion","text":"<p>You can also use a query to delete records that match specific criteria. The <code>delete()</code> method will delete all records returned by the query and return an integer with the count of records deleted:</p> <pre><code># Delete all users over 30\ndeleted_count = db.select(User).filter(age__gt=30).delete()\n\n# Delete inactive users in a specific age range\ndeleted_count = db.select(User).filter(\n    age__gte=25,\n    age__lt=40,\n    status=\"inactive\"\n).delete()\n\n# Delete all records from a table\ndeleted_count = db.select(User).delete()\n</code></pre> <p>Note</p> <p>The query-based delete operation ignores any <code>limit()</code>, <code>offset()</code>, or <code>order()</code> clauses that might be in the query chain. It will always delete ALL records that match the filter conditions.</p>"},{"location":"guide/data-operations/#commit-your-changes","title":"Commit your changes","text":"<p>By default, SQLiter will automatically commit changes to the database after each operation. If you want to disable this behavior, you can set <code>auto_commit=False</code> when creating the database connection:</p> <pre><code>db = SqliterDB(\"your_database.db\", auto_commit=False)\n</code></pre> <p>You can then manually commit changes using the <code>commit()</code> method:</p> <pre><code>db.commit()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>commit()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/data-operations/#close-the-connection","title":"Close the Connection","text":"<p>When you're done with the database connection, you should close it to release resources:</p> <pre><code>db.close()\n</code></pre> <p>Note that closing the connection will also commit any pending changes, unless <code>auto_commit</code> is set to <code>False</code>.</p> <p>Note</p> <p>If you are using the database connection as a context manager (see tansactions), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p>"},{"location":"guide/debug/","title":"Debug Logging","text":"<p>You can enable debug logging to see the SQL queries being executed by SQLiter. This can be useful for debugging and understanding the behavior of your application. It is disabled by default, and can be set on the <code>SqliterDB</code> class:</p> <pre><code>db = SqliterDB(\"your_database.db\", debug=True)\n</code></pre> <p>This will print the SQL queries to the console as they are executed. If there is an existing logger in your application then SQLiter will use that logger, otherwise it will create and use a new logger named <code>sqliter</code>.</p>"},{"location":"guide/exceptions/","title":"Exceptions","text":"<p>SQLiter includes several custom exceptions to handle specific errors that may occur during database operations. These exceptions inherit from a common base class, <code>SqliterError</code>, to ensure consistency across error messages and behavior.</p> <ul> <li><code>SqliterError</code>:<ul> <li>The base class for all exceptions in SQLiter. It captures the exception   context and chains any previous exceptions.</li> <li>Message: \"An error occurred in the SQLiter package.\"</li> </ul> </li> </ul> <ul> <li><code>DatabaseConnectionError</code>:<ul> <li>Raised when the SQLite database connection fails.</li> <li>Message: \"Failed to connect to the database: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOffsetError</code>:<ul> <li>Raised when an invalid offset value (0 or negative) is used in queries.</li> <li>Message: \"Invalid offset value: '{}'. Offset must be a positive   integer.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidOrderError</code>:<ul> <li>Raised when an invalid order value is used in queries, such as a   non-existent field or an incorrect sorting direction.</li> <li>Message: \"Invalid order value - '{}'\"</li> </ul> </li> </ul> <ul> <li><code>TableCreationError</code>:<ul> <li>Raised when a table cannot be created in the database.</li> <li>Message: \"Failed to create the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordInsertionError</code>:<ul> <li>Raised when an error occurs during record insertion.</li> <li>Message: \"Failed to insert record into table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordUpdateError</code>:<ul> <li>Raised when an error occurs during record update.</li> <li>Message: \"Failed to update record in table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordNotFoundError</code>:<ul> <li>Raised when a record with the specified primary key is not found.</li> <li>Message: \"Failed to find a record for key '{}'\".</li> </ul> </li> </ul> <ul> <li><code>RecordFetchError</code>:<ul> <li>Raised when an error occurs while fetching records from the database.</li> <li>Message: \"Failed to fetch record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>RecordDeletionError</code>:<ul> <li>Raised when an error occurs during record deletion.</li> <li>Message: \"Failed to delete record from table: '{}'.\"</li> </ul> </li> </ul> <ul> <li><code>InvalidFilterError</code>:<ul> <li>Raised when an invalid filter field is used in a query.</li> <li>Message: \"Failed to apply filter: invalid field '{}'\".</li> </ul> </li> </ul> <ul> <li><code>TableDeletionError</code>:<ul> <li>Raised when a table cannot be deleted from the database.</li> <li>Message: \"Failed to delete the table: '{}'.\"</li> </ul> </li> </ul> <ul> <li>SqlExecutionError<ul> <li>Raised when an error occurs during SQL query execution.</li> <li>Message: \"Failed to execute SQL: '{}'.\"</li> </ul> </li> </ul> <ul> <li>InvalidIndexError<ul> <li>Raised when an invalid index is specified for a model.</li> <li>Message: \"Invalid fields for indexing in model '{}': {}\"</li> </ul> </li> </ul>"},{"location":"guide/fields/","title":"Field Control","text":""},{"location":"guide/fields/#selecting-specific-fields","title":"Selecting Specific Fields","text":"<p>By default, all commands query and return all fields in the table. If you want to select only specific fields, you can pass them using the <code>fields()</code> method:</p> <pre><code>results = db.select(User).fields([\"name\", \"age\"]).fetch_all()\n</code></pre> <p>This will return only the <code>name</code> and <code>age</code> fields for each record.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, fields=[\"name\", \"age\"]).fetch_all()\n</code></pre> <p>Note that using the <code>fields()</code> method will override any fields specified in the 'select()' method.</p>"},{"location":"guide/fields/#excluding-specific-fields","title":"Excluding Specific Fields","text":"<p>If you want to exclude specific fields from the results, you can use the <code>exclude()</code> method:</p> <pre><code>results = db.select(User).exclude([\"email\"]).fetch_all()\n</code></pre> <p>This will return all fields except the <code>email</code> field.</p> <p>You can also pass this as a parameter to the <code>select()</code> method:</p> <pre><code>results = db.select(User, exclude=[\"email\"]).fetch_all()\n</code></pre>"},{"location":"guide/fields/#returning-exactly-one-explicit-field-only","title":"Returning exactly one explicit field only","text":"<p>If you only want to return a single field from the results, you can use the <code>only()</code> method:</p> <pre><code>result = db.select(User).only(\"name\").fetch_first()\n</code></pre> <p>This will return only the <code>name</code> field for the first record.</p> <p>This is exactly the same as using the <code>fields()</code> method with a single field, but very specific and obvious. There is NO equivalent argument to this in the <code>select()</code> method. An exception WILL be raised if you try to use this method with more than one field.</p>"},{"location":"guide/fields/#complex-data-types","title":"Complex Data Types","text":"<p>SQLiter supports storing complex Python data types in the database. The following types are supported:</p> <ul> <li><code>list[T]</code>: Lists of any type T</li> <li><code>dict[K, V]</code>: Dictionaries with keys of type K and values of type V</li> <li><code>set[T]</code>: Sets of any type T</li> <li><code>tuple[T, ...]</code>: Tuples of any type T</li> </ul> <p>These types are automatically serialized and stored as BLOBs in the database. Here's an example of using complex types:</p> <pre><code>from typing import Any\nfrom sqliter import Model\n\nclass UserPreferences(Model):\n    tags: list[str] = []  # List of string tags\n    metadata: dict[str, Any] = {}  # Dictionary with string keys and any value type\n    friends: set[int] = set()  # Set of user IDs\n    coordinates: tuple[float, float] = (0.0, 0.0)  # Tuple of two floats\n\n# Create and save an instance\nprefs = UserPreferences(\n    tags=[\"python\", \"sqlite\", \"orm\"],\n    metadata={\"theme\": \"dark\", \"notifications\": True},\n    friends={1, 2, 3},\n    coordinates=(51.5074, -0.1278)\n)\nprefs.save()\n\n# Query and use the complex types\nloaded_prefs = UserPreferences.get(prefs.id)\nprint(loaded_prefs.tags)  # ['python', 'sqlite', 'orm']\nprint(loaded_prefs.metadata[\"theme\"])  # 'dark'\nprint(1 in loaded_prefs.friends)  # True\nprint(loaded_prefs.coordinates)  # (51.5074, -0.1278)\n</code></pre> <p>The complex types are automatically validated using Pydantic's type system, ensuring that only values of the correct type can be stored. When querying, the values are automatically deserialized back into their original Python types.</p> <p>Note that since these types are stored as BLOBs, you cannot perform SQL operations on their contents (like searching or filtering). If you need to search or filter based on these values, you should consider storing them in a different format or in separate tables.</p>"},{"location":"guide/filtering/","title":"Filtering Results","text":"<p>The <code>filter()</code> method in SQLiter supports various filter options to query records, and can be combined with other methods like <code>order()</code>, <code>limit()</code>, and <code>offset()</code> to build more complex queries:</p> <pre><code>result = db.select(User).filter(age__lte=30).limit(10).fetch_all()\n</code></pre> <p>It is possible to both add multiple filters in the same call, and to chain multiple filter calls together:</p> <pre><code>result = db.select(User).filter(age__gte=20, age__lte=30).fetch_all()\n</code></pre> <pre><code>result = db.select(User).filter(age__gte=20).filter(age__lte=30).fetch_all()\n</code></pre>"},{"location":"guide/filtering/#basic-filters","title":"Basic Filters","text":"<ul> <li><code>__eq</code>: Equal to (default if no operator is specified)<ul> <li>Example: <code>name=\"John\"</code> or <code>name__eq=\"John\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#null-checks","title":"Null Checks","text":"<ul> <li><code>__isnull</code>: Is NULL<ul> <li>Example: <code>email__isnull=True</code></li> </ul> </li> <li><code>__notnull</code>: Is NOT NULL<ul> <li>Example: <code>email__notnull=True</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>__lt</code>: Less than<ul> <li>Example: <code>age__lt=30</code></li> </ul> </li> <li><code>__lte</code>: Less than or equal to<ul> <li>Example: <code>age__lte=30</code></li> </ul> </li> <li><code>__gt</code>: Greater than<ul> <li>Example: <code>age__gt=30</code></li> </ul> </li> <li><code>__gte</code>: Greater than or equal to<ul> <li>Example: <code>age__gte=30</code></li> </ul> </li> <li><code>__ne</code>: Not equal to<ul> <li>Example: <code>status__ne=\"inactive\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#list-operations","title":"List Operations","text":"<ul> <li><code>__in</code>: In a list of values<ul> <li>Example: <code>status__in=[\"active\", \"pending\"]</code></li> </ul> </li> <li><code>__not_in</code>: Not in a list of values<ul> <li>Example: <code>category__not_in=[\"archived\", \"deleted\"]</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#string-operations-case-sensitive","title":"String Operations (Case-Sensitive)","text":"<ul> <li><code>__startswith</code>: Starts with<ul> <li>Example: <code>name__startswith=\"A\"</code></li> </ul> </li> <li><code>__endswith</code>: Ends with<ul> <li>Example: <code>email__endswith=\".com\"</code></li> </ul> </li> <li><code>__contains</code>: Contains<ul> <li>Example: <code>description__contains=\"important\"</code></li> </ul> </li> </ul>"},{"location":"guide/filtering/#string-operations-case-insensitive","title":"String Operations (Case-Insensitive)","text":"<ul> <li><code>__istartswith</code>: Starts with (case-insensitive)<ul> <li>Example: <code>name__istartswith=\"a\"</code></li> </ul> </li> <li><code>__iendswith</code>: Ends with (case-insensitive)<ul> <li>Example: <code>email__iendswith=\".COM\"</code></li> </ul> </li> <li><code>__icontains</code>: Contains (case-insensitive)<ul> <li>Example: <code>description__icontains=\"IMPORTANT\"</code></li> </ul> </li> </ul>"},{"location":"guide/foreign-keys/","title":"Foreign Keys","text":"<p>Foreign keys allow you to define relationships between models, enabling referential integrity in your database. When you define a foreign key, SQLiter ensures that the referenced record exists and automatically handles actions when the referenced record is deleted or updated.</p>"},{"location":"guide/foreign-keys/#defining-foreign-keys","title":"Defining Foreign Keys","text":"<p>To define a foreign key, use the <code>ForeignKey()</code> function when declaring a model field. The foreign key field stores the primary key (<code>pk</code>) of the referenced model:</p> <pre><code>from typing import Annotated\nfrom sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n</code></pre> <p>Important</p> <p>The referenced table (<code>Author</code>) must be created before the table that references it (<code>Book</code>).</p> <p>Note</p> <p>The default foreign key action is <code>RESTRICT</code> for both <code>on_delete</code> and <code>on_update</code>. This means that by default, SQLiter will prevent deletion or updates of referenced records if other records reference them. This is the safest behavior and matches SQLite's default. You must explicitly specify <code>on_delete=\"CASCADE\"</code> or <code>on_update=\"CASCADE\"</code> if you want cascading behavior.</p>"},{"location":"guide/foreign-keys/#foreign-key-naming-convention","title":"Foreign Key Naming Convention","text":"<p>By default, the foreign key column in the database will be named <code>{field_name}_id</code>. In the example above, the field <code>author_id</code> creates a column named <code>author_id</code> in the <code>books</code> table.</p> <p>You can customize the column name using the <code>db_column</code> parameter:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        db_column=\"writer_id\",\n        on_delete=\"CASCADE\"\n    )\n</code></pre>"},{"location":"guide/foreign-keys/#type-checking","title":"Type Checking","text":"<p>The examples in this documentation show the simplest syntax that works at runtime and with most type checkers:</p> <pre><code>author_id: int = ForeignKey(\n    Author,\n    on_delete=\"CASCADE\",\n    on_update=\"CASCADE\"\n)\nauthor_id: int | None = ForeignKey(\n    Author, on_delete=\"SET NULL\", null=True, default=None\n)\n</code></pre> <p>If you use strict type checking with <code>mypy</code>, you can wrap the type and <code>ForeignKey()</code> with <code>Annotated</code> for explicit type metadata:</p> <pre><code>from typing import Annotated\n\nauthor_id: Annotated[\n    int,\n    ForeignKey(Author, on_delete=\"CASCADE\", on_update=\"CASCADE\")\n]\nauthor_id: Annotated[\n    int | None,\n    ForeignKey(Author, on_delete=\"SET NULL\", null=True)\n] = None\n</code></pre> <p>This is optional for foreign keys but required for the <code>unique()</code> constraint (see Models).</p>"},{"location":"guide/foreign-keys/#foreign-key-actions","title":"Foreign Key Actions","text":"<p>Foreign keys support actions that define what happens when the referenced record is deleted (<code>on_delete</code>) or updated (<code>on_update</code>). The following actions are available:</p>"},{"location":"guide/foreign-keys/#cascade","title":"CASCADE","text":"<p>When the referenced record is deleted, all records that reference it are also deleted. When the referenced record's primary key is updated, the foreign key values are updated to match. You must explicitly specify <code>on_delete=\"CASCADE\"</code> and <code>on_update=\"CASCADE\"</code> to use this behavior:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\nauthor = db.insert(Author(name=\"Jane Austen\", email=\"jane@example.com\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author_id=author.pk))\n\n# Deleting the author will also delete the book\ndb.delete(Author, author.pk)\n\n# The book is now deleted too\nbooks = db.select(Book).filter(author_id=author.pk).fetch_all()\nassert len(books) == 0\n</code></pre>"},{"location":"guide/foreign-keys/#set-null","title":"SET NULL","text":"<p>When the referenced record is deleted or updated, the foreign key field is set to <code>NULL</code>. This requires <code>null=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int | None = ForeignKey(\n        Author, on_delete=\"SET NULL\", null=True, default=None\n    )\n</code></pre> <p>Important</p> <p>You must set <code>null=True</code> when using <code>SET NULL</code>. SQLiter will raise a <code>ValueError</code> if you try to use <code>SET NULL</code> without <code>null=True</code>.</p>"},{"location":"guide/foreign-keys/#restrict","title":"RESTRICT","text":"<p>Prevents deletion or update of the referenced record if other records reference it. This is the default behavior in SQLiter and matches SQLite's default when foreign keys are enabled:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"RESTRICT\")\n\nauthor = db.insert(Author(name=\"Jane Austen\", email=\"jane@example.com\"))\nbook = db.insert(Book(title=\"Pride and Prejudice\", author_id=author.pk))\n\n# This will raise a ForeignKeyConstraintError\ndb.delete(Author, author.pk)\n</code></pre>"},{"location":"guide/foreign-keys/#no-action","title":"NO ACTION","text":"<p>Similar to <code>RESTRICT</code> in SQLite. The deletion or update is prevented if other records reference the record:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, on_delete=\"NO ACTION\")\n</code></pre>"},{"location":"guide/foreign-keys/#nullable-foreign-keys","title":"Nullable Foreign Keys","text":"<p>By default, foreign key fields are required (NOT NULL). You can make them optional by setting <code>null=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int | None = ForeignKey(\n        Author, on_delete=\"SET NULL\", null=True, default=None\n    )\n\n# Insert a book without an author\nbook = db.insert(Book(title=\"Anonymous Book\", author_id=None))\n</code></pre>"},{"location":"guide/foreign-keys/#one-to-one-relationships","title":"One-to-One Relationships","text":"<p>To create a one-to-one relationship, use <code>unique=True</code>:</p> <pre><code>class Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(Author, unique=True)\n</code></pre> <p>This ensures that each author can be referenced by only one book.</p>"},{"location":"guide/foreign-keys/#querying-with-foreign-keys","title":"Querying with Foreign Keys","text":"<p>You can filter records using the foreign key column:</p> <pre><code># Get all books by a specific author\nbooks = db.select(Book).filter(author_id=author.pk).fetch_all()\n\n# Get all books without an author\norphaned_books = db.select(Book).filter(author_id=None).fetch_all()\n</code></pre>"},{"location":"guide/foreign-keys/#automatic-indexing","title":"Automatic Indexing","text":"<p>SQLiter automatically creates an index on foreign key columns to improve query performance. This is done when you create the table:</p> <pre><code>db.create_table(Book)  # Automatically creates index on author_id\n</code></pre>"},{"location":"guide/foreign-keys/#foreign-key-errors","title":"Foreign Key Errors","text":"<p>SQLiter provides specific exceptions for foreign key constraint violations:</p> <ul> <li><code>ForeignKeyConstraintError</code>: Raised when a foreign key constraint is violated,   such as trying to delete a record that is referenced by other records with   <code>RESTRICT</code> or <code>NO ACTION</code> action.</li> <li><code>InvalidForeignKeyError</code>: Raised when an invalid foreign key configuration is   detected, such as using <code>SET NULL</code> without <code>null=True</code>.</li> </ul>"},{"location":"guide/foreign-keys/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing foreign key usage with CASCADE deletion:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel, ForeignKey\n\nclass Author(BaseDBModel):\n    name: str\n    email: str\n\nclass Book(BaseDBModel):\n    title: str\n    author_id: int = ForeignKey(\n        Author,\n        on_delete=\"CASCADE\",\n        on_update=\"CASCADE\"\n    )\n\n# Create database and tables\ndb = SqliterDB(\":memory:\")\ndb.create_table(Author)\ndb.create_table(Book)\n\n# Insert an author\nauthor = db.insert(Author(\n    name=\"Jane Austen\",\n    email=\"jane@example.com\"\n))\n\n# Insert books by this author\nbook1 = db.insert(Book(\n    title=\"Pride and Prejudice\",\n    author_id=author.pk\n))\nbook2 = db.insert(Book(\n    title=\"Sense and Sensibility\",\n    author_id=author.pk\n))\n\n# Query books by author\njane_books = db.select(Book).filter(author_id=author.pk).fetch_all()\nprint(f\"Jane has {len(jane_books)} books\")\n\n# Delete the author (CASCADE will delete the books)\ndb.delete(Author, author.pk)\n\n# Verify books are deleted\nremaining_books = db.select(Book).fetch_all()\nassert len(remaining_books) == 0\n</code></pre>"},{"location":"guide/foreign-keys/#future-enhancements","title":"Future Enhancements","text":"<p>Phase 1 of foreign key support (current implementation) focuses on constraint enforcement and explicit <code>_id</code> field access. Phase 2 will add ORM-style conveniences such as:</p> <ul> <li>Lazy loading: <code>book.author.name</code> instead of <code>book.author_id</code></li> <li>Reverse relationships: <code>author.books.fetch_all()</code></li> <li>String references for forward references</li> </ul> <p>See the TODO for more details on planned enhancements.</p>"},{"location":"guide/guide/","title":"SQLiter Overview","text":"<p>SQLiter is a lightweight Python library designed to simplify database operations using Pydantic models. It provides a range of functionality including table creation, CRUD operations, querying, filtering, and more. This overview briefly introduces each feature.</p>"},{"location":"guide/guide/#basic-setup","title":"Basic Setup","text":"<p>To get started, import the necessary modules and define a Pydantic model for your table:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n# Create a database connection\ndb = SqliterDB(\"example.db\")\n</code></pre>"},{"location":"guide/guide/#table-creation","title":"Table Creation","text":"<p>SQLiter allows you to create tables automatically based on your models:</p> <pre><code>db.create_table(User)\n</code></pre> <p>This creates a table for the <code>User</code> model, with fields based on the attributes of the model.</p>"},{"location":"guide/guide/#inserting-records","title":"Inserting Records","text":"<p>Inserting records is straightforward with SQLiter:</p> <pre><code>user = User(name=\"John Doe\", age=30, email=\"john@example.com\")\nnew_record = db.insert(user)\n</code></pre> <p>If successful, <code>new_record</code> will contain a model the same as was passed to it, but including the newly-created primary key value.</p>"},{"location":"guide/guide/#basic-queries","title":"Basic Queries","text":"<p>You can easily query all records from a table:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre>"},{"location":"guide/guide/#filtering-results","title":"Filtering Results","text":"<p>SQLiter allows filtering of results using various conditions:</p> <pre><code>young_users = db.select(User).filter(age__lt=30).fetch_all()\n</code></pre>"},{"location":"guide/guide/#fetching-records","title":"Fetching Records","text":"<p>SQLiter provides methods to fetch multiple, single, or the last record in a table.</p>"},{"location":"guide/guide/#fetching-all-records","title":"Fetching All Records","text":"<p>The <code>fetch_all()</code> method retrieves all records from the table that match the query or filter:</p> <pre><code>all_users = db.select(User).fetch_all()\n</code></pre> <p>This returns a list of all matching records. If no record matches, an empty list is returned.</p>"},{"location":"guide/guide/#fetching-one-record","title":"Fetching One Record","text":"<p>The <code>fetch_one()</code> method retrieves a single record that matches the query or filter:</p> <pre><code>result = db.select(User).filter(name=\"John Doe\").fetch_one()\n</code></pre> <p>If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#fetching-the-last-record","title":"Fetching the Last Record","text":"<p>The <code>fetch_last()</code> method retrieves the last record in the table, typically based on the <code>rowid</code>:</p> <pre><code>last_user = db.select(User).fetch_last()\n</code></pre> <p>This fetches the most recently inserted record. If no record is found, <code>None</code> is returned.</p>"},{"location":"guide/guide/#updating-records","title":"Updating Records","text":"<p>Records can be updated seamlessly. Simply modify the fields of the model instance and pass that to the <code>update()</code> method:</p> <pre><code>user.age = 31\ndb.update(user)\n</code></pre>"},{"location":"guide/guide/#deleting-records","title":"Deleting Records","text":"<p>SQLiter provides two ways to delete records:</p>"},{"location":"guide/guide/#single-record-deletion","title":"Single Record Deletion","text":"<p>To delete a single record by its primary key:</p> <pre><code>db.delete(User, 1)\n</code></pre> <p>Important</p> <p>The single record deletion method will raise: - <code>RecordNotFoundError</code> if the record with the specified primary key is not found - <code>RecordDeletionError</code> if there's an error during the deletion process</p> <p>Note</p> <p>You can get the primary key value from the record or model instance itself, e.g., <code>new_record.pk</code> and pass that as the second argument to the <code>delete()</code> method:</p> <pre><code>db.delete(User, new_record.pk)\n</code></pre>"},{"location":"guide/guide/#query-based-deletion","title":"Query-Based Deletion","text":"<p>You can also delete multiple records that match specific criteria using a query. The <code>delete()</code> method will delete all records that match the query and return the number of records deleted:</p> <pre><code># Delete all users over 30\ndeleted_count = db.select(User).filter(age__gt=30).delete()\n\n# Delete inactive users in a specific age range\ndeleted_count = db.select(User).filter(\n    age__gte=25,\n    age__lt=40,\n    status=\"inactive\"\n).delete()\n</code></pre> <p>Note</p> <p>The query-based delete operation ignores any <code>limit()</code>, <code>offset()</code>, or <code>order()</code> clauses that might be in the query chain. It will always delete ALL records that match the filter conditions.</p>"},{"location":"guide/guide/#advanced-query-features","title":"Advanced Query Features","text":""},{"location":"guide/guide/#ordering","title":"Ordering","text":"<p>SQLiter supports ordering of results by specific fields:</p> <pre><code>ordered_users = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre>"},{"location":"guide/guide/#limiting-and-offsetting","title":"Limiting and Offsetting","text":"<p>Pagination is supported through <code>limit()</code> and <code>offset()</code>:</p> <pre><code>paginated_users = db.select(User).limit(10).offset(20).fetch_all()\n</code></pre>"},{"location":"guide/guide/#transactions","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager. This ensures that a group of operations are executed atomically, meaning either all of the operations succeed or none of them are applied.</p> <p>To use transactions, simply wrap the operations within a <code>with</code> block:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs here, both inserts will be rolled back\n</code></pre> <p>If an error occurs within the transaction block, all changes made inside the block will be rolled back automatically.</p> <p>If no errors occur, the transaction will commit and changes will be saved. The <code>close()</code> method will also be called when the context manager exits, so there is no need to call it manually.</p>"},{"location":"guide/guide/#closing-the-database","title":"Closing the Database","text":"<p>Always remember to close the connection when you're done:</p> <pre><code>db.close()\n</code></pre> <p>Note</p> <p>If you are using the database connection as a context manager (see above), you do not need to call <code>close()</code> explicitly. The connection will be closed automatically when the context manager exits, and any changes will be committed.</p> <p>This is a quick look at the core features of SQLiter. For more details on each functionality, see the next section.</p>"},{"location":"guide/models/","title":"Models","text":"<p>Each individual table in your database should be represented by a model. This model should inherit from <code>BaseDBModel</code> and define the fields that should be stored in the table. Under the hood, the model is a Pydantic model, so you can use all the features of Pydantic models, such as default values, type hints, and validation.</p>"},{"location":"guide/models/#defining-models","title":"Defining Models","text":"<p>Models are defined like this:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n</code></pre> <p>You can create as many Models as you need, each representing a different table in your database. The fields in the model will be used to create the columns in the table.</p> <p>Important</p> <ul> <li>Type-hints are REQUIRED for each field in the model.</li> <li>The Model automatically creates an auto-incrementing integer primary key for each table called <code>pk</code>, you do not need to define it yourself.</li> <li>The Model automatically creates a <code>created_at</code> and <code>updated_at</code> field which is an integer Unix timestamp IN UTC when the record was created or last updated. You can convert this timestamp to any format and timezone that you need.</li> </ul>"},{"location":"guide/models/#field-types","title":"Field Types","text":"<p>The following field types are currently supported:</p> <p>Basic Types:</p> <ul> <li><code>str</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>bool</code></li> <li><code>date</code></li> <li><code>datetime</code></li> <li><code>bytes</code></li> </ul> <p>Complex Types:</p> <ul> <li><code>list[T]</code> - Lists of any type T</li> <li><code>dict[K, V]</code> - Dictionaries with keys of type K and values of type V</li> <li><code>set[T]</code> - Sets of any type T</li> <li><code>tuple[T, ...]</code> - Tuples of any type T</li> </ul> <p>Complex types are automatically serialized and stored as BLOBs in the database. For more details on using complex types, see the Fields Guide.</p>"},{"location":"guide/models/#foreign-key-fields","title":"Foreign Key Fields","text":"<p>Foreign keys allow you to define relationships between models, enabling referential integrity in your database. See the Foreign Keys Guide for detailed information on defining and using foreign key relationships.</p>"},{"location":"guide/models/#table-configuration","title":"Table Configuration","text":"<p>You can add indexes to your table by specifying the <code>indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        indexes = [\"name\", \"email\"]\n</code></pre> <p>This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p>"},{"location":"guide/models/#adding-unique-indexes","title":"Adding Unique Indexes","text":"<p>You can add unique indexes to your table by specifying the <code>unique_indexes</code> attribute in the <code>Meta</code> class. This should be a list of strings, each string being the name of an existing field in the model that should be indexed.</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        unique_indexes = [\"email\"]\n</code></pre> <p>These will ensure that all values in this field are unique. This is in addition to the primary key index (<code>pk</code>) that is automatically created.</p> <p>Tip</p> <p>You can specify both <code>indexes</code> and <code>unique_indexes</code> in the <code>Meta</code> class if you need to.</p>"},{"location":"guide/models/#unique-fields","title":"Unique Fields","text":"<p>Caution</p> <p>In version 0.9.1 and below, this flag was <code>Unique()</code> with a capital 'U'. This has now been deprecated and the current <code>unique()</code> with a lower case 'u' is the supported command.</p> <p>The old functionality still works but will raise a deprecation warning and will probably be removed in future versions.</p> <p>You can also specify that a field should be all unique values by using the <code>unique()</code> method from the <code>sqliter.model</code> module. This will ensure that all values in this field are unique.</p> <pre><code>from typing import Annotated\nfrom sqliter.model import BaseDBModel, unique\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: Annotated[str, unique()]\n</code></pre> <p>This will raise either a <code>RecordInsertionError</code> or <code>RecordUpdateError</code> if you try to insert or update a record with a duplicate value in the chosen field.</p> <p>Tip</p> <p>Using <code>Annotated</code> is optional, but without it your code wil not pass type-checking with <code>mypy</code>. It will work fine at runtime but is not recommended:</p> <pre><code>email: str = unique()\n</code></pre> <p>This will give the following Mypy error:</p> <pre><code>error: Incompatible types in assignment (expression has type \"unique\", variable has type \"str\")  [assignment]\n</code></pre> <p>If you DONT use a static type checker (<code>mypy</code>, <code>ty</code> or similar) then you can leave off the <code>Annotated</code>.</p>"},{"location":"guide/models/#custom-table-name","title":"Custom Table Name","text":"<p>By default, the table name will be the same as the model name, converted to 'snake_case' and pluralized (e.g., <code>User</code> -&gt; <code>users</code>). Also, any 'Model' suffix will be removed (e.g., <code>UserModel</code> -&gt; <code>users</code>). To override this behavior, you can specify the <code>table_name</code> in the <code>Meta</code> class manually as below:</p> <pre><code>from sqliter.model import BaseDBModel\n\nclass User(BaseDBModel):\n    name: str\n    age: int\n    email: str\n\n    class Meta:\n        table_name = \"people\"\n</code></pre> <p>Note</p> <p>The pluralization is pretty basic by default, and just consists of adding an 's' if not already there. This will fail on words like 'person' or 'child'. If you need more advanced pluralization, you can install the <code>extras</code> package as mentioned in the installation. Of course, you can always specify the <code>table_name</code> manually in this case!</p>"},{"location":"guide/models/#model-classmethods","title":"Model Classmethods","text":"<p>There are 2 useful methods you can call on your models. Note that they are Class Methods so should be called on the Model class itself, not an instance of the model:</p>"},{"location":"guide/models/#get_table_name","title":"<code>get_table_name()</code>","text":"<p>This method returns the actual table name for the model either specified or automatically generated. This is useful if you need to do any raw SQL queries.</p> <pre><code>table_name = User.get_table_name()\n</code></pre>"},{"location":"guide/models/#get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>This simply returns the name of the primary key for that table. At the moment, this will always return the string <code>pk</code> but this may change in the future.</p> <pre><code>primary_key = User.get_primary_key()\n</code></pre>"},{"location":"guide/ordering/","title":"Ordering","text":"<p>For now we only support ordering by the single field. You can specify the field to order by and whether to reverse the order:</p> <pre><code>results = db.select(User).order(\"age\", reverse=True).fetch_all()\n</code></pre> <p>This will order the results by the <code>age</code> field in descending order.</p> <p>If you do not specify a field, the default is to order by the primary key field:</p> <pre><code>results = db.select(User).order().fetch_all()\n</code></pre> <p>This will order the results by the primary key field in ascending order.</p> <p>Warning</p> <p>Previously ordering was done using the <code>direction</code> parameter with <code>asc</code> or <code>desc</code>, but this has been deprecated in favor of using the <code>reverse</code> parameter. The <code>direction</code> parameter still works, but will raise a <code>DeprecationWarning</code> and will be removed in a future release.</p>"},{"location":"guide/properties/","title":"SqliterDB Properties","text":""},{"location":"guide/properties/#overview","title":"Overview","text":"<p>The <code>SqliterDB</code> class includes several useful read-only properties that provide insight into the current state of the database. These properties allow users to easily query key database attributes, such as the filename, whether the database is in memory, auto-commit status, and the list of tables.</p>"},{"location":"guide/properties/#properties","title":"Properties","text":"<ol> <li> <p><code>filename</code>    Returns the filename of the database, or <code>None</code> if the database is in-memory.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(db_filename=\"test.db\")\nprint(db.filename)  # Output: 'test.db'\n</code></pre> </li> <li> <p><code>is_memory</code>    Returns <code>True</code> if the database is in-memory, otherwise <code>False</code>.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(memory=True)\nprint(db.is_memory)  # Output: True\n</code></pre> </li> <li> <p><code>is_autocommit</code>    Returns <code>True</code> if the database is in auto-commit mode, otherwise <code>False</code>.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(auto_commit=True)\nprint(db.is_autocommit)  # Output: True\n</code></pre> </li> <li> <p><code>table_names</code>    Returns a list of all user-defined table names in the database. The property temporarily reconnects if the connection is closed.</p> <p>Usage Example:</p> <pre><code>db = SqliterDB(memory=True)\ndb.create_table(User)  # Assume 'User' is a predefined model\nprint(db.table_names)  # Output: ['user']\n</code></pre> </li> </ol>"},{"location":"guide/properties/#property-details","title":"Property Details","text":""},{"location":"guide/properties/#filename","title":"<code>filename</code>","text":"<p>This property allows users to retrieve the current database filename. For in-memory databases, this property returns <code>None</code>, as no filename is associated with an in-memory database.</p> <ul> <li>Type: <code>Optional[str]</code></li> <li>Returns: The database filename or <code>None</code> if in memory.</li> </ul>"},{"location":"guide/properties/#is_memory","title":"<code>is_memory</code>","text":"<p>This property indicates whether the database is in memory. It simplifies the check for memory-based databases, returning <code>True</code> for in-memory and <code>False</code> otherwise.</p> <ul> <li>Type: <code>bool</code></li> <li>Returns: <code>True</code> if the database is in memory, otherwise <code>False</code>.</li> </ul>"},{"location":"guide/properties/#is_autocommit","title":"<code>is_autocommit</code>","text":"<p>This property returns whether the database is in auto-commit mode. If <code>auto_commit</code> is enabled, every operation is automatically committed without requiring an explicit <code>commit()</code> call.</p> <ul> <li>Type: <code>bool</code></li> <li>Returns: <code>True</code> if auto-commit mode is enabled, otherwise <code>False</code>.</li> </ul>"},{"location":"guide/properties/#table_names","title":"<code>table_names</code>","text":"<p>This property retrieves a list of user-defined table names from the database. It does not include system tables (<code>sqlite_</code>). If the database connection is closed, this property will temporarily reconnect to query the table names and close the connection afterward.</p> <ul> <li>Type: <code>list[str]</code></li> <li>Returns: A list of user-defined table names in the database.</li> <li>Raises: <code>DatabaseConnectionError</code> if the database connection fails to re-establish.</li> </ul>"},{"location":"guide/properties/#example","title":"Example","text":"<p>Here's a complete example demonstrating the use of the new properties:</p> <pre><code>from sqliter import SqliterDB\nfrom sqliter.model import BaseDBModel\n\n# Define a simple model\nclass User(BaseDBModel):\n    id: int\n    name: str\n\n# Create an in-memory database\ndb = SqliterDB(memory=True)\ndb.create_table(User)\n\n# Access properties\nprint(db.filename)        # Output: None\nprint(db.is_memory)       # Output: True\nprint(db.is_autocommit)   # Output: True (this is the default)\nprint(db.table_names)     # Output: ['user']\n</code></pre>"},{"location":"guide/tables/","title":"Table Operations","text":"<p>All table operations work on a Pydantic Model you have defined based on <code>BaseDBModel</code>. You can have as many tables as you need, but each must have it's own Model defined.</p>"},{"location":"guide/tables/#creating-tables","title":"Creating Tables","text":"<p>To create a table, you simply pass your Model class to the <code>create_table()</code> method:</p> <pre><code>db.create_table(User)\n</code></pre> <p>Important</p> <p>The Table is created regardless of the <code>auto_commit</code> setting.</p> <p>By default, if the table already exists, it will not be created again and no error will be raised. If you want to raise an exception if the table already exists, you can set <code>exists_ok=False</code>:</p> <pre><code>db.create_table(User, exists_ok=False)\n</code></pre> <p>This will raise a <code>TableCreationError</code> if the table already exists.</p> <p>There is a complementary flag <code>force=True</code> which will drop the table if it exists and then recreate it. This may be useful if you are changing the table structure:</p> <pre><code>db.create_table(User, force=True)\n</code></pre> <p>This defaults to <code>False</code>.</p>"},{"location":"guide/tables/#dropping-tables","title":"Dropping Tables","text":"<p>To drop a table completely from the database use the <code>drop_table</code> method</p> <pre><code>db.drop_table(User)\n</code></pre> <p>Caution</p> <p>This is non-reversible and will you will lose all data in that table.</p> <p>The Table is dropped regardless of the <code>auto_commit</code> setting.</p>"},{"location":"guide/transactions/","title":"Transactions","text":"<p>SQLiter supports transactions using Python's context manager:</p> <pre><code>with db:\n    db.insert(User(name=\"Alice\", age=30, email=\"alice@example.com\"))\n    db.insert(User(name=\"Bob\", age=35, email=\"bob@example.com\"))\n    # If an exception occurs, the transaction will be rolled back\n</code></pre> <p>Warning</p> <p>Using the context manager will automatically commit the transaction at the end (unless an exception occurs), regardless of the <code>auto_commit</code> setting.</p> <p>the <code>close()</code> method will also be called when the context manager exits, so you do not need to call it manually.</p>"},{"location":"todo/","title":"TODO","text":"<p>Items marked with  are high priority.</p>"},{"location":"todo/#general-plans-and-ideas","title":"General Plans and Ideas","text":"<ul> <li>add ability to inspect existing SQLite databases and generate Pydantic models   dynamically, including CLI tool for schema dumping.</li> <li>add an 'execute' method to the main class to allow executing arbitrary SQL   queries which can be chained to the 'find_first' etc methods or just used   directly.</li> <li>add a <code>rollback</code> method to the main class to allow manual rollbacks.</li> <li> allow adding foreign keys and relationships to each table.</li> <li>add a migration system to allow updating the database schema without losing   data.</li> <li>add more tests where 'auto_commit' is set to False to ensure that commit is   not called automatically.</li> <li> perhaps add a <code>JSON</code> field type to allow storing JSON data in a field,   and an <code>Object</code> field type to allow storing arbitrary Python objects? Perhaps   a <code>Binary</code> field type to allow storing arbitrary binary data? (just uses the   existing <code>bytes</code> mapping but more explicit)</li> <li>Consider performance optimizations for field validation:<ul> <li>Benchmark shows ~50% overhead for field assignments with validation</li> <li>Potential solutions:<ul> <li>Add a \"fast mode\" configuration option</li> <li>Create bulk update methods that temporarily disable validation</li> <li>Optimize validation for specific field types</li> </ul> </li> </ul> </li> <li>on update, check if the model has actually changed before sending the update   to the database. This will prevent unnecessary updates and leave the   <code>updated_at</code> correct. However, this will always require a query to the   database to check the current values and so in large batch updates this could   have a considerable performance impact. Probably best to gate this behind a   flag.</li> </ul>"},{"location":"todo/#housekeeping","title":"Housekeeping","text":"<ul> <li>Tidy up the test suite - remove any duplicates, sort them into logical files   (many already are), try to reduce and centralize fixtures.</li> </ul>"},{"location":"todo/#documentation","title":"Documentation","text":"<ul> <li>Nothing at the moment.</li> </ul>"},{"location":"todo/#potential-filter-additions","title":"Potential Filter Additions","text":"<ul> <li>Range filter<ul> <li><code>__range</code>: For selecting values within a specific range</li> </ul> </li> </ul> <ul> <li>Date and time filters<ul> <li><code>__year</code>, <code>__month</code>, <code>__day</code>: For filtering date fields</li> <li><code>__date</code>: For filtering the date part of a datetime field</li> </ul> </li> </ul> <ul> <li>Regular expression filter<ul> <li><code>__regex</code>: For more complex string matching</li> </ul> </li> </ul> <ul> <li>Numeric operations<ul> <li><code>__abs</code>: Absolute value comparison</li> </ul> </li> </ul> <ul> <li>Boolean filters<ul> <li><code>__istrue</code>, <code>__isfalse</code>: Explicit boolean checks</li> </ul> </li> </ul> <ul> <li>List field operations<ul> <li><code>__contains_all</code>: Check if a list field contains all specified values</li> <li><code>__contains_any</code>: Check if a list field contains any of the specified values</li> </ul> </li> </ul> <ul> <li>Negation filter<ul> <li><code>__not</code>: General negation for other filters</li> </ul> </li> </ul> <ul> <li>Distinct filter<ul> <li><code>__distinct</code>: To get distinct values in a field</li> </ul> </li> </ul>"}]}